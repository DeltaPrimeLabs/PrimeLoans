const fs = require('fs');
const ethers = require("ethers");
const rpcUrl = 'https://arb1.arbitrum.io/rpc'; // Replace with your RPC URL
const provider = new ethers.providers.JsonRpcProvider(rpcUrl);

let lastBlockNumberBeforeFirstExploitWithdrawalPerPool = {
    "BtcPoolTUP": 253995298 - 1,
    "DaiPoolTUP": 253995304 - 1,
    "UsdcPoolTUP": 253995296 - 1,
    "WethPoolTUP": 253995300 - 1,
    "ArbPoolTUP": 253995302 - 1,
}

let blockNumberOfPoolPausePerPool = {
    "BtcPoolTUP": 254085961 + 1,
    "DaiPoolTUP": 254085961 + 1,
    "UsdcPoolTUP": 254085961 + 1,
    "WethPoolTUP": 254085961 + 1,
    "ArbPoolTUP": 254085961 + 1,
}

const erc20Abi = [
    // balanceOf
    {
        "constant": true,
        "inputs": [
            {
                "name": "_owner",
                "type": "address"
            }
        ],
        "name": "balanceOf",
        "outputs": [
            {
                "name": "balance",
                "type": "uint256"
            }
        ],
        "type": "function"
    },
    // totalSupply
    {
        "constant": true,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "type": "function"
    },
    // decimals
    {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [
            {
                "name": "",
                "type": "uint8"
            }
        ],
        "type": "function"
    }
];
const factoryAbi = [
    {
        "inputs": [],
        "name": "getAllLoans",
        "outputs": [
            {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    }
];
const poolAbi = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "_user",
                "type": "address"
            }
        ],
        "name": "getBorrowed",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    // totalSupply
    {
        "constant": true,
        "inputs": [],
        "name": "totalSupply",
        "outputs": [
            {
                "name": "",
                "type": "uint256"
            }
        ],
        "type": "function"
    },
    // decimals
    {
        "constant": true,
        "inputs": [],
        "name": "decimals",
        "outputs": [
            {
                "name": "",
                "type": "uint8"
            }
        ],
        "type": "function"
    },
    {
        "constant": true,
        "inputs": [],
        "name": "tokenAddress",
        "outputs": [
            {
                "name": "",
                "type": "address"
            }
        ],
        "type": "function"
    }
];

let blockNumberOfPrimeAccountsPause = 254053985;

const pools = {
    "arbitrum": [
        "0x8FE3842e0B7472a57f2A2D56cF6bCe08517A1De0",       // USDC
        "0x0BeBEB5679115f143772CfD97359BBcc393d46b3",    // WETH
        "0x2B8C610F3fC6F883817637d15514293565C3d08A",    // ARB
        "0x5CdE36c23f0909960BA4D6E8713257C6191f8C35",    // BTC
        "0xd5E8f691756c3d7b86FD8A89A06497D38D362540"     // DAI
    ],
    "avalanche": [
        "0xD26E504fc642B96751fD55D3E68AF295806542f5",   // AVAX
        "0xd222e10D7Fe6B7f9608F14A8B5Cf703c74eFBcA1",   // USDT
        "0x2323dAC85C6Ab9bd6a8B5Fb75B0581E31232d12b",   // USDC
        "0x475589b0Ed87591A893Df42EC6076d2499bB63d0",   // BTC
        "0xD7fEB276ba254cD9b34804A986CE9a8C3E359148"    // ETH
    ]
}

const poolAddressToPoolNameMapping = {
    "0x8FE3842e0B7472a57f2A2D56cF6bCe08517A1De0": "UsdcPoolTUP",
    "0x0BeBEB5679115f143772CfD97359BBcc393d46b3": "WethPoolTUP",
    "0x2B8C610F3fC6F883817637d15514293565C3d08A": "ArbPoolTUP",
    "0x5CdE36c23f0909960BA4D6E8713257C6191f8C35": "BtcPoolTUP",
    "0xd5E8f691756c3d7b86FD8A89A06497D38D362540": "DaiPoolTUP"
}

async function getDepositorsAddressesFromChainbase(chain) {
    let chainId;
    let depositors = {};

    if (chain === "arbitrum") {
        chainId = 42161;
    } else if (chain === "avalanche") {
        chainId = 43114;
    }

    for (let pool of pools[chain]) {
        let page = 1;
        let limit = 100;
        let hasMoreDepositors = true;

        while (hasMoreDepositors) {
            const url = `https://api.chainbase.online/v1/token/holders?chain_id=${chainId}&contract_address=${pool}&page=${page}&limit=${limit}`;
            const response = await fetch(url, {
                headers: {
                    "x-api-key": "2ke1uWajgBBBy7k9ObLuaaOyltE"
                }
            });
            const json = await response.json();

            if (json.data && json.data.length > 0) {
                depositors[pool] = depositors[pool] ? [...depositors[pool], ...json.data] : json.data;
                page++;

                await new Promise((resolve, reject) => setTimeout(resolve, 600));
            } else {
                hasMoreDepositors = false;
            }
        }
        depositors[pool] = [...new Set(depositors[pool])];
        console.log(`Found ${depositors[pool].length} depositors for ${pool} on ${chain} chain.`);
        depositors[pool] = mergeChainbaseDepositorsWithArbiscanHoldersJson(pool, depositors);
    }

    return depositors;
}

function mergeChainbaseDepositorsWithArbiscanHoldersJson(poolAddress, chainbaseDepositors){
    const arbiscanHoldersJson = require(`./depositorsFromArbiscan/export-tokenholders-for-contract-${poolAddress}.json`);

    const chainbaseDepositorsAddressesSet = new Set(chainbaseDepositors[poolAddress]);
    const arbiscanHoldersAddressesSet = new Set(arbiscanHoldersJson);

    const union = new Set([...chainbaseDepositorsAddressesSet, ...arbiscanHoldersAddressesSet]);

    console.log(`Chainbase depositors: ${chainbaseDepositors[poolAddress].length}`);
    console.log(`Arbiscan holders: ${arbiscanHoldersJson.length}`);
    console.log(`Union: ${union.size}`);
    return [...union];
}

function chunkArray(array, size) {
    const result = [];
    for (let i = 0; i < array.length; i += size) {
        result.push(array.slice(i, i + size));
    }
    return result;
}

async function calculateDepositorsBalancesInBatches(batchSize = 100) {
    console.time('calculateDepositorsBalancesInBatches');

    const depositors = await getDepositorsAddressesFromChainbase("arbitrum");
    let originalDeposits = {};

    for (let poolAddress in depositors) {
        console.log(`Calculating original deposits for ${poolAddress}`);

        let poolContract = new ethers.Contract(poolAddress, erc20Abi, provider);
        let poolContractDecimals = await poolContract.decimals();

        // Initialize deposits for this pool
        originalDeposits[poolAddress] = {};

        let poolName = poolAddressToPoolNameMapping[poolAddress];
        // Get the blockTag (block number) for this pool
        let blockTag = blockNumberOfPoolPausePerPool[poolName];
        console.log(`Block number for ${poolAddress}: ${blockTag}`);

        let depositorAddresses = depositors[poolAddress];
        let batches = chunkArray(depositorAddresses, batchSize);

        for (let batch of batches) {
            let promises = [];
            let depositorsInBatch = [];

            for (let depositor of batch) {
                const lowerCaseDepositor = depositor.toLowerCase();

                if (lowerCaseDepositor === "0xd550cfea0bffdc81b2dee7b6d915d9d9e31d83a2") {
                    console.log('Skipping the exploiter address');
                    continue;
                }

                if (lowerCaseDepositor === "0x6b9836d18978a2e865a935f12f4f958317da4619") {
                    console.log('Skipping the stability pool address');
                    continue;
                }

                depositorsInBatch.push(depositor);

                let balancePromise = poolContract.balanceOf(depositor, {
                    blockTag: blockTag
                });
                promises.push(balancePromise);
            }

            let balances = await Promise.all(promises);

            for (let i = 0; i < balances.length; i++) {
                let depositor = depositorsInBatch[i];
                let balance = balances[i];
                originalDeposits[poolAddress][depositor] = ethers.utils.formatUnits(balance, poolContractDecimals);
            }
        }

        console.log(`blockTag: ${blockTag}`);
        // After processing all depositors for this pool, write the data to a JSON file
        let dataToSave = {
            poolAddress: poolAddress,
            blockNumber: blockTag,
            poolName: poolName,
            deposits: originalDeposits[poolAddress]
        };

        // Sanitize the pool name for use in a filename
        let sanitizedPoolName = poolName.replace(/[:/]/g, '_');

        fs.writeFileSync(
            `originalDeposits-${sanitizedPoolName}-block-${blockTag}.json`,
            JSON.stringify(dataToSave)
        );
    }

    console.timeEnd('calculateDepositorsBalancesInBatches');
}

async function calculateBorrowersBalancesInBatches(batchSize = 100) {
    console.time('calculateBorrowersBalancesInBatches');

    let smartLoansFactoryAddress = "0xFf5e3dDaefF411a1dC6CcE00014e4Bca39265c20";
    let smartLoansFactory = new ethers.Contract(smartLoansFactoryAddress, factoryAbi, provider);
    const borrowers = await smartLoansFactory.getAllLoans();

    for (let poolAddress of pools["arbitrum"]) {
        console.log(`Calculating original borrows for ${poolAddress}`);

        let poolContract = new ethers.Contract(poolAddress, poolAbi, provider);
        let poolContractDecimals = await poolContract.decimals();

        let poolName = poolAddressToPoolNameMapping[poolAddress];
        let blockTag = blockNumberOfPoolPausePerPool[poolName];
        console.log(`Block number for ${poolAddress}: ${blockTag}`);

        let originalBorrows = {};
        let batches = chunkArray(borrowers, batchSize);

        for (let batch of batches) {
            let promises = [];
            let borrowersInBatch = [];

            for (let borrower of batch) {
                borrowersInBatch.push(borrower);

                let balancePromise = poolContract.getBorrowed(borrower, { blockTag: blockTag });
                promises.push(balancePromise);
            }

            let balances = await Promise.all(promises);

            for (let i = 0; i < balances.length; i++) {
                let borrower = borrowersInBatch[i];
                let balance = balances[i];
                originalBorrows[borrower] = ethers.utils.formatUnits(balance, poolContractDecimals);
            }
        }

        // After processing all borrowers for this pool, write the data to a JSON file
        let dataToSave = {
            poolAddress: poolAddress,
            poolName: poolName,
            blockNumber: blockTag,
            borrows: originalBorrows
        };

        // Sanitize the pool name for use in a filename
        let sanitizedPoolName = poolName.replace(/[:/]/g, '_');

        fs.writeFileSync(
            `originalBorrows-${sanitizedPoolName}-block-${blockTag}.json`,
            JSON.stringify(dataToSave)
        );
    }

    console.timeEnd('calculateBorrowersBalancesInBatches');
}



const tokenUsdPricePerPool = {
    "0x8FE3842e0B7472a57f2A2D56cF6bCe08517A1De0": 1.0,       // USDC
    "0x0BeBEB5679115f143772CfD97359BBcc393d46b3": 2466,    // WETH
    "0x2B8C610F3fC6F883817637d15514293565C3d08A": 0.5585,    // ARB
    "0x5CdE36c23f0909960BA4D6E8713257C6191f8C35": 63000,    // BTC
    "0xd5E8f691756c3d7b86FD8A89A06497D38D362540": 1.0     // DAI
}

async function calculateMissingPoolTokens() {
    let missingPoolTokens = {};
    let missingInUsdTotal = 0;
    let missingInUsdTotalForTargetReimbursedPercentage = 0;
    const STABILITY_POOL_REMAINING_USD_VALUE = 824000 - 57600;

    for (let poolAddress in poolAddressToPoolNameMapping) {
        let poolName = poolAddressToPoolNameMapping[poolAddress];
        let blockTag = blockNumberOfPoolPausePerPool[poolName];

        // console.log(`Processing pool: ${poolName} at block: ${blockTag}`);

        // Construct filenames for the depositors and borrowers JSON files
        let sanitizedPoolName = poolName.replace(/[:/]/g, '_');

        let depositorsFileName = `originalDeposits-${sanitizedPoolName}-block-${blockTag}.json`;
        let borrowersFileName = `originalBorrows-${sanitizedPoolName}-block-${blockTag}.json`;

        // Read and parse the depositors data
        let depositorsData;
        try {
            depositorsData = JSON.parse(fs.readFileSync(depositorsFileName, 'utf8'));
        } catch (error) {
            console.error(`Error reading depositors file for ${poolName}:`, error);
            continue;
        }

        // Read and parse the borrowers data
        let borrowersData;
        try {
            borrowersData = JSON.parse(fs.readFileSync(borrowersFileName, 'utf8'));
        } catch (error) {
            console.error(`Error reading borrowers file for ${poolName}:`, error);
            continue;
        }

        // Extract balances from the data
        let depositorsBalances = depositorsData.deposits; // Assuming deposits are under 'deposits' key
        let borrowersBalances = borrowersData.borrows;     // Assuming borrows are under 'borrows' key

        // Initialize the pool contract and token details
        let poolContract = new ethers.Contract(poolAddress, poolAbi, provider);
        let poolTokenAddress = await poolContract.tokenAddress();
        let poolTokenContract = new ethers.Contract(poolTokenAddress, erc20Abi, provider);
        let poolTokenDecimals = await poolTokenContract.decimals();

        // Sum up all depositors' balances
        let sumOfDeposits = Object.values(depositorsBalances).reduce((a, b) => parseFloat(a) + parseFloat(b), 0);

        console.log(`SUM OF DEPOSITS: ${sumOfDeposits}`);

        // Sum up all borrowers' balances
        let sumOfBorrows = Object.values(borrowersBalances).reduce((a, b) => parseFloat(a) + parseFloat(b), 0);

        console.log(`SUM OF BORROWS: ${sumOfBorrows}`);

        // Get the pool's token balance at the specific block
        let poolTokenBalanceRaw = await poolTokenContract.balanceOf(poolAddress);
        let poolTokenBalance = parseFloat(ethers.utils.formatUnits(poolTokenBalanceRaw, poolTokenDecimals));

        // Calculate the missing pool tokens
        let missingTokens = sumOfBorrows - sumOfDeposits + poolTokenBalance;
        missingPoolTokens[poolAddress] = missingTokens;

        let reimbursedPercentage = (sumOfDeposits - Math.abs(missingTokens)) / sumOfDeposits * 100;

        // Calculate the missing amount in USD
        let tokenPrice = tokenUsdPricePerPool[poolAddress];
        let missingInUsd = tokenPrice * missingTokens;

        console.log(`Missing pool tokens for ${poolName}: ${missingTokens} [out of ${sumOfDeposits} = ${Math.abs(reimbursedPercentage.toFixed(2))}%] ($${missingInUsd})`);
        missingInUsdTotal += missingInUsd;

        // Define target reimbursed percentage (e.g., 80%)
        let targetReimbursedPercentage = 58; // Set your desired target percentage here

        // Inside the loop for each pool, after calculating missingTokens and missingInUsd

        // Calculate the current missing tokens as a positive value
        let currentMissingTokens = Math.abs(missingTokens);

        // Calculate the current missing percentage
        let currentMissingPercentage = (currentMissingTokens / sumOfDeposits) * 100;

        // Calculate the target missing percentage
        let targetMissingPercentage = 100 - targetReimbursedPercentage;

        // Calculate the target missing tokens based on the target missing percentage
        let targetMissingTokens = (targetMissingPercentage / 100) * sumOfDeposits;

        // Calculate the amount of tokens needed to add to the pool
        let tokensNeededToAdd = currentMissingTokens - targetMissingTokens;

        // Ensure tokensNeededToAdd is not negative
        if (tokensNeededToAdd <= 0) {
            console.log(`Pool ${poolName} is already reimbursed at ${targetReimbursedPercentage}% or higher.`);
        } else {
            // Calculate the USD value of the tokens needed to add
            let tokensNeededToAddUsdValue = tokensNeededToAdd * tokenPrice;
            missingInUsdTotalForTargetReimbursedPercentage += tokensNeededToAddUsdValue;

            console.log(`To achieve ${targetReimbursedPercentage}% reimbursed for ${poolName}, need to add ${tokensNeededToAdd.toFixed(6)} tokens ($${tokensNeededToAddUsdValue.toFixed(2)}) to the pool.`);
        }

    }

    console.log("Missing Pool Tokens:", missingPoolTokens);
    console.log(`Total missing in USD: $${missingInUsdTotal}`);
    console.log(`Total missing in USD for target reimbursed percentage: $${missingInUsdTotalForTargetReimbursedPercentage}`);
    console.log(`Stability Pool Remaining USD Value: $${STABILITY_POOL_REMAINING_USD_VALUE}`);
    console.log(`Total missing in USD for target reimbursed percentage IN PRIME: $${missingInUsdTotalForTargetReimbursedPercentage - STABILITY_POOL_REMAINING_USD_VALUE}`);
}

async function isContract(provider, address) {
    const code = await provider.getCode(address);
    return code !== '0x';
}

function mergeAllDepositors(depositors) {
    // Create a Set to store unique depositors across all pools
    const allDepositorsSet = new Set();

    // Iterate over each pool in the depositors object
    for (const pool in depositors) {
        if (depositors.hasOwnProperty(pool)) {
            // Merge depositors for the current pool into the Set to avoid duplicates
            depositors[pool].forEach(depositor => allDepositorsSet.add(depositor));
        }
    }

    // Convert the Set back to an array
    const allDepositorsArray = Array.from(allDepositorsSet);

    // Return the array of unique depositors
    return allDepositorsArray;
}

async function checkAddressesInBatches() {
    let depositors = await getDepositorsAddressesFromChainbase("arbitrum");
    depositors = mergeAllDepositors(depositors);
    const contractAddresses = [];

    // Split the addresses array into chunks of 50
    for (let i = 0; i < depositors.length; i += 50) {
        const batch = depositors.slice(i, i + 50);

        // Use Promise.all to check each address in the batch concurrently
        const batchResults = await Promise.all(
            batch.map(async (address) => {
                const isContractAddress = await isContract(provider, address);
                return { address, isContractAddress };
            })
        );

        // Collect all contract addresses
        batchResults.forEach(result => {
            if (result.isContractAddress) {
                contractAddresses.push(result.address);
            }
        });
    }

    // Log all contract addresses
    console.log("Contract addresses:", contractAddresses);
}

// calculateDepositorsBalancesInBatches(50)
// calculateBorrowersBalancesInBatches(50)
// checkAddressesInBatches()
calculateMissingPoolTokens()