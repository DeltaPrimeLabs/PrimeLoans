const ethers = require('ethers');
const fs = require('fs');
const path = require('path');

async function main() {
    const rpcUrl = '<REDACTED>'; // Replace with your RPC URL
    const provider = new ethers.providers.JsonRpcProvider(rpcUrl);

    const factoryAddress = '0xFf5e3dDaefF411a1dC6CcE00014e4Bca39265c20';
    const factoryAbi = [
        {
            "inputs": [],
            "name": "getAllLoans",
            "outputs": [
                {
                    "internalType": "address[]",
                    "name": "",
                    "type": "address[]"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        }
    ];

    const factoryContract = new ethers.Contract(factoryAddress, factoryAbi, provider);

    // Fetch all PrimeAccount addresses
    const allPAs = await factoryContract.getAllLoans();
    console.log(`Fetched ${allPAs.length} PrimeAccount addresses.`);

    const pools = {
        "BtcPoolTUP": "0x5CdE36c23f0909960BA4D6E8713257C6191f8C35",
        "DaiPoolTUP": "0xd5E8f691756c3d7b86FD8A89A06497D38D362540",
        "UsdcPoolTUP": "0x8FE3842e0B7472a57f2A2D56cF6bCe08517A1De0",
        "WethPoolTUP": "0x0BeBEB5679115f143772CfD97359BBcc393d46b3",
        "ArbPoolTUP": "0x2B8C610F3fC6F883817637d15514293565C3d08A",
    };

    const poolDecimals = {
        "BtcPoolTUP": 8,
        "DaiPoolTUP": 18,
        "UsdcPoolTUP": 6,
        "WethPoolTUP": 18,
        "ArbPoolTUP": 18,
    };

    const lastBlockNumberBeforeExploitPerPool = {
        "BtcPoolTUP": 253995298 - 1,
        "DaiPoolTUP": 253995304 - 1,
        "UsdcPoolTUP": 253995296 - 1,
        "WethPoolTUP": 253995300 - 1,
        "ArbPoolTUP": 253995302 - 1,
    };

    const lastWithdrawBlockNumberPerPool = {
        "BtcPoolTUP": 254021502 + 1,
        "DaiPoolTUP": 253995304 + 1,
        "UsdcPoolTUP": 254031212 + 1,
        "WethPoolTUP": 254031778 + 1,
        "ArbPoolTUP": 254029099 + 1,
    };

    // Underlying token addresses (replace with actual token addresses on Arbitrum)
    const underlyingTokens = {
        "BtcPoolTUP": "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f", // WBTC address on Arbitrum
        "DaiPoolTUP": "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1", // DAI address on Arbitrum
        "UsdcPoolTUP": "0xaf88d065e77c8cC2239327C5EDb3A432268e5831", // USDC address on Arbitrum
        "WethPoolTUP": "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1", // WETH address on Arbitrum
        "ArbPoolTUP": "0x912CE59144191C1204E64559FE8253a0e49E6548", // ARB token address
    };

    const erc20Abi = [
        // balanceOf
        {
            "constant": true,
            "inputs": [
                {
                    "name": "_owner",
                    "type": "address"
                }
            ],
            "name": "balanceOf",
            "outputs": [
                {
                    "name": "balance",
                    "type": "uint256"
                }
            ],
            "type": "function"
        },
        // totalSupply
        {
            "constant": true,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [
                {
                    "name": "",
                    "type": "uint256"
                }
            ],
            "type": "function"
        }
    ];

    const poolAbi = [
        {
            "inputs": [
                {
                    "internalType": "address",
                    "name": "_user",
                    "type": "address"
                }
            ],
            "name": "getBorrowed",
            "outputs": [
                {
                    "internalType": "uint256",
                    "name": "",
                    "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
        },
        // totalSupply
        {
            "constant": true,
            "inputs": [],
            "name": "totalSupply",
            "outputs": [
                {
                    "name": "",
                    "type": "uint256"
                }
            ],
            "type": "function"
        }
    ];

    for (const [poolName, poolAddress] of Object.entries(pools)) {
        console.log(`Processing pool: ${poolName}`);
        const poolContract = new ethers.Contract(poolAddress, poolAbi, provider);
        const decimals = poolDecimals[poolName];
        const blockNumberBeforeExploit = lastBlockNumberBeforeExploitPerPool[poolName];
        const blockNumberAfterWithdrawal = lastWithdrawBlockNumberPerPool[poolName];

        // Prepare variables to store results
        const resultsBeforeExploit = {};
        let totalBorrowedAmountBeforeExploit = ethers.BigNumber.from(0);

        // Fetch borrowed amounts at blockNumberBeforeExploit
        for (let i = 0; i < allPAs.length; i += 200) {
            const batch = allPAs.slice(i, i + 200);

            const promises = batch.map(paAddress => {
                return poolContract.getBorrowed(paAddress, { blockTag: blockNumberBeforeExploit })
                    .then(amount => {
                        // Sum the raw borrowed amounts
                        totalBorrowedAmountBeforeExploit = totalBorrowedAmountBeforeExploit.add(amount);
                        // Normalize individual borrowed amount
                        const normalizedAmount = ethers.utils.formatUnits(amount, decimals);
                        resultsBeforeExploit[paAddress] = normalizedAmount;
                    })
                    .catch(error => {
                        console.error(`Error fetching borrowed amount for PA ${paAddress} in pool ${poolName}:`, error);
                        resultsBeforeExploit[paAddress] = null;
                    });
            });

            await Promise.all(promises);
            console.log(`Processed borrowers batch ${Math.ceil((i + 1) / 200)} of ${Math.ceil(allPAs.length / 200)} for pool ${poolName} at block ${blockNumberBeforeExploit}`);
        }

        // Normalize the total borrowed amount before exploit
        const normalizedTotalBorrowedAmountBeforeExploit = ethers.utils.formatUnits(totalBorrowedAmountBeforeExploit, decimals);

        // Fetch pool's totalSupply at blockNumberBeforeExploit
        let poolTotalSupplyBeforeExploit;
        try {
            const totalSupplyBefore = await poolContract.totalSupply({ blockTag: blockNumberBeforeExploit });
            poolTotalSupplyBeforeExploit = ethers.utils.formatUnits(totalSupplyBefore, decimals);
        } catch (error) {
            console.error(`Error fetching totalSupply before exploit for pool ${poolName}:`, error);
            poolTotalSupplyBeforeExploit = null;
        }

        // Fetch pool's underlying token balance at blockNumberBeforeExploit
        const underlyingTokenAddress = underlyingTokens[poolName];
        const underlyingTokenContract = new ethers.Contract(underlyingTokenAddress, erc20Abi, provider);

        let poolUnderlyingBalanceBeforeExploit;
        try {
            const balanceBefore = await underlyingTokenContract.balanceOf(poolAddress, { blockTag: blockNumberBeforeExploit });
            poolUnderlyingBalanceBeforeExploit = ethers.utils.formatUnits(balanceBefore, decimals);
        } catch (error) {
            console.error(`Error fetching underlying token balance before exploit for pool ${poolName}:`, error);
            poolUnderlyingBalanceBeforeExploit = null;
        }

        // Fetch total borrowed amount after last withdrawal
        let totalBorrowedAmountAfterLastWithdrawal = ethers.BigNumber.from(0);

        // We may not need per-account borrowed amounts after last withdrawal, so we can just sum them up
        for (let i = 0; i < allPAs.length; i += 200) {
            const batch = allPAs.slice(i, i + 200);

            const promises = batch.map(paAddress => {
                return poolContract.getBorrowed(paAddress, { blockTag: blockNumberAfterWithdrawal })
                    .then(amount => {
                        // Sum the raw borrowed amounts
                        totalBorrowedAmountAfterLastWithdrawal = totalBorrowedAmountAfterLastWithdrawal.add(amount);
                    })
                    .catch(error => {
                        console.error(`Error fetching borrowed amount after withdrawal for PA ${paAddress} in pool ${poolName}:`, error);
                    });
            });

            await Promise.all(promises);
            console.log(`Processed borrowers batch ${Math.ceil((i + 1) / 200)} of ${Math.ceil(allPAs.length / 200)} for pool ${poolName} at block ${blockNumberAfterWithdrawal}`);
        }

        // Normalize the total borrowed amount after last withdrawal
        const normalizedTotalBorrowedAmountAfterWithdrawal = ethers.utils.formatUnits(totalBorrowedAmountAfterLastWithdrawal, decimals);

        // Fetch pool's totalSupply at blockNumberAfterWithdrawal
        let poolTotalSupplyAfterLastWithdrawal;
        try {
            const totalSupplyAfter = await poolContract.totalSupply({ blockTag: blockNumberAfterWithdrawal });
            poolTotalSupplyAfterLastWithdrawal = ethers.utils.formatUnits(totalSupplyAfter, decimals);
        } catch (error) {
            console.error(`Error fetching totalSupply after last withdrawal for pool ${poolName}:`, error);
            poolTotalSupplyAfterLastWithdrawal = null;
        }

        // Fetch pool's underlying token balance at blockNumberAfterWithdrawal
        let poolUnderlyingBalanceAfterLastWithdrawal;
        try {
            const balanceAfter = await underlyingTokenContract.balanceOf(poolAddress, { blockTag: blockNumberAfterWithdrawal });
            poolUnderlyingBalanceAfterLastWithdrawal = ethers.utils.formatUnits(balanceAfter, decimals);
        } catch (error) {
            console.error(`Error fetching underlying token balance after last withdrawal for pool ${poolName}:`, error);
            poolUnderlyingBalanceAfterLastWithdrawal = null;
        }

        // Prepare the final results object with the specified key names and additional data
        const finalResults = {
            normalizedTotalBorrowedAmountBeforeExploit: normalizedTotalBorrowedAmountBeforeExploit,
            totalBorrowedAmountAfterLastWithdrawal: normalizedTotalBorrowedAmountAfterWithdrawal,
            poolUnderlyingBalanceBeforeExploit: poolUnderlyingBalanceBeforeExploit,
            poolUnderlyingBalanceAfterLastWithdrawal: poolUnderlyingBalanceAfterLastWithdrawal,
            poolTotalSupplyBeforeExploit: poolTotalSupplyBeforeExploit,
            poolTotalSupplyAfterLastWithdrawal: poolTotalSupplyAfterLastWithdrawal,
            borrowedPerPrimeAccount: resultsBeforeExploit
        };

        const folderPath = path.join(__dirname, poolName, `borrowedAtBlock${blockNumberBeforeExploit}`);
        fs.mkdirSync(folderPath, { recursive: true });

        const filePath = path.join(folderPath, 'borrowed.json');
        fs.writeFileSync(filePath, JSON.stringify(finalResults, null, 2));
        console.log(`Results for pool ${poolName} written to ${filePath}`);
    }

    console.log('Script execution completed.');
}

main().catch(error => {
    console.error('An error occurred:', error);
    process.exit(1);
});
