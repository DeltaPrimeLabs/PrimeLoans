import {WrapperBuilder} from "@redstone-finance/evm-connector";
import CACHE_LAYER_URLS from "../../../common/redstone-cache-layer-urls.json";
import * as pools from "rxjs";

const contractName = "SmartLoanGigaChadInterface";
const contractMethod = "getDebts";
// const jsonRPC = "https://arb.nirvanalabs.xyz/arbitrum_aws?apikey=284d7cde-5c20-46a9-abee-2e3932cdb771";
const jsonRPC = "https://avax.nirvanalabs.xyz/avalanche_aws/ext/bc/C/rpc?apikey=284d7cde-5c20-46a9-abee-2e3932cdb771";
const fromWei = val => parseFloat(ethers.utils.formatEther(val));
const fromBytes32 = require('ethers').utils.parseBytes32String;
const formatUnits = require('ethers').utils.formatUnits;

const PA_ARTIFACT = require(`../../../artifacts/contracts/interfaces/SmartLoanGigaChadInterface.sol/SmartLoanGigaChadInterface.json`);
const POOL_ARTIFACT = require(`../../../artifacts/contracts/Pool.sol/Pool.json`);
const SLF_ARTIFACT = require(`../../../artifacts/contracts/SmartLoansFactory.sol/SmartLoansFactory.json`);
const ethers = require("ethers");
const fs = require("fs");
async function wrapContract(contract, assets) {
    //for more symbols in data feed it's more optimal to not specify asset list
    const providedAssets = (assets && assets.length <= 5) ? assets : undefined;

    return WrapperBuilder.wrap(contract).usingDataService(
        {
            dataServiceId: 'redstone-arbitrum-prod',
            uniqueSignersCount: 3,
            dataFeeds: providedAssets,
            disablePayloadsDryRun: true
        },
        CACHE_LAYER_URLS.urls
    );
};
const key = fs.readFileSync("./.secret").toString().trim();
let mnemonicWallet = new ethers.Wallet(key);
let provider = new ethers.providers.JsonRpcProvider(jsonRPC);
let wallet = mnemonicWallet.connect(provider);


const CONTRACTS_AVALANCHE = [
    '0xA9B975C11F6AFcE142799CeBB80f078f1Be4C8F6',
    '0x281AA602B13491AeBbBD39c436d25fD0fc241369',
    '0x7e4d79614E079EBfeec345c560FD3312d50b4337',
    '0x790Cb941FD0D472b24EB40f4be8dcd6f881ae319',
    '0x1C300f7Fb1c0d545f77095FdF79396d2DAE0D2fF',
    '0x7370423d2dB2F83135FD71049C7D2e6ad49Fec56'
]

const CONTRACTS_ARBITRUM = [
    '0xf81b4381b70EF520Ae635AFD4B0E8aeb994131fb',
    '0x481244Ee8C1d78FC2722dAc859f8bEf96E5aC62D',
    '0xC5Fe20fE7D61414Ea126BfEac60Cce3af14f1B34',
    '0x9b3B64c0C848a3864D482beD8B8e51df9448CB0c',
    '0x599d21C3B27a9a9E7C8853ceFD01Ad3A3871d6b4',
    '0x6902fdb1E1F46D2EC0256252cd3A8236451d5898',
    '0x647bf4f0a8F9468298aD3552d29c03a5a0e6f906',
    '0xDa148082c652c51b6C6892afA9a06E5b71108a15',
    '0x92bF0C91c6B9d2b6D32383Ef831fCd3222b904b2',
    '0xD9f3fe38fb7fD76af5cF2bb388d0Ad77198e60ef',
    '0x8a3d989E23B71f479958905D0E164443eb2f66C4',
    '0x8D2905A7580abe890D02727894b58d3Dd02FBDCF',
    '0x54f6bF0D9322b5Cc91Df2200FDB8Aa1128De9B88'
]

const POOLS_AVALANCHE = [
    { symbol: 'AVAX', address: '0xD26E504fc642B96751fD55D3E68AF295806542f5', decimals: 18},
    { symbol: 'USDC', address: '0x2323dAC85C6Ab9bd6a8B5Fb75B0581E31232d12b', decimals: 6},
    { symbol: 'BTC', address: '0x475589b0Ed87591A893Df42EC6076d2499bB63d0', decimals: 8},
    { symbol: 'ETH', address: '0xD7fEB276ba254cD9b34804A986CE9a8C3E359148', decimals: 18},
    { symbol: 'USDT', address: '0xd222e10D7Fe6B7f9608F14A8B5Cf703c74eFBcA1', decimals: 6}
]

const POOLS_ARBITRUM = [
    { symbol: 'USDC', address: '0x5f3DB5899a7937c9ABF0A5Fc91718E6F813e4195', decimals: 6},
    { symbol: 'DAI', address: '0x7Dcf909B1E4b280bEe72C6A69b3a7Ed8adfb63f0', decimals: 18},
    { symbol: 'BTC', address: '0x275Caecf5542bF4a3CF64aa78a3f57dc9939675C', decimals: 8},
    { symbol: 'ARB', address: '0x14c82CFc2c651700a66aBDd7dC375c9CeEFDDD72', decimals: 18},
    { symbol: 'ETH', address: '0x2E2fE9Bc7904649b65B6373bAF40F9e2E0b883c5', decimals: 18}
]

const AVALANCHE_POOL_LOSSES = {
    AVAX: 74425.46321742902,
    USDC: 860117.762769,
    BTC: 6.3447697,
    ETH: 49.67764265713932,
    USDT: 259936.323824
};

const ARBITRUM_POOL_LOSSES = {
    USDC: 	271618.8176,
    DAI: 	2769.140089,
    BTC: 	2.96711484,
    ARB: 	50060.28521,
    ETH: 	66.62145095
};

const AVALANCHE_POOL_PERCENTAGE_LOSSES = {
    AVAX: 29.39,
    USDC: 14.68,
    BTC: 14.54,
    ETH: 28.22,
    USDT: 14.17
};

const ARBITRUM_POOL_PERCENTAGE_LOSSES = {
    USDC: 	9.47,
    DAI: 	6.77,
    BTC: 	10.62,
    ARB: 	15.22,
    ETH: 	15.28
};

const ARBITRUM_OBSOLETE_ADDRESSES = [
    '0xf81b4381b70EF520Ae635AFD4B0E8aeb994131fb',
    '0x481244Ee8C1d78FC2722dAc859f8bEf96E5aC62D',
    '0xC5Fe20fE7D61414Ea126BfEac60Cce3af14f1B34',
    '0x9b3B64c0C848a3864D482beD8B8e51df9448CB0c',
    '0x599d21C3B27a9a9E7C8853ceFD01Ad3A3871d6b4',
    '0x6902fdb1E1F46D2EC0256252cd3A8236451d5898',
    '0x647bf4f0a8F9468298aD3552d29c03a5a0e6f906',
    '0xDa148082c652c51b6C6892afA9a06E5b71108a15',
    '0x92bF0C91c6B9d2b6D32383Ef831fCd3222b904b2',
    '0xD9f3fe38fb7fD76af5cF2bb388d0Ad77198e60ef',
    '0x8a3d989E23B71f479958905D0E164443eb2f66C4',
    '0x8D2905A7580abe890D02727894b58d3Dd02FBDCF',
    '0x54f6bF0D9322b5Cc91Df2200FDB8Aa1128De9B88'
]

const AVALANCHE_OBSOLETE_ADDRESSES = [
    '0xA9B975C11F6AFcE142799CeBB80f078f1Be4C8F6',
    '0x281AA602B13491AeBbBD39c436d25fD0fc241369',
    '0x7e4d79614E079EBfeec345c560FD3312d50b4337',
    '0x790Cb941FD0D472b24EB40f4be8dcd6f881ae319',
    '0x1C300f7Fb1c0d545f77095FdF79396d2DAE0D2fF',
    '0x7370423d2dB2F83135FD71049C7D2e6ad49Fec56'
]

let sumOfDebts = [0,0,0,0,0]

async function checkAccount(contract, blockNumber, pools) {
    let res = await contract[contractMethod]({blockTag: blockNumber});
    // console.log(res.map(el => fromBytes32(el.name)));

    for (let i = 0; i < res.length; i++) {
        sumOfDebts[i] += parseFloat(formatUnits(res[i].debt, pools[i].decimals));
    }

    for (let i = 0; i <res.length; i++) {
    }
    console.log(res)
}

async function checkAccounts(accounts, blockNumber, pools) {
    for (let paAddress of accounts) {
        let contract = new ethers.Contract(paAddress, PA_ARTIFACT.abi, wallet);

        await checkAccount(contract, blockNumber, pools);
    }

    for (let i = 0; i < sumOfDebts.length; i++) {
        console.log(`${pools[i].symbol}: ${sumOfDebts[i]}`)
    }
}

async function checkPools(pools, blockNumber) {
    for (let pool of pools) {
        await checkPool(pool, blockNumber);
    }
}

async function checkPool(pool, blockNumber) {
    let contract = new ethers.Contract(pool.address, POOL_ARTIFACT.abi, wallet);

    let res = await contract.getFullPoolStatus({blockTag: blockNumber});

    let totalSupply = parseFloat(formatUnits(res[0], pool.decimals));
    let totalBorrowed = parseFloat(formatUnits(res[3], pool.decimals));

    // console.log(`${pool.symbol}, totalSupply: ${totalSupply}, totalDebt: ${totalBorrowed}`);
    return totalSupply;
}

function formatNumber(num)  {
    if (!isFinite(num)) return String(num);

    // For very large numbers, use toString() directly
    if (Math.abs(num) >= 1e20) {
        return num.toString();
    }

    let str = num.toPrecision(15);
    str = str.replace(/\.?0+$/, '');

    if (str.includes('e')) {
        const [base, exp] = str.split('e');
        const exponent = parseInt(exp);

        if (exponent < 0) {
            return '0.' + '0'.repeat(Math.abs(exponent) - 1) + base.replace('.', '');
        } else {
            const baseDigits = base.replace('.', '');
            const targetLength = baseDigits.length + exponent - (base.includes('.') ? 1 : 0);
            return baseDigits.padEnd(targetLength, '0');
        }
    }

    return str;
}

async function generateDepositJsonsAfterHaircut(pools, poolLosses, blockNumber, network) {
    for (let [symbol, loss] of Object.entries(poolLosses)) {
        const pool = pools.find(el => el.symbol === symbol);
        const totalSupply = await checkPool(pool, blockNumber);
        const newTotalSupply = totalSupply - loss;
        const ratio = newTotalSupply / totalSupply;
        const newBalances = {};

        const balancesBeforeHack = JSON.parse(fs.readFileSync(`./tools/scripts/exploitCalculations2/before-hack/including-yy-fortifi/${network}/${symbol}.json`));
        console.log(balancesBeforeHack)
        for (let [address, balance] of Object.entries(balancesBeforeHack)) {
            newBalances[address] = Math.floor((balance * ratio)).toLocaleString('fullwide', {useGrouping:false});
        }
        fs.writeFileSync(`./tools/scripts/exploitCalculations2/after-hack/savings/${network}/${symbol}.json`, JSON.stringify(newBalances));
    }
}

async function generateBorrowJsons(pools, blockNumber, network) {
    for (let pool of pools) {
        const factoryTUP = require(`../../../deployments/${network}/SmartLoansFactoryTUP.json`);
        let factoryContract = new ethers.Contract(factoryTUP.address, SLF_ARTIFACT.abi, wallet);
        let poolContract = new ethers.Contract(pool.address, POOL_ARTIFACT.abi, wallet);

        const loans = await factoryContract.getAllLoans({blockTag: blockNumber});

        const borrows = {};

        for (let loan of loans) {
            const borrowed = await poolContract.getBorrowed(loan, {blockTag: blockNumber});
            borrows[loan] = borrowed.toString();
            console.log(`${loan}: ${borrowed.toString()}`)
        }

        fs.writeFileSync(`./tools/scripts/exploitCalculations2/after-hack/borrows/${network}/${pool.symbol}.json`, JSON.stringify(borrows));
    }
}

async function calculateDamagePerPool(pools, poolLosses, blockNumber) {
    for (let [symbol, loss] of Object.entries(poolLosses)) {
        const pool = pools.find(el => el.symbol === symbol);

        const totalSupply = await checkPool(pool, blockNumber);

        const percentageLoss = loss / totalSupply * 100;

        console.log(`symbol: ${symbol}, percentageLoss: ${percentageLoss.toFixed(2)}%`);
    }
}

async function getSingleDepositAtBlock(symbol, pools, address, blockNumber) {
    let pool = pools.find(el => el.symbol === symbol);
    let poolContract = new ethers.Contract(pool.address, POOL_ARTIFACT.abi, wallet);

    let result = formatUnits(await poolContract.balanceOf(address, {blockTag: blockNumber}), pool.decimals);

    console.log(`Balance of ${address} at ${blockNumber}: ${result}`)
}

async function getSingleBorrowAtBlock(symbol, pools, address, blockNumber) {
    let pool = pools.find(el => el.symbol === symbol);
    let poolContract = new ethers.Contract(pool.address, POOL_ARTIFACT.abi, wallet);

    let result = formatUnits(await poolContract.getBorrowed(address, {blockTag: blockNumber}), pool.decimals);

    console.log(`Borrowed of ${address} at ${blockNumber}: ${result}`)
}

async function verifyUserHaircut(symbol, pools, haircutData, depositors, blockNumber, network) {
    let pool = pools.find(el => el.symbol === symbol);
    let poolContract = new ethers.Contract(pool.address, POOL_ARTIFACT.abi, wallet);
    let calculatedData = JSON.parse(fs.readFileSync(`./tools/scripts/exploitCalculations2/after-hack/savings/${network}/${pool.symbol}.json`));

    for (let depositor of depositors) {
        let depositBeforeHaircut = formatUnits(await poolContract.balanceOf(depositor, {blockTag: blockNumber}), pool.decimals);


        const haircut = (depositBeforeHaircut - calculatedData[depositor] / 10**pool.decimals) / depositBeforeHaircut;

        console.log(`Haircut of ${depositor}: ${(haircut * 100).toFixed(2)}%, expected: ${haircutData[symbol]}`)

    }
}


async function fetchPoolBalancesAtBlock(pools, blockNumber, network) {
    for (let pool of pools) {
        let poolContract = new ethers.Contract(pool.address, POOL_ARTIFACT.abi, wallet);

        let depositorData = JSON.parse(fs.readFileSync(`./tools/scripts/exploitCalculations2/before-hack/pure/${network}/${pool.symbol}.json`));

        let deposits = {};

        for (let depositor of Object.keys(depositorData)) {
            const deposited = await poolContract.balanceOf(depositor, {blockTag: blockNumber});
            deposits[depositor] = deposited.toString();
            console.log(`pool: ${pool.symbol}, user: ${depositor}, balance: ${deposits[depositor]}`);
        }

        // fs.writeFileSync(`./tools/scripts/exploitCalculations2/before-hack/mbare/${network}/${pool.symbol}.json`, JSON.stringify(deposits));
    }
}

async function removeObsoleteBorrows(pools, obsoleteAddresses, network) {
    for (let pool of pools) {
        let borrows = JSON.parse(fs.readFileSync(`./tools/scripts/exploitCalculations2/after-hack/borrows/${network}/${pool.symbol}.json`));

        for (let borrower of Object.keys(borrows)) {
            if (obsoleteAddresses.indexOf(borrower) !== -1) {
                delete borrows[borrower];
                console.log(`Removed : ${borrower}, from: ${pool.symbol}`);
            }
        }

        fs.writeFileSync(`./tools/scripts/exploitCalculations2/after-hack/borrows/${network}/${pool.symbol}.json`, JSON.stringify(borrows));
    }
}

const path = require('path');

function convertScientificToDecimal(value) {
    const strValue = value.toString();
    if (!strValue.includes('e') && !strValue.includes('E')) {
        return strValue;
    }
    const numValue = parseFloat(strValue);
    return numValue.toLocaleString('fullwide', { useGrouping: false });
}

function filterAndSaveNonZeroValues(filePath) {
    const jsonData = JSON.parse(fs.readFileSync(filePath, 'utf8'));

    const filteredData = Object.fromEntries(
        Object.entries(jsonData)
            .filter(([_, value]) => value !== '0' && value !== 0)
            .map(([key, value]) => [key, convertScientificToDecimal(value)])
    );

    const dir = path.dirname(filePath);
    const fileName = path.basename(filePath, '.json');
    const newFilePath = path.join(dir, `${fileName}_nonzero.json`);

    fs.writeFileSync(newFilePath, JSON.stringify(filteredData, null, 2));

    return newFilePath;
}

function formatArrayContent(items) {
    return `[\n${items.map(item => `  "${item}"`).join(',\n')}\n]`;
}

function processByBatches(batchSize = 50) {
    const networks = ['arbitrum', 'avalanche'];
    const categories = ['borrows', 'savings'];
    const afterHackPath = path.join('tools', 'scripts', 'exploitCalculations2', 'after-hack');

    for (const network of networks) {
        for (const category of categories) {
            const batchesPath = path.join(afterHackPath, category, network, 'batches');
            if (!fs.existsSync(batchesPath)) {
                fs.mkdirSync(batchesPath, { recursive: true });
            }
        }
    }

    for (const category of categories) {
        console.log(`Processing ${category}`);

        for (const network of networks) {
            const networkPath = path.join(afterHackPath, category, network);

            const files = fs.readdirSync(networkPath)
                .filter(file => file.endsWith('.json') && !file.includes('_nonzero'));

            console.log(`Processing ${network} network files in ${category}: ${files.join(', ')}`);

            const filteredFiles = files.map(file => {
                const filePath = path.join(networkPath, file);
                console.log(`Creating filtered version of ${file}`);
                return filterAndSaveNonZeroValues(filePath);
            });

            for (const filteredFile of filteredFiles) {
                try {
                    const tokenName = path.basename(filteredFile, '_nonzero.json');
                    const jsonData = JSON.parse(fs.readFileSync(filteredFile, 'utf8'));

                    const addresses = Object.keys(jsonData);
                    const values = Object.values(jsonData);

                    const totalRecords = addresses.length;
                    const numberOfBatches = Math.ceil(totalRecords / batchSize);

                    console.log(`Processing ${tokenName} on ${network} (${category}): ${totalRecords} records in ${numberOfBatches} batches`);

                    for (let batchNum = 0; batchNum < numberOfBatches; batchNum++) {
                        const start = batchNum * batchSize;
                        const end = Math.min(start + batchSize, totalRecords);

                        const addressesBatch = addresses.slice(start, end);
                        const valuesBatch = values.slice(start, end);

                        // Format content as JSON arrays
                        const addressesContent = formatArrayContent(addressesBatch);
                        const valuesContent = formatArrayContent(valuesBatch);

                        const addressFileName = path.join(afterHackPath, category, network, 'batches',
                            `${tokenName}_addresses_batch_${batchNum + 1}.txt`);
                        const valuesFileName = path.join(afterHackPath, category, network, 'batches',
                            `${tokenName}_values_batch_${batchNum + 1}.txt`);

                        fs.writeFileSync(addressFileName, addressesContent);
                        fs.writeFileSync(valuesFileName, valuesContent);

                        console.log(`Batch ${batchNum + 1}/${numberOfBatches} processed for ${tokenName} on ${network} (${category})`);
                    }
                } catch (error) {
                    console.error(`Error processing ${filteredFile} in ${network} ${category}:`, error);
                }
            }
        }
    }

    console.log('All networks, categories and tokens processed successfully');
}


// checkAccounts(CONTRACTS_ARBITRUM, 273282893 - 1, POOLS_ARBITRUM);
// checkAccounts(CONTRACTS_AVALANCHE, 52928213 - 1, POOLS_AVALANCHE);

// checkPools(POOLS_ARBITRUM, 273282893 - 1);
// checkPools(POOLS_AVALANCHE, 52928213 - 1);

// generateDepositJsonsAfterHaircut(POOLS_ARBITRUM, ARBITRUM_POOL_LOSSES, 273282893 - 1, 'arbitrum');
// generateDepositJsonsAfterHaircut(POOLS_AVALANCHE, AVALANCHE_POOL_LOSSES, 52928213 - 1, 'avalanche');


// generateBorrowJsons(POOLS_ARBITRUM, 273282893 - 1, 'arbitrum');
// generateBorrowJsons(POOLS_AVALANCHE, 52928213 - 1, 'avalanche');

// calculateDamagePerPool(POOLS_ARBITRUM, ARBITRUM_POOL_LOSSES, 273282893 - 1)
// calculateDamagePerPool(POOLS_AVALANCHE, AVALANCHE_POOL_LOSSES, 52928213 - 1)

// getSingleDepositAtBlock('ARB', POOLS_ARBITRUM,'0x850a805da80bc53ccd244d4f64622f76e06469dd', 273282893 - 1)
// getSingleBorrowAtBlock('USDC', POOLS_ARBITRUM,'0x1D57c7d5A549De54Fc6ff225AA1De199ebc9f3c5', 273282893 - 1)

// fetchPoolBalancesAtBlock(POOLS_ARBITRUM, 273282893 - 1, 'arbitrum');
// fetchPoolBalancesAtBlock(POOLS_AVALANCHE, 52928213 - 1, 'avalanche');

removeObsoleteBorrows(POOLS_ARBITRUM, ARBITRUM_OBSOLETE_ADDRESSES, 'arbitrum');

const userList = [

]


// verifyUserHaircut('USDC', POOLS_ARBITRUM, ARBITRUM_POOL_PERCENTAGE_LOSSES, userList, 273282893 - 1, 'arbitrum')
// verifyUserHaircut('USDT', POOLS_AVALANCHE, AVALANCHE_POOL_PERCENTAGE_LOSSES, userList, 52928213 - 1, 'avalanche')
// verifyUserHaircut('USDT', POOLS_AVALANCHE, AVALANCHE_POOL_PERCENTAGE_LOSSES, userList, 52928213 - 1, 'avalanche')

processByBatches(300);

//ARBITRUM
//[ 'USDC', 'DAI', 'BTC', 'ARB', 'ETH' ]

//AVALANCHE
//[ 'AVAX', 'USDC', 'BTC', 'ETH', 'USDT' ]