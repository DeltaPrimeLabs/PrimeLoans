const fs = require('fs');
const path = require('path');
const { ethers } = require('ethers');

// Configuration
const BATCH_SIZE = 100;
const BASE_DIR = './after-hack/savings/rtkns';
const NETWORKS = ['arbitrum', 'avalanche'];
const DECIMALS = 18;
const MIN_VALUE = 1.0;

function filterAndSaveRtkns(network) {
    const filePath = path.join(BASE_DIR, network, 'rtkns.json');

    if (!fs.existsSync(filePath)) {
        console.log(`File not found: ${filePath}`);
        return null;
    }

    // Read and parse original JSON file
    const originalData = JSON.parse(fs.readFileSync(filePath, 'utf8'));

    // Filter entries where value >= 1.0
    const filteredData = Object.entries(originalData)
        .filter(([_, value]) => value >= MIN_VALUE)
        .reduce((acc, [address, value]) => ({
            ...acc,
            [address]: value
        }), {});

    // Save filtered data to new file
    const filteredFilePath = path.join(BASE_DIR, network, 'rtkns.filtered.json');
    fs.writeFileSync(filteredFilePath, JSON.stringify(filteredData, null, 2));

    console.log(`\nFiltering results for ${network}:`);
    console.log(`Original entries: ${Object.keys(originalData).length}`);
    console.log(`Filtered entries: ${Object.keys(filteredData).length}`);
    console.log(`Removed ${Object.keys(originalData).length - Object.keys(filteredData).length} entries < ${MIN_VALUE}`);

    return filteredFilePath;
}

function floatToERC20Amount(float) {
    try {
        const fixedStr = Number(float).toFixed(18);
        const parsed = ethers.utils.parseUnits(fixedStr, DECIMALS);
        return parsed.toString();
    } catch (error) {
        console.error(`Error converting value ${float}:`, error);
        throw error;
    }
}

function processRtknsFile(network) {
    // First filter the data
    const filteredFilePath = filterAndSaveRtkns(network);
    if (!filteredFilePath) return;

    // Read and parse the filtered JSON file
    const data = JSON.parse(fs.readFileSync(filteredFilePath, 'utf8'));

    // Extract addresses and values while preserving order
    const addresses = Object.keys(data);
    const values = Object.values(data).map(value => floatToERC20Amount(value));

    // Calculate number of batches needed
    const numBatches = Math.ceil(addresses.length / BATCH_SIZE);

    // Create output directory if it doesn't exist
    const outputDir = path.join(BASE_DIR, network, 'split');
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    // Split into batches and save files
    for (let i = 0; i < numBatches; i++) {
        const startIdx = i * BATCH_SIZE;
        const endIdx = Math.min(startIdx + BATCH_SIZE, addresses.length);

        // Create batches
        const addressesBatch = addresses.slice(startIdx, endIdx);
        const valuesBatch = values.slice(startIdx, endIdx);

        // Save address batch
        fs.writeFileSync(
            path.join(outputDir, `addresses_batch_${i + 1}.json`),
            JSON.stringify(addressesBatch, null, 2)
        );

        // Save values batch
        fs.writeFileSync(
            path.join(outputDir, `values_batch_${i + 1}.json`),
            JSON.stringify(valuesBatch, null, 2)
        );

        console.log(`Created batch ${i + 1} for ${network}`);
    }

    // Log sample conversions for verification
    if (addresses.length > 0) {
        console.log(`\nSample conversions for ${network}:`);
        const sampleIdx = Math.min(2, addresses.length - 1);
        const sampleAddr = addresses[sampleIdx];
        console.log(`Original: ${data[sampleAddr]}`);
        console.log(`Converted: ${values[sampleIdx]}`);
    }

    console.log(`\nProcessed ${network}: ${addresses.length} entries split into ${numBatches} batches`);
}

// Process files for each network
try {
    NETWORKS.forEach(network => {
        console.log(`Processing ${network}...`);
        processRtknsFile(network);
    });
} catch (error) {
    console.error('Error processing files:', error);
}