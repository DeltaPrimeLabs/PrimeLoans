{
  "language": "Solidity",
  "sources": {
    "contracts/aave_v3/flashloan/base/FlashLoanReceiverBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.4;\r\n\r\nimport {IFlashLoanReceiver} from \"../interfaces/IFlashLoanReceiver.sol\";\r\nimport {IPoolAddressesProvider} from \"../../interfaces/IPoolAddressesProvider.sol\";\r\nimport {IPool} from \"../../interfaces/IPool.sol\";\r\n\r\n/**\r\n * @title FlashLoanReceiverBase\r\n * @author Aave\r\n * @notice Base contract to develop a flashloan-receiver contract.\r\n */\r\nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver {\r\n    IPoolAddressesProvider public immutable override ADDRESSES_PROVIDER;\r\n    IPool public immutable override POOL;\r\n\r\n    constructor(IPoolAddressesProvider provider) {\r\n        ADDRESSES_PROVIDER = provider;\r\n        POOL = IPool(provider.getPool());\r\n    }\r\n}\r\n"
    },
    "contracts/aave_v3/flashloan/interfaces/IFlashLoanReceiver.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.4;\r\n\r\nimport {IPoolAddressesProvider} from \"../../interfaces/IPoolAddressesProvider.sol\";\r\nimport {IPool} from \"../../interfaces/IPool.sol\";\r\n\r\n/**\r\n * @title IFlashLoanReceiver\r\n * @author Aave\r\n * @notice Defines the basic interface of a flashloan-receiver contract.\r\n * @dev Implement this interface to develop a flashloan-compatible flashLoanReceiver contract\r\n **/\r\ninterface IFlashLoanReceiver {\r\n    /**\r\n     * @notice Executes an operation after receiving the flash-borrowed assets\r\n     * @dev Ensure that the contract can return the debt + premium, e.g., has\r\n     *      enough funds to repay and has approved the Pool to pull the total amount\r\n     * @param assets The addresses of the flash-borrowed assets\r\n     * @param amounts The amounts of the flash-borrowed assets\r\n     * @param premiums The fee of each flash-borrowed asset\r\n     * @param initiator The address of the flashloan initiator\r\n     * @param params The byte-encoded params passed when initiating the flashloan\r\n     * @return True if the execution of the operation succeeds, false otherwise\r\n     */\r\n    function executeOperation(\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata premiums,\r\n        address initiator,\r\n        bytes calldata params\r\n    ) external returns (bool);\r\n\r\n    function ADDRESSES_PROVIDER()\r\n        external\r\n        view\r\n        returns (IPoolAddressesProvider);\r\n\r\n    function POOL() external view returns (IPool);\r\n}\r\n"
    },
    "contracts/aave_v3/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @title IPoolAddressesProvider\r\n * @author Aave\r\n * @notice Defines the basic interface for a Pool Addresses Provider.\r\n **/\r\ninterface IPoolAddressesProvider {\r\n    /**\r\n     * @dev Emitted when the market identifier is updated.\r\n     * @param oldMarketId The old id of the market\r\n     * @param newMarketId The new id of the market\r\n     */\r\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\r\n\r\n    /**\r\n     * @dev Emitted when the pool is updated.\r\n     * @param oldAddress The old address of the Pool\r\n     * @param newAddress The new address of the Pool\r\n     */\r\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n    /**\r\n     * @dev Emitted when the pool configurator is updated.\r\n     * @param oldAddress The old address of the PoolConfigurator\r\n     * @param newAddress The new address of the PoolConfigurator\r\n     */\r\n    event PoolConfiguratorUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the price oracle is updated.\r\n     * @param oldAddress The old address of the PriceOracle\r\n     * @param newAddress The new address of the PriceOracle\r\n     */\r\n    event PriceOracleUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the ACL manager is updated.\r\n     * @param oldAddress The old address of the ACLManager\r\n     * @param newAddress The new address of the ACLManager\r\n     */\r\n    event ACLManagerUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the ACL admin is updated.\r\n     * @param oldAddress The old address of the ACLAdmin\r\n     * @param newAddress The new address of the ACLAdmin\r\n     */\r\n    event ACLAdminUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the price oracle sentinel is updated.\r\n     * @param oldAddress The old address of the PriceOracleSentinel\r\n     * @param newAddress The new address of the PriceOracleSentinel\r\n     */\r\n    event PriceOracleSentinelUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the pool data provider is updated.\r\n     * @param oldAddress The old address of the PoolDataProvider\r\n     * @param newAddress The new address of the PoolDataProvider\r\n     */\r\n    event PoolDataProviderUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a new proxy is created.\r\n     * @param id The identifier of the proxy\r\n     * @param proxyAddress The address of the created proxy contract\r\n     * @param implementationAddress The address of the implementation contract\r\n     */\r\n    event ProxyCreated(\r\n        bytes32 indexed id,\r\n        address indexed proxyAddress,\r\n        address indexed implementationAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a new non-proxied contract address is registered.\r\n     * @param id The identifier of the contract\r\n     * @param oldAddress The address of the old contract\r\n     * @param newAddress The address of the new contract\r\n     */\r\n    event AddressSet(\r\n        bytes32 indexed id,\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the implementation of the proxy registered with id is updated\r\n     * @param id The identifier of the contract\r\n     * @param proxyAddress The address of the proxy contract\r\n     * @param oldImplementationAddress The address of the old implementation contract\r\n     * @param newImplementationAddress The address of the new implementation contract\r\n     */\r\n    event AddressSetAsProxy(\r\n        bytes32 indexed id,\r\n        address indexed proxyAddress,\r\n        address oldImplementationAddress,\r\n        address indexed newImplementationAddress\r\n    );\r\n\r\n    /**\r\n     * @notice Returns the id of the Aave market to which this contract points to.\r\n     * @return The market id\r\n     **/\r\n    function getMarketId() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Associates an id with a specific PoolAddressesProvider.\r\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\r\n     * identify and validate multiple Aave markets.\r\n     * @param newMarketId The market id\r\n     */\r\n    function setMarketId(string calldata newMarketId) external;\r\n\r\n    /**\r\n     * @notice Returns an address by its identifier.\r\n     * @dev The returned address might be an EOA or a contract, potentially proxied\r\n     * @dev It returns ZERO if there is no registered address with the given id\r\n     * @param id The id\r\n     * @return The address of the registered for the specified id\r\n     */\r\n    function getAddress(bytes32 id) external view returns (address);\r\n\r\n    /**\r\n     * @notice General function to update the implementation of a proxy registered with\r\n     * certain `id`. If there is no proxy registered, it will instantiate one and\r\n     * set as implementation the `newImplementationAddress`.\r\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\r\n     * setter function, in order to avoid unexpected consequences\r\n     * @param id The id\r\n     * @param newImplementationAddress The address of the new implementation\r\n     */\r\n    function setAddressAsProxy(bytes32 id, address newImplementationAddress)\r\n        external;\r\n\r\n    /**\r\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\r\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\r\n     * @param id The id\r\n     * @param newAddress The address to set\r\n     */\r\n    function setAddress(bytes32 id, address newAddress) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the Pool proxy.\r\n     * @return The Pool proxy address\r\n     **/\r\n    function getPool() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the implementation of the Pool, or creates a proxy\r\n     * setting the new `pool` implementation when the function is called for the first time.\r\n     * @param newPoolImpl The new Pool implementation\r\n     **/\r\n    function setPoolImpl(address newPoolImpl) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the PoolConfigurator proxy.\r\n     * @return The PoolConfigurator proxy address\r\n     **/\r\n    function getPoolConfigurator() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\r\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\r\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\r\n     **/\r\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the price oracle.\r\n     * @return The address of the PriceOracle\r\n     */\r\n    function getPriceOracle() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the price oracle.\r\n     * @param newPriceOracle The address of the new PriceOracle\r\n     */\r\n    function setPriceOracle(address newPriceOracle) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the ACL manager.\r\n     * @return The address of the ACLManager\r\n     */\r\n    function getACLManager() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the ACL manager.\r\n     * @param newAclManager The address of the new ACLManager\r\n     **/\r\n    function setACLManager(address newAclManager) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the ACL admin.\r\n     * @return The address of the ACL admin\r\n     */\r\n    function getACLAdmin() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the ACL admin.\r\n     * @param newAclAdmin The address of the new ACL admin\r\n     */\r\n    function setACLAdmin(address newAclAdmin) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the price oracle sentinel.\r\n     * @return The address of the PriceOracleSentinel\r\n     */\r\n    function getPriceOracleSentinel() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the price oracle sentinel.\r\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\r\n     **/\r\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the data provider.\r\n     * @return The address of the DataProvider\r\n     */\r\n    function getPoolDataProvider() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the data provider.\r\n     * @param newDataProvider The address of the new DataProvider\r\n     **/\r\n    function setPoolDataProvider(address newDataProvider) external;\r\n}\r\n"
    },
    "contracts/aave_v3/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.4;\r\n\r\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\r\nimport {DataTypes} from \"../protocol/libraries/types/DataTypes.sol\";\r\n\r\n/**\r\n * @title IPool\r\n * @author Aave\r\n * @notice Defines the basic interface for an Aave Pool.\r\n **/\r\ninterface IPool {\r\n    /**\r\n     * @dev Emitted on mintUnbacked()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the supply\r\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\r\n     * @param amount The amount of supplied assets\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event MintUnbacked(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on backUnbacked()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param backer The address paying for the backing\r\n     * @param amount The amount added as backing\r\n     * @param fee The amount paid in fees\r\n     **/\r\n    event BackUnbacked(\r\n        address indexed reserve,\r\n        address indexed backer,\r\n        uint256 amount,\r\n        uint256 fee\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on supply()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the supply\r\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\r\n     * @param amount The amount supplied\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event Supply(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on withdraw()\r\n     * @param reserve The address of the underlying asset being withdrawn\r\n     * @param user The address initiating the withdrawal, owner of aTokens\r\n     * @param to The address that will receive the underlying\r\n     * @param amount The amount to be withdrawn\r\n     **/\r\n    event Withdraw(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n     * @param reserve The address of the underlying asset being borrowed\r\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n     * initiator of the transaction on flashLoan()\r\n     * @param onBehalfOf The address that will be getting the debt\r\n     * @param amount The amount borrowed out\r\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\r\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event Borrow(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        DataTypes.InterestRateMode interestRateMode,\r\n        uint256 borrowRate,\r\n        uint16 indexed referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on repay()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The beneficiary of the repayment, getting his debt reduced\r\n     * @param repayer The address of the user initiating the repay(), providing the funds\r\n     * @param amount The amount repaid\r\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\r\n     **/\r\n    event Repay(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed repayer,\r\n        uint256 amount,\r\n        bool useATokens\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on swapBorrowRateMode()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user swapping his rate mode\r\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\r\n     **/\r\n    event SwapBorrowRateMode(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        DataTypes.InterestRateMode interestRateMode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @param totalDebt The total isolation mode debt for the reserve\r\n     */\r\n    event IsolationModeTotalDebtUpdated(\r\n        address indexed asset,\r\n        uint256 totalDebt\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the user selects a certain asset category for eMode\r\n     * @param user The address of the user\r\n     * @param categoryId The category id\r\n     **/\r\n    event UserEModeSet(address indexed user, uint8 categoryId);\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralEnabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralDisabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on rebalanceStableBorrowRate()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user for which the rebalance has been executed\r\n     **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on flashLoan()\r\n     * @param target The address of the flash loan receiver contract\r\n     * @param initiator The address initiating the flash loan\r\n     * @param asset The address of the asset being flash borrowed\r\n     * @param amount The amount flash borrowed\r\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\r\n     * @param premium The fee flash borrowed\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event FlashLoan(\r\n        address indexed target,\r\n        address initiator,\r\n        address indexed asset,\r\n        uint256 amount,\r\n        DataTypes.InterestRateMode interestRateMode,\r\n        uint256 premium,\r\n        uint16 indexed referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a borrower is liquidated.\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\r\n     * @param liquidator The address of the liquidator\r\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    event LiquidationCall(\r\n        address indexed collateralAsset,\r\n        address indexed debtAsset,\r\n        address indexed user,\r\n        uint256 debtToCover,\r\n        uint256 liquidatedCollateralAmount,\r\n        address liquidator,\r\n        bool receiveAToken\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the state of a reserve is updated.\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param liquidityRate The next liquidity rate\r\n     * @param stableBorrowRate The next stable borrow rate\r\n     * @param variableBorrowRate The next variable borrow rate\r\n     * @param liquidityIndex The next liquidity index\r\n     * @param variableBorrowIndex The next variable borrow index\r\n     **/\r\n    event ReserveDataUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\r\n     * @param reserve The address of the reserve\r\n     * @param amountMinted The amount minted to the treasury\r\n     **/\r\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\r\n\r\n    /**\r\n     * @dev Mints an `amount` of aTokens to the `onBehalfOf`\r\n     * @param asset The address of the underlying asset to mint\r\n     * @param amount The amount to mint\r\n     * @param onBehalfOf The address that will receive the aTokens\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function mintUnbacked(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Back the current unbacked underlying with `amount` and pay `fee`.\r\n     * @param asset The address of the underlying asset to back\r\n     * @param amount The amount to back\r\n     * @param fee The amount paid in fees\r\n     **/\r\n    function backUnbacked(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 fee\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to supply\r\n     * @param amount The amount to be supplied\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function supply(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\r\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\r\n     * @param asset The address of the underlying asset to supply\r\n     * @param amount The amount to be supplied\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param deadline The deadline timestamp that the permit is valid\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param permitV The V parameter of ERC712 permit sig\r\n     * @param permitR The R parameter of ERC712 permit sig\r\n     * @param permitS The S parameter of ERC712 permit sig\r\n     **/\r\n    function supplyWithPermit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode,\r\n        uint256 deadline,\r\n        uint8 permitV,\r\n        bytes32 permitR,\r\n        bytes32 permitS\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to The address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\r\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n     * @param asset The address of the underlying asset to borrow\r\n     * @param amount The amount to be borrowed\r\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\r\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n     * if he has been given credit delegation allowance\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @return The final amount repaid\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        address onBehalfOf\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\r\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @param deadline The deadline timestamp that the permit is valid\r\n     * @param permitV The V parameter of ERC712 permit sig\r\n     * @param permitR The R parameter of ERC712 permit sig\r\n     * @param permitS The S parameter of ERC712 permit sig\r\n     * @return The final amount repaid\r\n     **/\r\n    function repayWithPermit(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        address onBehalfOf,\r\n        uint256 deadline,\r\n        uint8 permitV,\r\n        bytes32 permitR,\r\n        bytes32 permitS\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\r\n     * equivalent debt tokens\r\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\r\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\r\n     * balance is not enough to cover the whole debt\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @return The final amount repaid\r\n     **/\r\n    function repayWithATokens(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\r\n     **/\r\n    function swapBorrowRateMode(address asset, uint256 interestRateMode)\r\n        external;\r\n\r\n    /**\r\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n     * - Users can be rebalanced if the following conditions are satisfied:\r\n     *     1. Usage ratio is above 95%\r\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\r\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param user The address of the user to be rebalanced\r\n     **/\r\n    function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n    /**\r\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\r\n     * @param asset The address of the underlying asset supplied\r\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\r\n     **/\r\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n        external;\r\n\r\n    /**\r\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\r\n     * into consideration. For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\r\n     * @param assets The addresses of the assets being flash-borrowed\r\n     * @param amounts The amounts of the assets being flash-borrowed\r\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\r\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata interestRateModes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\r\n     * into consideration. For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\r\n     * @param asset The address of the asset being flash-borrowed\r\n     * @param amount The amount of the asset being flash-borrowed\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoanSimple(\r\n        address receiverAddress,\r\n        address asset,\r\n        uint256 amount,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the user account data across all the reserves\r\n     * @param user The address of the user\r\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\r\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\r\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\r\n     * @return currentLiquidationThreshold The liquidation threshold of the user\r\n     * @return ltv The loan to value of The user\r\n     * @return healthFactor The current health factor of the user\r\n     **/\r\n    function getUserAccountData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralBase,\r\n            uint256 totalDebtBase,\r\n            uint256 availableBorrowsBase,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    /**\r\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\r\n     * interest rate strategy\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\r\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\r\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\r\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n     **/\r\n    function initReserve(\r\n        address asset,\r\n        address aTokenAddress,\r\n        address stableDebtAddress,\r\n        address variableDebtAddress,\r\n        address interestRateStrategyAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Drop a reserve\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param asset The address of the underlying asset of the reserve\r\n     **/\r\n    function dropReserve(address asset) external;\r\n\r\n    /**\r\n     * @notice Updates the address of the interest rate strategy contract\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @param rateStrategyAddress The address of the interest rate strategy contract\r\n     **/\r\n    function setReserveInterestRateStrategyAddress(\r\n        address asset,\r\n        address rateStrategyAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Sets the configuration bitmap of the reserve as a whole\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @param configuration The new configuration bitmap\r\n     **/\r\n    function setConfiguration(\r\n        address asset,\r\n        DataTypes.ReserveConfigurationMap calldata configuration\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The configuration of the reserve\r\n     **/\r\n    function getConfiguration(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n    /**\r\n     * @notice Returns the configuration of the user across all the reserves\r\n     * @param user The user address\r\n     * @return The configuration of the user\r\n     **/\r\n    function getUserConfiguration(address user)\r\n        external\r\n        view\r\n        returns (DataTypes.UserConfigurationMap memory);\r\n\r\n    /**\r\n     * @notice Returns the normalized income normalized income of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve's normalized income\r\n     */\r\n    function getReserveNormalizedIncome(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the normalized variable debt per unit of asset\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve normalized variable debt\r\n     */\r\n    function getReserveNormalizedVariableDebt(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the state and configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The state and configuration data of the reserve\r\n     **/\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveData memory);\r\n\r\n    /**\r\n     * @notice Validates and finalizes an aToken transfer\r\n     * @dev Only callable by the overlying aToken of the `asset`\r\n     * @param asset The address of the underlying asset of the aToken\r\n     * @param from The user from which the aTokens are transferred\r\n     * @param to The user receiving the aTokens\r\n     * @param amount The amount being transferred/withdrawn\r\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\r\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\r\n     */\r\n    function finalizeTransfer(\r\n        address asset,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 balanceFromBefore,\r\n        uint256 balanceToBefore\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the list of the underlying assets of all the initialized reserves\r\n     * @dev It does not include dropped reserves\r\n     * @return The addresses of the underlying assets of the initialized reserves\r\n     **/\r\n    function getReservesList() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\r\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\r\n     * @return The address of the reserve associated with id\r\n     **/\r\n    function getReserveAddressById(uint16 id) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the PoolAddressesProvider connected to this contract\r\n     * @return The address of the PoolAddressesProvider\r\n     **/\r\n    function ADDRESSES_PROVIDER()\r\n        external\r\n        view\r\n        returns (IPoolAddressesProvider);\r\n\r\n    /**\r\n     * @notice Updates the protocol fee on the bridging\r\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\r\n     */\r\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\r\n\r\n    /**\r\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\r\n     * - A part is sent to aToken holders as extra, one time accumulated interest\r\n     * - A part is collected by the protocol treasury\r\n     * @dev The total premium is calculated on the total borrowed amount\r\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\r\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\r\n     */\r\n    function updateFlashloanPremiums(\r\n        uint128 flashLoanPremiumTotal,\r\n        uint128 flashLoanPremiumToProtocol\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Configures a new category for the eMode.\r\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\r\n     * The category 0 is reserved as it's the default for volatile assets\r\n     * @param id The id of the category\r\n     * @param config The configuration of the category\r\n     */\r\n    function configureEModeCategory(\r\n        uint8 id,\r\n        DataTypes.EModeCategory memory config\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the data of an eMode category\r\n     * @param id The id of the category\r\n     * @return The configuration data of the category\r\n     */\r\n    function getEModeCategoryData(uint8 id)\r\n        external\r\n        view\r\n        returns (DataTypes.EModeCategory memory);\r\n\r\n    /**\r\n     * @notice Allows a user to use the protocol in eMode\r\n     * @param categoryId The id of the category\r\n     */\r\n    function setUserEMode(uint8 categoryId) external;\r\n\r\n    /**\r\n     * @notice Returns the eMode the user is using\r\n     * @param user The address of the user\r\n     * @return The eMode id\r\n     */\r\n    function getUserEMode(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Resets the isolation mode total debt of the given asset to zero\r\n     * @dev It requires the given asset has zero debt ceiling\r\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\r\n     */\r\n    function resetIsolationModeTotalDebt(address asset) external;\r\n\r\n    /**\r\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\r\n     * @return The percentage of available liquidity to borrow, expressed in bps\r\n     */\r\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the total fee on flash loans\r\n     * @return The total fee on flashloans\r\n     */\r\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\r\n\r\n    /**\r\n     * @notice Returns the part of the bridge fees sent to protocol\r\n     * @return The bridge fee sent to the protocol treasury\r\n     */\r\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the part of the flashloan fees sent to protocol\r\n     * @return The flashloan fee sent to the protocol treasury\r\n     */\r\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\r\n\r\n    /**\r\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\r\n     * @return The maximum number of reserves supported\r\n     */\r\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\r\n\r\n    /**\r\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\r\n     * @param assets The list of reserves for which the minting needs to be executed\r\n     **/\r\n    function mintToTreasury(address[] calldata assets) external;\r\n\r\n    /**\r\n     * @notice Rescue and transfer tokens locked in this contract\r\n     * @param token The address of the token\r\n     * @param to The address of the recipient\r\n     * @param amount The amount of token to transfer\r\n     */\r\n    function rescueTokens(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\r\n     * @dev Deprecated: Use the `supply` function instead\r\n     * @param asset The address of the underlying asset to supply\r\n     * @param amount The amount to be supplied\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n}\r\n"
    },
    "contracts/aave_v3/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.4;\r\n\r\nlibrary DataTypes {\r\n    struct ReserveData {\r\n        //stores the reserve configuration\r\n        ReserveConfigurationMap configuration;\r\n        //the liquidity index. Expressed in ray\r\n        uint128 liquidityIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint128 currentLiquidityRate;\r\n        //variable borrow index. Expressed in ray\r\n        uint128 variableBorrowIndex;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint128 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint128 currentStableBorrowRate;\r\n        //timestamp of last update\r\n        uint40 lastUpdateTimestamp;\r\n        //the id of the reserve. Represents the position in the list of the active reserves\r\n        uint16 id;\r\n        //aToken address\r\n        address aTokenAddress;\r\n        //stableDebtToken address\r\n        address stableDebtTokenAddress;\r\n        //variableDebtToken address\r\n        address variableDebtTokenAddress;\r\n        //address of the interest rate strategy\r\n        address interestRateStrategyAddress;\r\n        //the current treasury balance, scaled\r\n        uint128 accruedToTreasury;\r\n        //the outstanding unbacked aTokens minted through the bridging feature\r\n        uint128 unbacked;\r\n        //the outstanding debt borrowed against this asset in isolation mode\r\n        uint128 isolationModeTotalDebt;\r\n    }\r\n\r\n    struct ReserveConfigurationMap {\r\n        //bit 0-15: LTV\r\n        //bit 16-31: Liq. threshold\r\n        //bit 32-47: Liq. bonus\r\n        //bit 48-55: Decimals\r\n        //bit 56: reserve is active\r\n        //bit 57: reserve is frozen\r\n        //bit 58: borrowing is enabled\r\n        //bit 59: stable rate borrowing enabled\r\n        //bit 60: asset is paused\r\n        //bit 61: borrowing in isolation mode is enabled\r\n        //bit 62-63: reserved\r\n        //bit 64-79: reserve factor\r\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\r\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\r\n        //bit 152-167 liquidation protocol fee\r\n        //bit 168-175 eMode category\r\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\r\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\r\n        //bit 252-255 unused\r\n\r\n        uint256 data;\r\n    }\r\n\r\n    struct UserConfigurationMap {\r\n        /**\r\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\r\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\r\n         * asset is borrowed by the user.\r\n         */\r\n        uint256 data;\r\n    }\r\n\r\n    struct EModeCategory {\r\n        // each eMode category has a custom ltv and liquidation threshold\r\n        uint16 ltv;\r\n        uint16 liquidationThreshold;\r\n        uint16 liquidationBonus;\r\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\r\n        address priceSource;\r\n        string label;\r\n    }\r\n\r\n    enum InterestRateMode {\r\n        NONE,\r\n        STABLE,\r\n        VARIABLE\r\n    }\r\n\r\n    struct ReserveCache {\r\n        uint256 currScaledVariableDebt;\r\n        uint256 nextScaledVariableDebt;\r\n        uint256 currPrincipalStableDebt;\r\n        uint256 currAvgStableBorrowRate;\r\n        uint256 currTotalStableDebt;\r\n        uint256 nextAvgStableBorrowRate;\r\n        uint256 nextTotalStableDebt;\r\n        uint256 currLiquidityIndex;\r\n        uint256 nextLiquidityIndex;\r\n        uint256 currVariableBorrowIndex;\r\n        uint256 nextVariableBorrowIndex;\r\n        uint256 currLiquidityRate;\r\n        uint256 currVariableBorrowRate;\r\n        uint256 reserveFactor;\r\n        ReserveConfigurationMap reserveConfiguration;\r\n        address aTokenAddress;\r\n        address stableDebtTokenAddress;\r\n        address variableDebtTokenAddress;\r\n        uint40 reserveLastUpdateTimestamp;\r\n        uint40 stableDebtLastUpdateTimestamp;\r\n    }\r\n\r\n    struct ExecuteLiquidationCallParams {\r\n        uint256 reservesCount;\r\n        uint256 debtToCover;\r\n        address collateralAsset;\r\n        address debtAsset;\r\n        address user;\r\n        bool receiveAToken;\r\n        address priceOracle;\r\n        uint8 userEModeCategory;\r\n        address priceOracleSentinel;\r\n    }\r\n\r\n    struct ExecuteSupplyParams {\r\n        address asset;\r\n        uint256 amount;\r\n        address onBehalfOf;\r\n        uint16 referralCode;\r\n    }\r\n\r\n    struct ExecuteBorrowParams {\r\n        address asset;\r\n        address user;\r\n        address onBehalfOf;\r\n        uint256 amount;\r\n        InterestRateMode interestRateMode;\r\n        uint16 referralCode;\r\n        bool releaseUnderlying;\r\n        uint256 maxStableRateBorrowSizePercent;\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 userEModeCategory;\r\n        address priceOracleSentinel;\r\n    }\r\n\r\n    struct ExecuteRepayParams {\r\n        address asset;\r\n        uint256 amount;\r\n        InterestRateMode interestRateMode;\r\n        address onBehalfOf;\r\n        bool useATokens;\r\n    }\r\n\r\n    struct ExecuteWithdrawParams {\r\n        address asset;\r\n        uint256 amount;\r\n        address to;\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 userEModeCategory;\r\n    }\r\n\r\n    struct ExecuteSetUserEModeParams {\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 categoryId;\r\n    }\r\n\r\n    struct FinalizeTransferParams {\r\n        address asset;\r\n        address from;\r\n        address to;\r\n        uint256 amount;\r\n        uint256 balanceFromBefore;\r\n        uint256 balanceToBefore;\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 fromEModeCategory;\r\n    }\r\n\r\n    struct FlashloanParams {\r\n        address receiverAddress;\r\n        address[] assets;\r\n        uint256[] amounts;\r\n        uint256[] interestRateModes;\r\n        address onBehalfOf;\r\n        bytes params;\r\n        uint16 referralCode;\r\n        uint256 flashLoanPremiumToProtocol;\r\n        uint256 flashLoanPremiumTotal;\r\n        uint256 maxStableRateBorrowSizePercent;\r\n        uint256 reservesCount;\r\n        address addressesProvider;\r\n        uint8 userEModeCategory;\r\n        bool isAuthorizedFlashBorrower;\r\n    }\r\n\r\n    struct FlashloanSimpleParams {\r\n        address receiverAddress;\r\n        address asset;\r\n        uint256 amount;\r\n        bytes params;\r\n        uint16 referralCode;\r\n        uint256 flashLoanPremiumToProtocol;\r\n        uint256 flashLoanPremiumTotal;\r\n    }\r\n\r\n    struct FlashLoanRepaymentParams {\r\n        uint256 amount;\r\n        uint256 totalPremium;\r\n        uint256 flashLoanPremiumToProtocol;\r\n        address asset;\r\n        address receiverAddress;\r\n        uint16 referralCode;\r\n    }\r\n\r\n    struct CalculateUserAccountDataParams {\r\n        UserConfigurationMap userConfig;\r\n        uint256 reservesCount;\r\n        address user;\r\n        address oracle;\r\n        uint8 userEModeCategory;\r\n    }\r\n\r\n    struct ValidateBorrowParams {\r\n        ReserveCache reserveCache;\r\n        UserConfigurationMap userConfig;\r\n        address asset;\r\n        address userAddress;\r\n        uint256 amount;\r\n        InterestRateMode interestRateMode;\r\n        uint256 maxStableLoanPercent;\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 userEModeCategory;\r\n        address priceOracleSentinel;\r\n        bool isolationModeActive;\r\n        address isolationModeCollateralAddress;\r\n        uint256 isolationModeDebtCeiling;\r\n    }\r\n\r\n    struct ValidateLiquidationCallParams {\r\n        ReserveCache debtReserveCache;\r\n        uint256 totalDebt;\r\n        uint256 healthFactor;\r\n        address priceOracleSentinel;\r\n    }\r\n\r\n    struct CalculateInterestRatesParams {\r\n        uint256 unbacked;\r\n        uint256 liquidityAdded;\r\n        uint256 liquidityTaken;\r\n        uint256 totalStableDebt;\r\n        uint256 totalVariableDebt;\r\n        uint256 averageStableBorrowRate;\r\n        uint256 reserveFactor;\r\n        address reserve;\r\n        address aToken;\r\n    }\r\n\r\n    struct InitReserveParams {\r\n        address asset;\r\n        address aTokenAddress;\r\n        address stableDebtAddress;\r\n        address variableDebtAddress;\r\n        address interestRateStrategyAddress;\r\n        uint16 reservesCount;\r\n        uint16 maxNumberReserves;\r\n    }\r\n}\r\n"
    },
    "contracts/LiquidationFlashloan.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 628836252957dd59eefb208ff6d0fd6605fe3445;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./aave_v3/flashloan/base/FlashLoanReceiverBase.sol\";\r\nimport \"./facets/SmartLoanLiquidationFacet.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"./interfaces/IWrappedNativeToken.sol\";\r\n\r\ncontract LiquidationFlashloan is FlashLoanReceiverBase, Ownable {\r\n  using TransferHelper for address payable;\r\n  using TransferHelper for address;\r\n\r\n  IUniswapV2Router01 uniswapV2Router;\r\n  address wrappedNativeToken;\r\n  SmartLoanLiquidationFacet whitelistedLiquidatorsContract;\r\n\r\n  struct AssetAmount {\r\n    address asset;\r\n    uint256 amount;\r\n  }\r\n\r\n  struct LiqEnrichedParams {\r\n    address loan;\r\n    address liquidator;\r\n    address tokenManager;\r\n    uint256 bonus;\r\n  }\r\n\r\n  struct FlashLoanArgs {\r\n    address[] assets;\r\n    uint256[] amounts;\r\n    uint256[] interestRateModes;\r\n    bytes params;\r\n    uint256 bonus;\r\n    address liquidator;\r\n    address loanAddress;\r\n    address tokenManager;\r\n  }\r\n\r\n  constructor(\r\n    address _addressProvider,\r\n    address _uniswapV2Router,\r\n    address _wrappedNativeToken,\r\n    SmartLoanLiquidationFacet _whitelistedLiquidatorsContract\r\n  ) FlashLoanReceiverBase(IPoolAddressesProvider(_addressProvider)) {\r\n    uniswapV2Router = IUniswapV2Router01(_uniswapV2Router);\r\n    wrappedNativeToken = _wrappedNativeToken;\r\n    whitelistedLiquidatorsContract = _whitelistedLiquidatorsContract;\r\n  }\r\n\r\n  function transferERC20(address tokenAddress, address recipient, uint256 amount) external onlyOwner {\r\n    tokenAddress.safeTransfer(recipient, amount);\r\n  }\r\n\r\n  // ---- Extract calldata arguments ----\r\n  function getAssets() internal view returns (address[] calldata result) {\r\n    assembly {\r\n      result.length := calldataload(add(calldataload(0x04), 0x04))\r\n      result.offset := add(calldataload(0x04), 0x24)\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function getAmounts() internal view returns (uint256[] calldata result) {\r\n    assembly {\r\n      result.length := calldataload(add(calldataload(0x24), 0x04))\r\n      result.offset := add(calldataload(0x24), 0x24)\r\n    }\r\n    return result;\r\n  }\r\n\r\n  function getPremiums() internal view returns (uint256[] calldata result) {\r\n    assembly {\r\n      result.length := calldataload(add(calldataload(0x44), 0x04))\r\n      result.offset := add(calldataload(0x44), 0x24)\r\n    }\r\n    return result;\r\n  }\r\n  // --------------------------------------\r\n\r\n  /**\r\n   * @notice Executes an operation after receiving the flash-borrowed assets\r\n   * @dev Ensure that the contract can return the debt + premium, e.g., has\r\n   *      enough funds to repay and has approved the Pool to pull the total amount\r\n   * assets The addresses of the flash-borrowed assets\r\n   * amounts The amounts of the flash-borrowed assets\r\n   * premiums The fee of each flash-borrowed asset\r\n   * @param _initiator The address of the flashloan initiator\r\n   * @param _params The byte-encoded params passed when initiating the flashloan\r\n   * @return True if the execution of the operation succeeds, false otherwise\r\n   */\r\n  function executeOperation(\r\n    address[] calldata,\r\n    uint256[] calldata,\r\n    uint256[] calldata,\r\n    address _initiator,\r\n    bytes calldata _params\r\n  ) public override returns (bool) {\r\n    LiqEnrichedParams memory lep = getLiqEnrichedParams(_params);\r\n    address[] memory supportedTokens = ITokenManager(lep.tokenManager).getSupportedTokensAddresses();\r\n\r\n    AssetAmount[] memory assetSurplus = new AssetAmount[](supportedTokens.length);\r\n    AssetAmount[] memory assetDeficit = new AssetAmount[](supportedTokens.length);\r\n\r\n    // Use calldata instead of memory in order to avoid the \"Stack Too deep\" CompileError\r\n    address[] calldata assets = getAssets();\r\n    uint256[] calldata amounts = getAmounts();\r\n    uint256[] calldata premiums = getPremiums();\r\n\r\n    for (uint32 i = 0; i < assets.length; i++) {\r\n      IERC20(assets[i]).approve(lep.loan, 0);\r\n      IERC20(assets[i]).approve(lep.loan, amounts[i]);\r\n    }\r\n\r\n    // Liquidate loan\r\n    {\r\n      (bool success,) = lep.loan.call(\r\n        abi.encodePacked(\r\n          abi.encodeWithSelector(\r\n            SmartLoanLiquidationFacet.liquidateLoan.selector,\r\n            ITokenManager(lep.tokenManager).getAllPoolAssets(),\r\n            amounts,\r\n            lep.bonus\r\n          ),\r\n          _params\r\n        )\r\n      );\r\n      require(success, \"Liquidation failed\");\r\n    }\r\n\r\n    // Calculate surpluses & deficits\r\n    for (uint32 i = 0; i < supportedTokens.length; i++) {\r\n      int256 index = findIndex(supportedTokens[i], assets);\r\n      uint256 balance = IERC20Metadata(supportedTokens[i]).balanceOf(address(this));\r\n\r\n      if (index != - 1) {\r\n        int256 amount = int256(balance) - int256(amounts[uint256(index)]) - int256(premiums[uint256(index)]);\r\n        if (amount > 0) {\r\n          assetSurplus[i] = AssetAmount(supportedTokens[uint256(index)], uint256(amount));\r\n        } else if (amount < 0) {\r\n          assetDeficit[i] = AssetAmount(supportedTokens[uint256(index)], uint256(amount * - 1));\r\n        }\r\n      } else if (balance > 0){\r\n          assetSurplus[i] = AssetAmount(\r\n            supportedTokens[i],\r\n            balance\r\n          );\r\n      }\r\n    }\r\n\r\n    // Swap to negate deficits\r\n    for (uint32 i = 0; i < assetDeficit.length; i++) {\r\n      if (assetDeficit[i].amount != 0) {\r\n        for (uint32 j = 0; j < assetSurplus.length; j++) {\r\n          if (assetSurplus[j].amount != 0) {\r\n            if (swapToNegateDeficits(assetDeficit[i], assetSurplus[j])) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Send remaining tokens (bonus) to initiator\r\n    for (uint32 i = 0; i < assetSurplus.length; i++) {\r\n      if (assetSurplus[i].amount != 0) {\r\n        address(assetSurplus[i].asset).safeTransfer(\r\n          lep.liquidator,\r\n          assetSurplus[i].amount\r\n        );\r\n      }\r\n    }\r\n\r\n    // Approve AAVE POOL\r\n    for (uint32 i = 0; i < assets.length; i++) {\r\n      IERC20(assets[i]).approve(address(POOL), 0);\r\n      IERC20(assets[i]).approve(address(POOL), amounts[i] + premiums[i]);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function executeFlashloan(FlashLoanArgs calldata _args) public onlyWhitelistedLiquidators{\r\n    bytes memory enrichedParams = bytes.concat(abi.encodePacked(_args.loanAddress), abi.encodePacked(_args.liquidator), abi.encodePacked(_args.tokenManager), abi.encodePacked(_args.bonus), _args.params);\r\n\r\n    IPool(address(POOL)).flashLoan(\r\n      address(this),\r\n      _args.assets,\r\n      _args.amounts,\r\n      _args.interestRateModes,\r\n      address(this),\r\n      enrichedParams,\r\n      0\r\n    );\r\n  }\r\n\r\n  function getLiqEnrichedParams(bytes memory _enrichedParams) internal returns (LiqEnrichedParams memory) {\r\n    address _loan;\r\n    address _liquidator;\r\n    address _tokenManager;\r\n    uint256 _bonus;\r\n    assembly {\r\n    // Read 32 bytes from _enrichedParams ptr + 32 bytes offset, shift right 12 bytes\r\n      _loan := shr(mul(0x0c, 0x08), mload(add(_enrichedParams, 0x20)))\r\n    // Read 32 bytes from _enrichedParams ptr + 52 bytes offset, shift right 12 bytes\r\n      _liquidator := shr(mul(0x0c, 0x08), mload(add(_enrichedParams, 0x34)))\r\n    // Read 32 bytes from _enrichedParams ptr + 72 bytes offset, shift right 12 bytes\r\n      _tokenManager := shr(mul(0x0c, 0x08), mload(add(_enrichedParams, 0x48)))\r\n    // Read 32 bytes from _enrichedParams ptr + 92 bytes offset\r\n      _bonus := mload(add(_enrichedParams, 0x5c))\r\n    }\r\n    return LiqEnrichedParams({\r\n      loan : _loan,\r\n      liquidator : _liquidator,\r\n      tokenManager : _tokenManager,\r\n      bonus : _bonus\r\n    });\r\n  }\r\n\r\n  function swapToNegateDeficits(\r\n    AssetAmount memory _deficit,\r\n    AssetAmount memory _surplus\r\n  ) private returns (bool shouldBreak) {\r\n\r\n    uint256[] memory amounts;\r\n    uint256 soldTokenAmountNeeded = uniswapV2Router\r\n    .getAmountsIn(\r\n      _deficit.amount,\r\n      getPath(_surplus.asset, _deficit.asset)\r\n    )[0];\r\n\r\n    if (soldTokenAmountNeeded > _surplus.amount) {\r\n      address(_surplus.asset).safeApprove(address(uniswapV2Router), 0);\r\n      address(_surplus.asset).safeApprove(\r\n        address(uniswapV2Router),\r\n        _surplus.amount\r\n      );\r\n\r\n      amounts = uniswapV2Router.swapExactTokensForTokens(\r\n        _surplus.amount,\r\n        0,\r\n        getPath(_surplus.asset, _deficit.asset),\r\n        address(this),\r\n        block.timestamp\r\n      );\r\n      _deficit.amount = _deficit.amount - amounts[amounts.length - 1];\r\n      _surplus.amount = _surplus.amount - amounts[0];\r\n      return false;\r\n    } else {\r\n      address(_surplus.asset).safeApprove(address(uniswapV2Router), 0);\r\n      address(_surplus.asset).safeApprove(\r\n        address(uniswapV2Router),\r\n        soldTokenAmountNeeded\r\n      );\r\n\r\n      amounts = uniswapV2Router.swapTokensForExactTokens(\r\n        _deficit.amount,\r\n        soldTokenAmountNeeded,\r\n        getPath(_surplus.asset, _deficit.asset),\r\n        address(this),\r\n        block.timestamp\r\n      );\r\n      _deficit.amount = _deficit.amount - amounts[amounts.length - 1];\r\n      _surplus.amount = _surplus.amount - amounts[0];\r\n      return true;\r\n    }\r\n  }\r\n\r\n  //TODO: pretty inefficient, find better way\r\n  function findIndex(address addr, address[] memory array)\r\n  internal\r\n  view\r\n  returns (int256)\r\n  {\r\n    int256 index = - 1;\r\n    for (uint256 i; i < array.length; i++) {\r\n      if (array[i] == addr) {\r\n        index = int256(i);\r\n        break;\r\n      }\r\n    }\r\n\r\n    return index;\r\n  }\r\n\r\n  function getPath(address _token1, address _token2) internal virtual view returns (address[] memory) {\r\n    address[] memory path;\r\n\r\n    if (_token1 != wrappedNativeToken && _token2 != wrappedNativeToken) {\r\n      path = new address[](3);\r\n      path[0] = _token1;\r\n      path[1] = wrappedNativeToken;\r\n      path[2] = _token2;\r\n    } else {\r\n      path = new address[](2);\r\n      path[0] = _token1;\r\n      path[1] = _token2;\r\n    }\r\n\r\n    return path;\r\n  }\r\n\r\n  modifier onlyWhitelistedLiquidators() {\r\n    // External call in order to execute this method in the SmartLoanDiamondBeacon contract storage\r\n    require(whitelistedLiquidatorsContract.isLiquidatorWhitelisted(msg.sender), \"Only whitelisted liquidators can execute this method\");\r\n    _;\r\n  }\r\n\r\n  receive() external payable {\r\n    IWrappedNativeToken wrapped = IWrappedNativeToken(DeploymentConstants.getNativeToken());\r\n    wrapped.deposit{value : msg.value}();\r\n  }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/facets/SmartLoanLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 591f922090d65eb220427875697663e2d05267f6;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"../ReentrancyGuardKeccak.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../lib/SolvencyMethods.sol\";\r\nimport \"../Pool.sol\";\r\nimport \"../interfaces/ITokenManager.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\n\r\nimport \"./SolvencyFacetProd.sol\";\r\nimport \"../SmartLoanDiamondBeacon.sol\";\r\n\r\ncontract SmartLoanLiquidationFacet is ReentrancyGuardKeccak, SolvencyMethods {\r\n    //IMPORTANT: KEEP IT IDENTICAL ACROSS FACETS TO BE PROPERLY UPDATED BY DEPLOYMENT SCRIPTS\r\n    uint256 private constant _MAX_HEALTH_AFTER_LIQUIDATION = 1.042e18;\r\n\r\n    //IMPORTANT: KEEP IT IDENTICAL ACROSS FACETS TO BE PROPERLY UPDATED BY DEPLOYMENT SCRIPTS\r\n    uint256 private constant _MAX_LIQUIDATION_BONUS = 100;\r\n\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    /** @param assetsToRepay names of tokens to be repaid to pools\r\n    /** @param amountsToRepay amounts of tokens to be repaid to pools\r\n      * @param liquidationBonus per mille bonus for liquidator. Must be smaller or equal to getMaxLiquidationBonus(). Defined for\r\n      * liquidating loans where debt ~ total value\r\n      * @param allowUnprofitableLiquidation allows performing liquidation of bankrupt loans (total value smaller than debt)\r\n    **/\r\n\r\n    struct LiquidationConfig {\r\n        bytes32[] assetsToRepay;\r\n        uint256[] amountsToRepay;\r\n        uint256 liquidationBonusPercent;\r\n        bool allowUnprofitableLiquidation;\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n      * Returns maximum acceptable health ratio after liquidation\r\n      **/\r\n    function getMaxHealthAfterLiquidation() public pure returns (uint256) {\r\n        return _MAX_HEALTH_AFTER_LIQUIDATION;\r\n    }\r\n\r\n    /**\r\n      * Returns maximum acceptable liquidation bonus (bonus is provided by a liquidator)\r\n      **/\r\n    function getMaxLiquidationBonus() public pure returns (uint256) {\r\n        return _MAX_LIQUIDATION_BONUS;\r\n    }\r\n\r\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\r\n\r\n    function whitelistLiquidators(address[] memory _liquidators) external onlyOwner {\r\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\r\n\r\n        for(uint i; i<_liquidators.length; i++){\r\n            ls.canLiquidate[_liquidators[i]] = true;\r\n            emit LiquidatorWhitelisted(_liquidators[i], msg.sender, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function delistLiquidators(address[] memory _liquidators) external onlyOwner {\r\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\r\n        for(uint i; i<_liquidators.length; i++){\r\n            ls.canLiquidate[_liquidators[i]] = false;\r\n            emit LiquidatorDelisted(_liquidators[i], msg.sender, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function isLiquidatorWhitelisted(address _liquidator) public view returns(bool){\r\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\r\n        return ls.canLiquidate[_liquidator];\r\n    }\r\n\r\n    /**\r\n    * This function can be accessed by any user when Prime Account is insolvent or bankrupt and repay part of the loan\r\n    * with his approved tokens.\r\n    * BE CAREFUL: in contrast to liquidateLoan() method, this one doesn't necessarily return tokens to liquidator, nor give him\r\n    * a bonus. It's purpose is to bring the loan to a solvent position even if it's unprofitable for liquidator.\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param assetsToRepay bytes32[] names of tokens provided by liquidator for repayment\r\n    * @param amountsToRepay utin256[] amounts of tokens provided by liquidator for repayment\r\n    * @param _liquidationBonusPercent per mille bonus for liquidator. Must be lower than or equal to getMaxliquidationBonus()\r\n    **/\r\n    function unsafeLiquidateLoan(bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonusPercent) external payable onlyWhitelistedLiquidators nonReentrant {\r\n        liquidate(\r\n            LiquidationConfig({\r\n                assetsToRepay : assetsToRepay,\r\n                amountsToRepay : amountsToRepay,\r\n                liquidationBonusPercent : _liquidationBonusPercent,\r\n                allowUnprofitableLiquidation : true\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n    * This function can be accessed by any user when Prime Account is insolvent and liquidate part of the loan\r\n    * with his approved tokens.\r\n    * A liquidator has to approve adequate amount of tokens to repay debts to liquidity pools if\r\n    * there is not enough of them in a SmartLoan. For that he will receive the corresponding amount from SmartLoan\r\n    * with the same USD value + bonus.\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param assetsToRepay bytes32[] names of tokens provided by liquidator for repayment\r\n    * @param amountsToRepay utin256[] amounts of tokens provided by liquidator for repayment\r\n    * @param _liquidationBonusPercent per mille bonus for liquidator. Must be lower than or equal to  getMaxLiquidationBonus()\r\n    **/\r\n    function liquidateLoan(bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonusPercent) external payable onlyWhitelistedLiquidators nonReentrant {\r\n        liquidate(\r\n            LiquidationConfig({\r\n                assetsToRepay : assetsToRepay,\r\n                amountsToRepay : amountsToRepay,\r\n                liquidationBonusPercent : _liquidationBonusPercent,\r\n                allowUnprofitableLiquidation : false\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n    * This function can be accessed when Prime Account is insolvent and perform a partial liquidation of the loan\r\n    * (selling assets, closing positions and repaying debts) to bring the account back to a solvent state. At the end\r\n    * of liquidation resulting solvency of account is checked to make sure that the account is between maximum and minimum\r\n    * solvency.\r\n    * To diminish the potential effect of manipulation of liquidity pools by a liquidator, there are no swaps performed\r\n    * during liquidation.\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param config configuration for liquidation\r\n    **/\r\n    function liquidate(LiquidationConfig memory config) internal recalculateAssetsExposure{\r\n        SolvencyFacetProd.CachedPrices memory cachedPrices = _getAllPricesForLiquidation(config.assetsToRepay);\r\n        \r\n        uint256 initialTotal = _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices); \r\n        uint256 initialDebt = _getDebtWithPrices(cachedPrices.debtAssetsPrices); \r\n\r\n        require(config.liquidationBonusPercent <= getMaxLiquidationBonus(), \"Defined liquidation bonus higher than max. value\");\r\n        require(!_isSolventWithPrices(cachedPrices), \"Cannot sellout a solvent account\");\r\n\r\n        //healing means bringing a bankrupt loan to a state when debt is smaller than total value again\r\n        bool healingLoan = initialDebt > initialTotal;\r\n        require(!healingLoan || config.allowUnprofitableLiquidation, \"Trying to liquidate bankrupt loan\");\r\n\r\n\r\n        uint256 suppliedInUSD;\r\n        uint256 repaidInUSD;\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n\r\n        for (uint256 i = 0; i < config.assetsToRepay.length; i++) {\r\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(config.assetsToRepay[i], true));\r\n\r\n            uint256 balance = token.balanceOf(address(this));\r\n            uint256 supplyAmount;\r\n\r\n            if (balance < config.amountsToRepay[i]) {\r\n                supplyAmount = config.amountsToRepay[i] - balance;\r\n            }\r\n\r\n            if (supplyAmount > 0) {\r\n                address(token).safeTransferFrom(msg.sender, address(this), supplyAmount);\r\n                // supplyAmount is denominated in token.decimals(). Price is denominated in 1e8. To achieve 1e18 decimals we need to multiply by 1e10.\r\n                suppliedInUSD += supplyAmount * cachedPrices.assetsToRepayPrices[i].price * 10 ** 10 / 10 ** token.decimals();\r\n            }\r\n\r\n            Pool pool = Pool(tokenManager.getPoolAddress(config.assetsToRepay[i]));\r\n\r\n            uint256 repayAmount = Math.min(pool.getBorrowed(address(this)), config.amountsToRepay[i]);\r\n\r\n            address(token).safeApprove(address(pool), 0);\r\n            address(token).safeApprove(address(pool), repayAmount);\r\n\r\n            // repayAmount is denominated in token.decimals(). Price is denominated in 1e8. To achieve 1e18 decimals we need to multiply by 1e10.\r\n            repaidInUSD += repayAmount * cachedPrices.assetsToRepayPrices[i].price * 10 ** 10 / 10 ** token.decimals();\r\n\r\n            pool.repay(repayAmount);\r\n\r\n            if (token.balanceOf(address(this)) == 0) {\r\n                DiamondStorageLib.removeOwnedAsset(config.assetsToRepay[i]);\r\n            }\r\n\r\n            emit LiquidationRepay(msg.sender, config.assetsToRepay[i], repayAmount, block.timestamp);\r\n        }\r\n\r\n        bytes32[] memory assetsOwned = DeploymentConstants.getAllOwnedAssets();\r\n        uint256 bonusInUSD;\r\n\r\n        //after healing bankrupt loan (debt > total value), no tokens are returned to liquidator\r\n\r\n        bonusInUSD = repaidInUSD * config.liquidationBonusPercent / DeploymentConstants.getPercentagePrecision();\r\n\r\n        //meaning returning all tokens\r\n        uint256 partToReturn = 10 ** 18; // 1\r\n        uint256 assetsValue = _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices);\r\n\r\n        if (!healingLoan && assetsValue >= suppliedInUSD + bonusInUSD) {\r\n            //in that scenario we calculate how big part of token to return\r\n            partToReturn = (suppliedInUSD + bonusInUSD) * 10 ** 18 / assetsValue;\r\n        }\r\n\r\n        if(partToReturn > 0){\r\n            // Native token transfer\r\n            if (address(this).balance > 0) {\r\n                payable(msg.sender).safeTransferETH(address(this).balance * partToReturn / 10 ** 18);\r\n            }\r\n\r\n            for (uint256 i; i < assetsOwned.length; i++) {\r\n                IERC20Metadata token = getERC20TokenInstance(assetsOwned[i], true);\r\n                uint256 balance = token.balanceOf(address(this));\r\n\r\n                address(token).safeTransfer(msg.sender, balance * partToReturn / 10 ** 18);\r\n                emit LiquidationTransfer(msg.sender, assetsOwned[i], balance * partToReturn / 10 ** 18, block.timestamp);\r\n            }\r\n        }\r\n\r\n        uint256 health = _getHealthRatioWithPrices(cachedPrices);\r\n\r\n        if (healingLoan) {\r\n            require(_getDebtWithPrices(cachedPrices.debtAssetsPrices) == 0, \"Healing a loan must end up with 0 debt\");\r\n            require(_getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices) == 0, \"Healing a loan must end up with 0 total value\");\r\n        } else {\r\n            require(health <= getMaxHealthAfterLiquidation(), \"This operation would result in a loan with health ratio higher than Maxium Health Ratio which would put loan's owner in a risk of an unnecessarily high loss\");\r\n        }\r\n\r\n        require(health >= 1e18, \"This operation would not result in bringing the loan back to a solvent state\");\r\n\r\n        //TODO: include final debt and tv\r\n        emit Liquidated(msg.sender, healingLoan, initialTotal, initialDebt, repaidInUSD, bonusInUSD, health, block.timestamp);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelistedLiquidators() {\r\n        // External call in order to execute this method in the SmartLoanDiamondBeacon contract storage\r\n        require(SmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender), \"Only whitelisted liquidators can execute this method\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after a successful liquidation operation\r\n     * @param liquidator the address that initiated the liquidation operation\r\n     * @param healing was the liquidation covering the bad debt (unprofitable liquidation)\r\n     * @param initialTotal total value of assets before the liquidation\r\n     * @param initialDebt sum of all debts before the liquidation\r\n     * @param repayAmount requested amount (USD) of liquidation\r\n     * @param bonusInUSD an amount of bonus (USD) received by the liquidator\r\n     * @param health a new health ratio after the liquidation operation\r\n     * @param timestamp a time of the liquidation\r\n     **/\r\n    event Liquidated(address indexed liquidator, bool indexed healing, uint256 initialTotal, uint256 initialDebt, uint256 repayAmount, uint256 bonusInUSD, uint256 health, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when funds are repaid to the pool during a liquidation\r\n     * @param liquidator the address initiating repayment\r\n     * @param asset asset repaid by a liquidator\r\n     * @param amount of repaid funds\r\n     * @param timestamp of the repayment\r\n     **/\r\n    event LiquidationRepay(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when funds are sent to liquidator during liquidation\r\n     * @param liquidator the address initiating repayment\r\n     * @param asset token sent to a liquidator\r\n     * @param amount of sent funds\r\n     * @param timestamp of the transfer\r\n     **/\r\n    event LiquidationTransfer(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when a new liquidator gets whitelisted\r\n     * @param liquidator the address being whitelisted\r\n     * @param performer the address initiating whitelisting\r\n     * @param timestamp of the whitelisting\r\n     **/\r\n    event LiquidatorWhitelisted(address indexed liquidator, address performer, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when a liquidator gets delisted\r\n     * @param liquidator the address being delisted\r\n     * @param performer the address initiating delisting\r\n     * @param timestamp of the delisting\r\n     **/\r\n    event LiquidatorDelisted(address indexed liquidator, address performer, uint256 timestamp);\r\n}\r\n\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "contracts/interfaces/IWrappedNativeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IWrappedNativeToken {\r\n\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint wad) external;\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function approve(address guy, uint wad) external returns (bool);\r\n\r\n    function transfer(address dst, uint wad) external returns (bool);\r\n\r\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\r\n\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/ReentrancyGuardKeccak.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Modified version of Openzeppelin (OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)) ReentrancyGuard\r\n// contract that uses keccak slots instead of the standard storage layout.\r\n\r\nimport {DiamondStorageLib} from \"./lib/DiamondStorageLib.sol\";\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n */\r\nabstract contract ReentrancyGuardKeccak {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        DiamondStorageLib.ReentrancyGuardStorage storage rgs = DiamondStorageLib.reentrancyGuardStorage();\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(rgs._status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        rgs._status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        rgs._status = _NOT_ENTERED;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/lib/SolvencyMethods.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\r\nimport \"../facets/SolvencyFacetProd.sol\";\r\nimport \"../facets/AssetsExposureController.sol\";\r\nimport \"../DiamondHelper.sol\";\r\n\r\n// TODO Rename to contract instead of lib\r\ncontract SolvencyMethods is DiamondHelper, ProxyConnector {\r\n    // This function executes SolvencyFacetProd.getDebt()\r\n    function _getDebt() internal virtual returns (uint256 debt) {\r\n        debt = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getDebt.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getDebt.selector)\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getDebtWithPrices()\r\n    function _getDebtWithPrices(SolvencyFacetProd.AssetPrice[] memory debtAssetsPrices) internal virtual returns (uint256 debt) {\r\n        debt = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getDebtWithPrices.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getDebtWithPrices.selector, debtAssetsPrices)\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.isSolventWithPrices()\r\n    function _isSolventWithPrices(SolvencyFacetProd.CachedPrices memory cachedPrices) internal virtual returns (bool solvent){\r\n        solvent = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.isSolventWithPrices.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.isSolventWithPrices.selector, cachedPrices)\r\n            ),\r\n            (bool)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.isSolvent()\r\n    function _isSolvent() internal virtual returns (bool solvent){\r\n        solvent = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.isSolvent.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.isSolvent.selector)\r\n            ),\r\n            (bool)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.canRepayDebtFully()\r\n    function _canRepayDebtFully() internal virtual returns (bool solvent){\r\n        solvent = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.canRepayDebtFully.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.canRepayDebtFully.selector)\r\n            ),\r\n            (bool)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getTotalValue()\r\n    function _getTotalValue() internal virtual returns (uint256 totalValue) {\r\n        totalValue = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getTotalValue.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getTotalValue.selector)\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getTotalAssetsValue()\r\n    function _getTotalAssetsValue() internal virtual returns (uint256 assetsValue) {\r\n        assetsValue = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getTotalAssetsValue.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getTotalAssetsValue.selector)\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getHealthRatioWithPrices()\r\n    function _getHealthRatioWithPrices(SolvencyFacetProd.CachedPrices memory cachedPrices) public virtual returns (uint256 health) {\r\n        health = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getHealthRatioWithPrices.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getHealthRatioWithPrices.selector, cachedPrices)\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getHealthRatio()\r\n    function _getHealthRatio() public virtual returns (uint256 health) {\r\n        health = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getHealthRatio.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getHealthRatio.selector)\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getPrices()\r\n    function getPrices(bytes32[] memory symbols) public virtual returns (uint256[] memory prices) {\r\n        prices = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getPrices.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getPrices.selector, symbols)\r\n            ),\r\n            (uint256[])\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getPrices()\r\n    function _getAllPricesForLiquidation(bytes32[] memory assetsToRepay) public virtual returns (SolvencyFacetProd.CachedPrices memory result) {\r\n        result = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getAllPricesForLiquidation.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getAllPricesForLiquidation.selector, assetsToRepay)\r\n            ),\r\n            (SolvencyFacetProd.CachedPrices)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getOwnedAssetsWithNativePrices()\r\n    function _getOwnedAssetsWithNativePrices() internal virtual returns (SolvencyFacetProd.AssetPrice[] memory ownedAssetsPrices) {\r\n        ownedAssetsPrices = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getOwnedAssetsWithNativePrices.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getOwnedAssetsWithNativePrices.selector)\r\n            ),\r\n            (SolvencyFacetProd.AssetPrice[])\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getDebtAssetsPrices()\r\n    function _getDebtAssetsPrices() internal virtual returns (SolvencyFacetProd.AssetPrice[] memory debtAssetsPrices) {\r\n        debtAssetsPrices = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getDebtAssetsPrices.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getDebtAssetsPrices.selector)\r\n            ),\r\n            (SolvencyFacetProd.AssetPrice[])\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getStakedPositionsPrices()\r\n    function _getStakedPositionsPrices() internal virtual returns (SolvencyFacetProd.AssetPrice[] memory stakedPositionsPrices) {\r\n        stakedPositionsPrices = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getStakedPositionsPrices.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getStakedPositionsPrices.selector)\r\n            ),\r\n            (SolvencyFacetProd.AssetPrice[])\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getTotalAssetsValueWithPrices()\r\n    function _getTotalValueWithPrices(SolvencyFacetProd.AssetPrice[] memory ownedAssetsPrices, SolvencyFacetProd.AssetPrice[] memory stakedPositionsPrices) internal virtual returns (uint256 totalValue) {\r\n        totalValue = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getTotalValueWithPrices.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getTotalValueWithPrices.selector, ownedAssetsPrices, stakedPositionsPrices)\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    // This function executes SolvencyFacetProd.getPrices()\r\n    function getPrice(bytes32 symbol) public virtual returns (uint256 price) {\r\n        price = abi.decode(\r\n            proxyDelegateCalldata(\r\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getPrice.selector),\r\n                abi.encodeWithSelector(SolvencyFacetProd.getPrice.selector, symbol)\r\n            ),\r\n            (uint256)\r\n        );\r\n    }\r\n\r\n    // This function executes AssetsExposureController.decreaseAssetsExposure()\r\n    function _resetPrimeAccountAssetsExposure() public {\r\n        proxyDelegateCalldata(\r\n            DiamondHelper._getFacetAddress(AssetsExposureController.resetPrimeAccountAssetsExposure.selector),\r\n            abi.encodeWithSelector(AssetsExposureController.resetPrimeAccountAssetsExposure.selector)\r\n        );\r\n    }\r\n\r\n    // This function executes AssetsExposureController.increaseAssetsExposure()\r\n    function _setPrimeAccountAssetsExposure() public {\r\n        proxyDelegateCalldata(\r\n            DiamondHelper._getFacetAddress(AssetsExposureController.setPrimeAccountAssetsExposure.selector),\r\n            abi.encodeWithSelector(AssetsExposureController.setPrimeAccountAssetsExposure.selector)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns IERC20Metadata instance of a token\r\n     * @param _asset the code of an asset\r\n     **/\r\n    function getERC20TokenInstance(bytes32 _asset, bool allowInactive) internal view returns (IERC20Metadata) {\r\n        return IERC20Metadata(DeploymentConstants.getTokenManager().getAssetAddress(_asset, allowInactive));\r\n    }\r\n\r\n    modifier recalculateAssetsExposure() {\r\n        _resetPrimeAccountAssetsExposure();\r\n        _;\r\n        _setPrimeAccountAssetsExposure();\r\n    }\r\n\r\n    /**\r\n    * Checks whether account is solvent (health higher than 1)\r\n    * @dev This modifier uses the redstone-evm-connector\r\n    **/\r\n    modifier remainsSolvent() {\r\n        _;\r\n\r\n        require(_isSolvent(), \"The action may cause an account to become insolvent\");\r\n    }\r\n\r\n    modifier canRepayDebtFully() {\r\n        _;\r\n        require(_canRepayDebtFully(), \"Insufficient assets to fully repay the debt\");\r\n    }\r\n\r\n    modifier noBorrowInTheSameBlock() {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        require(ds._lastBorrowTimestamp != block.timestamp, \"Borrowing must happen in a standalone transaction\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 5bae95ca244e96444fe80078195944f6637e72d8;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"./interfaces/IIndex.sol\";\r\nimport \"./interfaces/IRatesCalculator.sol\";\r\nimport \"./interfaces/IBorrowersRegistry.sol\";\r\nimport \"./interfaces/IPoolRewarder.sol\";\r\n\r\n\r\n/**\r\n * @title Pool\r\n * @dev Contract allowing user to deposit to and borrow from a dedicated user account\r\n * Depositors are rewarded with the interest rates collected from borrowers.\r\n * The interest rates calculation is delegated to an external calculator contract.\r\n */\r\ncontract Pool is OwnableUpgradeable, ReentrancyGuardUpgradeable, IERC20 {\r\n    using TransferHelper for address payable;\r\n\r\n    uint256 public totalSupplyCap;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowed;\r\n    mapping(address => uint256) internal _deposited;\r\n\r\n    mapping(address => uint256) public borrowed;\r\n\r\n    IRatesCalculator public ratesCalculator;\r\n    IBorrowersRegistry public borrowersRegistry;\r\n    IPoolRewarder public poolRewarder;\r\n\r\n    IIndex public depositIndex;\r\n    IIndex public borrowIndex;\r\n\r\n    address payable public tokenAddress;\r\n\r\n    function initialize(IRatesCalculator ratesCalculator_, IBorrowersRegistry borrowersRegistry_, IIndex depositIndex_, IIndex borrowIndex_, address payable tokenAddress_, IPoolRewarder poolRewarder_, uint256 _totalSupplyCap) public initializer {\r\n        require(AddressUpgradeable.isContract(address(ratesCalculator_))\r\n            && AddressUpgradeable.isContract(address(borrowersRegistry_))\r\n            && AddressUpgradeable.isContract(address(depositIndex_))\r\n            && AddressUpgradeable.isContract(address(borrowIndex_))\r\n            && (AddressUpgradeable.isContract(address(poolRewarder_)) || address(poolRewarder_) == address(0)), \"Wrong init arguments\");\r\n\r\n        borrowersRegistry = borrowersRegistry_;\r\n        ratesCalculator = ratesCalculator_;\r\n        depositIndex = depositIndex_;\r\n        borrowIndex = borrowIndex_;\r\n        poolRewarder = poolRewarder_;\r\n        tokenAddress = tokenAddress_;\r\n        totalSupplyCap = _totalSupplyCap;\r\n\r\n        __Ownable_init();\r\n        __ReentrancyGuard_init();\r\n        _updateRates();\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * Sets new totalSupplyCap limiting how much in total can be deposited to the Pool.\r\n     * Only the owner of the Contract can execute this function.\r\n     * @dev _newTotalSupplyCap new deposit cap\r\n    **/\r\n    function setTotalSupplyCap(uint256 _newTotalSupplyCap) external onlyOwner {\r\n        totalSupplyCap = _newTotalSupplyCap;\r\n    }\r\n\r\n    /**\r\n     * Sets the new Pool Rewarder.\r\n     * The IPoolRewarder that distributes additional token rewards to people having a stake in this pool proportionally to their stake and time of participance.\r\n     * Only the owner of the Contract can execute this function.\r\n     * @dev _poolRewarder the address of PoolRewarder\r\n    **/\r\n    function setPoolRewarder(IPoolRewarder _poolRewarder) external onlyOwner {\r\n        if(!AddressUpgradeable.isContract(address(_poolRewarder)) && address(_poolRewarder) != address(0)) revert NotAContract(address(poolRewarder));\r\n        poolRewarder = _poolRewarder;\r\n\r\n        emit PoolRewarderChanged(address(_poolRewarder), block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Sets the new rate calculator.\r\n     * The calculator is an external contract that contains the logic for calculating deposit and borrowing rates.\r\n     * Only the owner of the Contract can execute this function.\r\n     * @dev ratesCalculator the address of rates calculator\r\n     **/\r\n    function setRatesCalculator(IRatesCalculator ratesCalculator_) external onlyOwner {\r\n        // setting address(0) ratesCalculator_ freezes the pool\r\n        if(!AddressUpgradeable.isContract(address(ratesCalculator_)) && address(ratesCalculator_) != address(0)) revert NotAContract(address(ratesCalculator_));\r\n        ratesCalculator = ratesCalculator_;\r\n        if (address(ratesCalculator_) != address(0)) {\r\n            _updateRates();\r\n        }\r\n\r\n        emit RatesCalculatorChanged(address(ratesCalculator_), block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Sets the new borrowers registry contract.\r\n     * The borrowers registry decides if an account can borrow funds.\r\n     * Only the owner of the Contract can execute this function.\r\n     * @dev borrowersRegistry the address of borrowers registry\r\n     **/\r\n    function setBorrowersRegistry(IBorrowersRegistry borrowersRegistry_) external onlyOwner {\r\n        if(!AddressUpgradeable.isContract(address(borrowersRegistry_))) revert NotAContract(address(borrowersRegistry_));\r\n\r\n        borrowersRegistry = borrowersRegistry_;\r\n        emit BorrowersRegistryChanged(address(borrowersRegistry_), block.timestamp);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        if(recipient == address(0)) revert TransferToZeroAddress();\r\n\r\n        if(recipient == address(this)) revert TransferToPoolAddress();\r\n\r\n        _accumulateDepositInterest(msg.sender);\r\n\r\n        if(_deposited[msg.sender] < amount) revert TransferAmountExceedsBalance(amount, _deposited[msg.sender]);\r\n\r\n        // (this is verified in \"require\" above)\r\n        unchecked {\r\n            _deposited[msg.sender] -= amount;\r\n        }\r\n\r\n        _accumulateDepositInterest(recipient);\r\n        _deposited[recipient] += amount;\r\n\r\n        // Handle rewards\r\n        if(address(poolRewarder) != address(0) && amount != 0){\r\n            uint256 unstaked = poolRewarder.withdrawFor(amount, msg.sender);\r\n            if(unstaked > 0) {\r\n                poolRewarder.stakeFor(unstaked, recipient);\r\n            }\r\n        }\r\n\r\n        emit Transfer(msg.sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        if(spender == address(0)) revert SpenderZeroAddress();\r\n        uint256 newAllowance = _allowed[msg.sender][spender] + addedValue;\r\n        _allowed[msg.sender][spender] = newAllowance;\r\n\r\n        emit Approval(msg.sender, spender, newAllowance);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        if(spender == address(0)) revert SpenderZeroAddress();\r\n        uint256 currentAllowance = _allowed[msg.sender][spender];\r\n        if(currentAllowance < subtractedValue) revert InsufficientAllowance(subtractedValue, currentAllowance);\r\n\r\n        uint256 newAllowance = currentAllowance - subtractedValue;\r\n        _allowed[msg.sender][spender] = newAllowance;\r\n\r\n        emit Approval(msg.sender, spender, newAllowance);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        if(spender == address(0)) revert SpenderZeroAddress();\r\n        _allowed[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowed[sender][msg.sender] < amount) revert InsufficientAllowance(amount, _allowed[sender][msg.sender]);\r\n\r\n        if(recipient == address(0)) revert TransferToZeroAddress();\r\n\r\n        if(recipient == address(this)) revert TransferToPoolAddress();\r\n\r\n        _accumulateDepositInterest(sender);\r\n\r\n        if(_deposited[sender] < amount) revert TransferAmountExceedsBalance(amount, _deposited[sender]);\r\n\r\n\r\n        _deposited[sender] -= amount;\r\n        _allowed[sender][msg.sender] -= amount;\r\n\r\n        _accumulateDepositInterest(recipient);\r\n        _deposited[recipient] += amount;\r\n\r\n        // Handle rewards\r\n        if(address(poolRewarder) != address(0) && amount != 0){\r\n            uint256 unstaked = poolRewarder.withdrawFor(amount, sender);\r\n            if(unstaked > 0) {\r\n                poolRewarder.stakeFor(unstaked, recipient);\r\n            }\r\n        }\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Deposits the amount\r\n     * It updates user deposited balance, total deposited and rates\r\n     **/\r\n    function deposit(uint256 _amount) public virtual nonReentrant {\r\n        if(_amount == 0) revert ZeroDepositAmount();\r\n\r\n        _accumulateDepositInterest(msg.sender);\r\n\r\n        if(totalSupplyCap != 0){\r\n            if(_deposited[address(this)] + _amount > totalSupplyCap) revert TotalSupplyCapBreached();\r\n        }\r\n\r\n        _transferToPool(msg.sender, _amount);\r\n\r\n        _mint(msg.sender, _amount);\r\n        _deposited[address(this)] += _amount;\r\n        _updateRates();\r\n\r\n        if (address(poolRewarder) != address(0)) {\r\n            poolRewarder.stakeFor(_amount, msg.sender);\r\n        }\r\n\r\n        emit Deposit(msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n    function _transferToPool(address from, uint256 amount) internal virtual {\r\n        tokenAddress.safeTransferFrom(from, address(this), amount);\r\n    }\r\n\r\n    function _transferFromPool(address to, uint256 amount) internal virtual {\r\n        tokenAddress.safeTransfer(to, amount);\r\n    }\r\n\r\n    /**\r\n     * Withdraws selected amount from the user deposits\r\n     * @dev _amount the amount to be withdrawn\r\n     **/\r\n    function withdraw(uint256 _amount) external nonReentrant {\r\n        if(_amount > IERC20(tokenAddress).balanceOf(address(this))) revert InsufficientPoolFunds();\r\n\r\n        _accumulateDepositInterest(msg.sender);\r\n\r\n        if(_amount > _deposited[address(this)]) revert BurnAmountExceedsBalance();\r\n        // verified in \"require\" above\r\n        unchecked {\r\n            _deposited[address(this)] -= _amount;\r\n        }\r\n        _burn(msg.sender, _amount);\r\n\r\n        _transferFromPool(msg.sender, _amount);\r\n\r\n        _updateRates();\r\n\r\n        if (address(poolRewarder) != address(0)) {\r\n            poolRewarder.withdrawFor(_amount, msg.sender);\r\n        }\r\n\r\n        emit Withdrawal(msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Borrows the specified amount\r\n     * It updates user borrowed balance, total borrowed amount and rates\r\n     * @dev _amount the amount to be borrowed\r\n     * @dev It is only meant to be used by a SmartLoanDiamondProxy\r\n     **/\r\n    function borrow(uint256 _amount) public virtual canBorrow nonReentrant {\r\n        if (_amount > IERC20(tokenAddress).balanceOf(address(this))) revert InsufficientPoolFunds();\r\n\r\n        _accumulateBorrowingInterest(msg.sender);\r\n\r\n        borrowed[msg.sender] += _amount;\r\n        borrowed[address(this)] += _amount;\r\n\r\n        _transferFromPool(msg.sender, _amount);\r\n\r\n        _updateRates();\r\n\r\n        emit Borrowing(msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Repays the amount\r\n     * It updates user borrowed balance, total borrowed amount and rates\r\n     * @dev It is only meant to be used by a SmartLoanDiamondProxy\r\n     **/\r\n    function repay(uint256 amount) external nonReentrant {\r\n        _accumulateBorrowingInterest(msg.sender);\r\n\r\n        if(amount > borrowed[msg.sender]) revert RepayingMoreThanWasBorrowed();\r\n        _transferToPool(msg.sender, amount);\r\n\r\n        borrowed[msg.sender] -= amount;\r\n        borrowed[address(this)] -= amount;\r\n\r\n        _updateRates();\r\n\r\n        emit Repayment(msg.sender, amount, block.timestamp);\r\n    }\r\n\r\n    /* =========\r\n\r\n\r\n    /**\r\n     * Returns the current borrowed amount for the given user\r\n     * The value includes the interest rates owned at the current moment\r\n     * @dev _user the address of queried borrower\r\n    **/\r\n    function getBorrowed(address _user) public view returns (uint256) {\r\n        return borrowIndex.getIndexedValue(borrowed[_user], _user);\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return balanceOf(address(this));\r\n    }\r\n\r\n    function totalBorrowed() public view returns (uint256) {\r\n        return getBorrowed(address(this));\r\n    }\r\n\r\n\r\n    // Calls the IPoolRewarder.getRewardsFor() that sends pending rewards to msg.sender\r\n    function getRewards() external {\r\n        poolRewarder.getRewardsFor(msg.sender);\r\n    }\r\n\r\n    // Returns number of pending rewards for msg.sender\r\n    function checkRewards() external view returns (uint256) {\r\n        return poolRewarder.earned(msg.sender);\r\n    }\r\n\r\n    // Returns max. acceptable pool utilisation after borrow action\r\n    function getMaxPoolUtilisationForBorrowing() virtual public view returns (uint256) {\r\n        return 0.9e18;\r\n    }\r\n\r\n    /**\r\n     * Returns the current deposited amount for the given user\r\n     * The value includes the interest rates earned at the current moment\r\n     * @dev _user the address of queried depositor\r\n     **/\r\n    function balanceOf(address user) public view override returns (uint256) {\r\n        return depositIndex.getIndexedValue(_deposited[user], user);\r\n    }\r\n\r\n    /**\r\n     * Returns the current interest rate for deposits\r\n     **/\r\n    function getDepositRate() public view returns (uint256) {\r\n        return ratesCalculator.calculateDepositRate(totalBorrowed(), totalSupply());\r\n    }\r\n\r\n    /**\r\n     * Returns the current interest rate for borrowings\r\n     **/\r\n    function getBorrowingRate() public view returns (uint256) {\r\n        return ratesCalculator.calculateBorrowingRate(totalBorrowed(), totalSupply());\r\n    }\r\n\r\n    /**\r\n     * Recovers the surplus funds resultant from difference between deposit and borrowing rates\r\n     **/\r\n    function recoverSurplus(uint256 amount, address account) public onlyOwner nonReentrant {\r\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\r\n        uint256 surplus = balance + totalBorrowed() - totalSupply();\r\n\r\n        if(amount > balance) revert InsufficientPoolFunds();\r\n        if(surplus < amount) revert InsufficientSurplus();\r\n\r\n        _transferFromPool(account, amount);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function _mint(address to, uint256 amount) internal {\r\n        if(to == address(0)) revert MintToAddressZero();\r\n\r\n        _deposited[to] += amount;\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        if(amount > _deposited[account]) revert BurnAmountExceedsBalance();\r\n\r\n        // verified in \"require\" above\r\n        unchecked {\r\n            _deposited[account] -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _updateRates() internal {\r\n        uint256 _totalBorrowed = totalBorrowed();\r\n        uint256 _totalSupply = totalSupply();\r\n        if(address(ratesCalculator) == address(0)) revert PoolFrozen();\r\n        depositIndex.setRate(ratesCalculator.calculateDepositRate(_totalBorrowed, _totalSupply));\r\n        borrowIndex.setRate(ratesCalculator.calculateBorrowingRate(_totalBorrowed, _totalSupply));\r\n    }\r\n\r\n    function _accumulateDepositInterest(address user) internal {\r\n        uint256 interest = balanceOf(user) - _deposited[user];\r\n\r\n        _mint(user, interest);\r\n        _deposited[address(this)] = balanceOf(address(this));\r\n\r\n        emit InterestCollected(user, interest, block.timestamp);\r\n\r\n        depositIndex.updateUser(user);\r\n        depositIndex.updateUser(address(this));\r\n    }\r\n\r\n    function _accumulateBorrowingInterest(address user) internal {\r\n        borrowed[user] = getBorrowed(user);\r\n        borrowed[address(this)] = getBorrowed(address(this));\r\n\r\n        borrowIndex.updateUser(user);\r\n        borrowIndex.updateUser(address(this));\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override {}\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier canBorrow() {\r\n        if(address(borrowersRegistry) == address(0)) revert BorrowersRegistryNotConfigured();\r\n        if(!borrowersRegistry.canBorrow(msg.sender)) revert NotAuthorizedToBorrow();\r\n        if(totalSupply() == 0) revert InsufficientPoolFunds();\r\n        _;\r\n        if((totalBorrowed() * 1e18) / totalSupply() > getMaxPoolUtilisationForBorrowing()) revert MaxPoolUtilisationBreached();\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @dev emitted after the user deposits funds\r\n     * @param user the address performing the deposit\r\n     * @param value the amount deposited\r\n     * @param timestamp of the deposit\r\n     **/\r\n    event Deposit(address indexed user, uint256 value, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after the user withdraws funds\r\n     * @param user the address performing the withdrawal\r\n     * @param value the amount withdrawn\r\n     * @param timestamp of the withdrawal\r\n     **/\r\n    event Withdrawal(address indexed user, uint256 value, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after the user borrows funds\r\n     * @param user the address that borrows\r\n     * @param value the amount borrowed\r\n     * @param timestamp time of the borrowing\r\n     **/\r\n    event Borrowing(address indexed user, uint256 value, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after the user repays debt\r\n     * @param user the address that repays debt\r\n     * @param value the amount repaid\r\n     * @param timestamp of the repayment\r\n     **/\r\n    event Repayment(address indexed user, uint256 value, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after accumulating deposit interest\r\n     * @param user the address that the deposit interest is accumulated for\r\n     * @param value the amount that interest is calculated from\r\n     * @param timestamp of the interest accumulation\r\n     **/\r\n    event InterestCollected(address indexed user, uint256 value, uint256 timestamp);\r\n\r\n    /**\r\n    * @dev emitted after changing borrowers registry\r\n    * @param registry an address of the newly set borrowers registry\r\n    * @param timestamp of the borrowers registry change\r\n    **/\r\n    event BorrowersRegistryChanged(address indexed registry, uint256 timestamp);\r\n\r\n    /**\r\n    * @dev emitted after changing rates calculator\r\n    * @param calculator an address of the newly set rates calculator\r\n    * @param timestamp of the borrowers registry change\r\n    **/\r\n    event RatesCalculatorChanged(address indexed calculator, uint256 timestamp);\r\n\r\n    /**\r\n    * @dev emitted after changing pool rewarder\r\n    * @param poolRewarder an address of the newly set pool rewarder\r\n    * @param timestamp of the pool rewarder change\r\n    **/\r\n    event PoolRewarderChanged(address indexed poolRewarder, uint256 timestamp);\r\n\r\n    /* ========== ERRORS ========== */\r\n\r\n    // Only authorized accounts may borrow\r\n    error NotAuthorizedToBorrow();\r\n\r\n    // Borrowers registry is not configured\r\n    error BorrowersRegistryNotConfigured();\r\n\r\n    // Pool is frozen\r\n    error PoolFrozen();\r\n\r\n    // Not enough funds in the pool.\r\n    error InsufficientPoolFunds();\r\n\r\n    // Insufficient pool surplus to cover the requested recover amount\r\n    error InsufficientSurplus();\r\n\r\n    // Address (`target`) must be a contract\r\n    // @param target target address that must be a contract\r\n    error NotAContract(address target);\r\n\r\n    //  ERC20: Spender cannot be a zero address\r\n    error SpenderZeroAddress();\r\n\r\n    //  ERC20: cannot transfer to the zero address\r\n    error TransferToZeroAddress();\r\n\r\n    //  ERC20: cannot transfer to the pool address\r\n    error TransferToPoolAddress();\r\n\r\n    //  ERC20: transfer amount (`amount`) exceeds balance (`balance`)\r\n    /// @param amount transfer amount\r\n    /// @param balance available balance\r\n    error TransferAmountExceedsBalance(uint256 amount, uint256 balance);\r\n\r\n    //  ERC20: requested transfer amount (`requested`) exceeds current allowance (`allowance`)\r\n    /// @param requested requested transfer amount\r\n    /// @param allowance current allowance\r\n    error InsufficientAllowance(uint256 requested, uint256 allowance);\r\n\r\n    //  This deposit operation would result in a breach of the totalSupplyCap\r\n    error TotalSupplyCapBreached();\r\n\r\n    // The deposit amount must be > 0\r\n    error ZeroDepositAmount();\r\n\r\n    // ERC20: cannot mint to the zero address\r\n    error MintToAddressZero();\r\n\r\n    // ERC20: burn amount exceeds current pool indexed balance\r\n    error BurnAmountExceedsBalance();\r\n\r\n    // Trying to repay more than was borrowed\r\n    error RepayingMoreThanWasBorrowed();\r\n\r\n    // getMaxPoolUtilisationForBorrowing was breached\r\n    error MaxPoolUtilisationBreached();\r\n}"
    },
    "contracts/interfaces/ITokenManager.sol": {
      "content": "interface ITokenManager {\r\n    struct poolAsset {\r\n        bytes32 asset;\r\n        address poolAddress;\r\n    }\r\n\r\n    struct Asset {\r\n        bytes32 asset;\r\n        address assetAddress;\r\n        uint256 debtCoverage;\r\n    }\r\n\r\n    function activateToken ( address token ) external;\r\n    function addPoolAssets ( poolAsset[] memory poolAssets ) external;\r\n    function addTokenAssets ( Asset[] memory tokenAssets ) external;\r\n    function deactivateToken ( address token ) external;\r\n    function debtCoverage ( address ) external view returns ( uint256 );\r\n    function debtCoverageStaked ( bytes32 ) external view returns ( uint256 );\r\n    function getAllPoolAssets (  ) external view returns ( bytes32[] memory result );\r\n    function getAllTokenAssets (  ) external view returns ( bytes32[] memory result );\r\n    function getAssetAddress ( bytes32 _asset, bool allowInactive ) external view returns ( address );\r\n    function getPoolAddress ( bytes32 _asset ) external view returns ( address );\r\n    function getSupportedTokensAddresses (  ) external view returns ( address[] memory);\r\n    function initialize ( Asset[] memory tokenAssets, poolAsset[] memory poolAssets ) external;\r\n    function increaseProtocolExposure ( bytes32 assetIdentifier, uint256 exposureIncrease ) external;\r\n    function decreaseProtocolExposure(bytes32 assetIdentifier, uint256 exposureDecrease) external;\r\n    function isTokenAssetActive ( address token ) external view returns ( bool );\r\n    function owner (  ) external view returns ( address );\r\n    function removePoolAssets ( bytes32[] memory _poolAssets ) external;\r\n    function removeTokenAssets ( bytes32[] memory _tokenAssets ) external;\r\n    function renounceOwnership (  ) external;\r\n    function setDebtCoverage ( address token, uint256 coverage ) external;\r\n    function setDebtCoverageStaked ( bytes32 stakedAsset, uint256 coverage ) external;\r\n    function supportedTokensList ( uint256 ) external view returns ( address );\r\n    function tokenAddressToSymbol ( address ) external view returns ( bytes32 );\r\n    function tokenToStatus ( address ) external view returns ( uint256 );\r\n    function transferOwnership ( address newOwner ) external;\r\n}"
    },
    "contracts/lib/avalanche/DeploymentConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../interfaces/ITokenManager.sol\";\r\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\r\n\r\n/**\r\n * DeploymentConstants\r\n * These constants are updated during test and prod deployments using JS scripts. Defined as constants\r\n * to decrease gas costs. Not meant to be updated unless really necessary.\r\n * BE CAREFUL WHEN UPDATING. CONSTANTS CAN BE USED AMONG MANY FACETS.\r\n **/\r\nlibrary DeploymentConstants {\r\n\r\n    // Used for LiquidationBonus calculations\r\n    uint256 private constant _PERCENTAGE_PRECISION = 1000;\r\n\r\n    bytes32 private constant _NATIVE_TOKEN_SYMBOL = 'AVAX';\r\n\r\n    address private constant _NATIVE_ADDRESS = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\r\n\r\n    address private constant _DIAMOND_BEACON_ADDRESS = 0x2916B3bf7C35bd21e63D01C93C62FB0d4994e56D;\r\n\r\n    address private constant _SMART_LOANS_FACTORY_ADDRESS = 0x3Ea9D480295A73fd2aF95b4D96c2afF88b21B03D;\r\n\r\n    address private constant _TOKEN_MANAGER_ADDRESS = 0xF3978209B7cfF2b90100C6F87CEC77dE928Ed58e;\r\n\r\n    //implementation-specific\r\n\r\n    function getPercentagePrecision() internal pure returns (uint256) {\r\n        return _PERCENTAGE_PRECISION;\r\n    }\r\n\r\n    //blockchain-specific\r\n\r\n    function getNativeTokenSymbol() internal pure returns (bytes32 symbol) {\r\n        return _NATIVE_TOKEN_SYMBOL;\r\n    }\r\n\r\n    function getNativeToken() internal pure returns (address payable) {\r\n        return payable(_NATIVE_ADDRESS);\r\n    }\r\n\r\n    //deployment-specific\r\n\r\n    function getDiamondAddress() internal pure returns (address) {\r\n        return _DIAMOND_BEACON_ADDRESS;\r\n    }\r\n\r\n    function getSmartLoansFactoryAddress() internal pure returns (address) {\r\n        return _SMART_LOANS_FACTORY_ADDRESS;\r\n    }\r\n\r\n    function getTokenManager() internal pure returns (ITokenManager) {\r\n        return ITokenManager(_TOKEN_MANAGER_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * Returns all owned assets keys\r\n    **/\r\n    function getAllOwnedAssets() internal view returns (bytes32[] memory result) {\r\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\r\n        return sls.ownedAssets._inner._keys._inner._values;\r\n    }\r\n}"
    },
    "contracts/facets/SolvencyFacetProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@redstone-finance/evm-connector/contracts/data-services/AvalancheDataServiceConsumerBase.sol\";\r\nimport \"../interfaces/ITokenManager.sol\";\r\nimport \"../Pool.sol\";\r\nimport \"../DiamondHelper.sol\";\r\nimport \"../interfaces/IStakingPositions.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract SolvencyFacetProd is AvalancheDataServiceConsumerBase, DiamondHelper {\r\n    struct AssetPrice {\r\n        bytes32 asset;\r\n        uint256 price;\r\n    }\r\n\r\n    // Struct used in the liquidation process to obtain necessary prices only once\r\n    struct CachedPrices {\r\n        AssetPrice[] ownedAssetsPrices;\r\n        AssetPrice[] debtAssetsPrices;\r\n        AssetPrice[] stakedPositionsPrices;\r\n        AssetPrice[] assetsToRepayPrices;\r\n    }\r\n\r\n    /**\r\n      * Checks if the loan is solvent.\r\n      * It means that the Health Ratio is greater than 1e18.\r\n      * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function isSolvent() public view returns (bool) {\r\n        return getHealthRatio() >= 1e18;\r\n    }\r\n\r\n    /**\r\n      * Checks if the loan is solvent.\r\n      * It means that the Health Ratio is greater than 1e18.\r\n      * Uses provided AssetPrice struct arrays instead of extracting the pricing data from the calldata again.\r\n      * @param cachedPrices Struct containing arrays of Asset/Price structs used to calculate value of owned assets, debt and staked positions\r\n    **/\r\n    function isSolventWithPrices(CachedPrices memory cachedPrices) public view returns (bool) {\r\n        return getHealthRatioWithPrices(cachedPrices) >= 1e18;\r\n    }\r\n\r\n    /**\r\n      * Returns an array of Asset/Price structs of staked positions.\r\n      * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getStakedPositionsPrices() public view returns(AssetPrice[] memory result) {\r\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\r\n\r\n        bytes32[] memory symbols = new bytes32[](positions.length);\r\n        for(uint256 i=0; i<positions.length; i++) {\r\n            symbols[i] = positions[i].symbol;\r\n        }\r\n\r\n        uint256[] memory stakedPositionsPrices = getOracleNumericValuesWithDuplicatesFromTxMsg(symbols);\r\n        result = new AssetPrice[](stakedPositionsPrices.length);\r\n\r\n        for(uint i; i<stakedPositionsPrices.length; i++){\r\n            result[i] = AssetPrice({\r\n                asset: symbols[i],\r\n                price: stakedPositionsPrices[i]\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Returns an array of bytes32[] symbols of debt (borrowable) assets.\r\n    **/\r\n    function getDebtAssets() public view returns(bytes32[] memory result) {\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        result = tokenManager.getAllPoolAssets();\r\n    }\r\n\r\n    /**\r\n      * Returns an array of Asset/Price structs of debt (borrowable) assets.\r\n      * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getDebtAssetsPrices() public view returns(AssetPrice[] memory result) {\r\n        bytes32[] memory debtAssets = getDebtAssets();\r\n\r\n        uint256[] memory debtAssetsPrices = getOracleNumericValuesFromTxMsg(debtAssets);\r\n        result = new AssetPrice[](debtAssetsPrices.length);\r\n\r\n        for(uint i; i<debtAssetsPrices.length; i++){\r\n            result[i] = AssetPrice({\r\n                asset: debtAssets[i],\r\n                price: debtAssetsPrices[i]\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Returns an array of Asset/Price structs of enriched (always containing AVAX at index 0) owned assets.\r\n      * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getOwnedAssetsWithNativePrices() public view returns(AssetPrice[] memory result) {\r\n        bytes32[] memory assetsEnriched = getOwnedAssetsWithNative();\r\n        uint256[] memory prices = getOracleNumericValuesFromTxMsg(assetsEnriched);\r\n\r\n        result = new AssetPrice[](assetsEnriched.length);\r\n\r\n        for(uint i; i<assetsEnriched.length; i++){\r\n            result[i] = AssetPrice({\r\n                asset: assetsEnriched[i],\r\n                price: prices[i]\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Returns an array of bytes32[] symbols of staked positions.\r\n    **/\r\n    function getStakedAssets() internal view returns (bytes32[] memory result) {\r\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\r\n        result = new bytes32[](positions.length);\r\n        for(uint i; i<positions.length; i++) {\r\n            result[i] = positions[i].symbol;\r\n        }\r\n    }\r\n\r\n    function copyToArray(bytes32[] memory target, bytes32[] memory source, uint256 offset, uint256 numberOfItems) pure internal {\r\n        require(numberOfItems <= source.length, \"numberOfItems > target array length\");\r\n        require(offset + numberOfItems <= target.length, \"offset + numberOfItems > target array length\");\r\n\r\n        for(uint i; i<numberOfItems; i++){\r\n            target[i + offset] = source[i];\r\n        }\r\n    }\r\n\r\n    function copyToAssetPriceArray(AssetPrice[] memory target, bytes32[] memory sourceAssets, uint256[] memory sourcePrices, uint256 offset, uint256 numberOfItems) pure internal {\r\n        require(numberOfItems <= sourceAssets.length, \"numberOfItems > sourceAssets array length\");\r\n        require(numberOfItems <= sourcePrices.length, \"numberOfItems > sourcePrices array length\");\r\n        require(offset + numberOfItems <= sourceAssets.length, \"offset + numberOfItems > sourceAssets array length\");\r\n        require(offset + numberOfItems <= sourcePrices.length, \"offset + numberOfItems > sourcePrices array length\");\r\n\r\n        for(uint i; i<numberOfItems; i++){\r\n            target[i] = AssetPrice({\r\n                asset: sourceAssets[i+offset],\r\n                price: sourcePrices[i+offset]\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Returns CachedPrices struct consisting of Asset/Price arrays for ownedAssets, debtAssets, stakedPositions and assetsToRepay.\r\n      * Used during the liquidation process in order to obtain all necessary prices from calldata only once.\r\n      * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getAllPricesForLiquidation(bytes32[] memory assetsToRepay) public view returns (CachedPrices memory result) {\r\n        bytes32[] memory ownedAssetsEnriched = getOwnedAssetsWithNative();\r\n        bytes32[] memory debtAssets = getDebtAssets();\r\n        bytes32[] memory stakedAssets = getStakedAssets();\r\n\r\n        bytes32[] memory allAssetsSymbols = new bytes32[](ownedAssetsEnriched.length + debtAssets.length + stakedAssets.length + assetsToRepay.length);\r\n        uint256 offset;\r\n\r\n        // Populate allAssetsSymbols with owned assets symbols\r\n        copyToArray(allAssetsSymbols, ownedAssetsEnriched, offset, ownedAssetsEnriched.length);\r\n        offset += ownedAssetsEnriched.length;\r\n\r\n        // Populate allAssetsSymbols with debt assets symbols\r\n        copyToArray(allAssetsSymbols, debtAssets, offset, debtAssets.length);\r\n        offset += debtAssets.length;\r\n\r\n        // Populate allAssetsSymbols with staked assets symbols\r\n        copyToArray(allAssetsSymbols, stakedAssets, offset, stakedAssets.length);\r\n        offset += stakedAssets.length;\r\n\r\n        // Populate allAssetsSymbols with assets to repay symbols\r\n        copyToArray(allAssetsSymbols, assetsToRepay, offset, assetsToRepay.length);\r\n\r\n        uint256[] memory allAssetsPrices = getOracleNumericValuesWithDuplicatesFromTxMsg(allAssetsSymbols);\r\n\r\n        offset = 0;\r\n\r\n        // Populate ownedAssetsPrices struct\r\n        AssetPrice[] memory ownedAssetsPrices = new AssetPrice[](ownedAssetsEnriched.length);\r\n        copyToAssetPriceArray(ownedAssetsPrices, allAssetsSymbols, allAssetsPrices, offset, ownedAssetsEnriched.length);\r\n        offset += ownedAssetsEnriched.length;\r\n\r\n        // Populate debtAssetsPrices struct\r\n        AssetPrice[] memory debtAssetsPrices = new AssetPrice[](debtAssets.length);\r\n        copyToAssetPriceArray(debtAssetsPrices, allAssetsSymbols, allAssetsPrices, offset, debtAssets.length);\r\n        offset += debtAssetsPrices.length;\r\n\r\n        // Populate stakedPositionsPrices struct\r\n        AssetPrice[] memory stakedPositionsPrices = new AssetPrice[](stakedAssets.length);\r\n        copyToAssetPriceArray(stakedPositionsPrices, allAssetsSymbols, allAssetsPrices, offset, stakedAssets.length);\r\n        offset += stakedAssets.length;\r\n\r\n        // Populate assetsToRepayPrices struct\r\n        // Stack too deep :F\r\n        AssetPrice[] memory assetsToRepayPrices = new AssetPrice[](assetsToRepay.length);\r\n        for(uint i=0; i<assetsToRepay.length; i++){\r\n            assetsToRepayPrices[i] = AssetPrice({\r\n            asset: allAssetsSymbols[i+offset],\r\n            price: allAssetsPrices[i+offset]\r\n            });\r\n        }\r\n\r\n        result = CachedPrices({\r\n        ownedAssetsPrices: ownedAssetsPrices,\r\n        debtAssetsPrices: debtAssetsPrices,\r\n        stakedPositionsPrices: stakedPositionsPrices,\r\n        assetsToRepayPrices: assetsToRepayPrices\r\n        });\r\n    }\r\n\r\n    // Check whether there is enough debt-denominated tokens to fully repaid what was previously borrowed\r\n    function canRepayDebtFully() external view returns(bool) {\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        bytes32[] memory poolAssets = tokenManager.getAllPoolAssets();\r\n\r\n        for(uint i; i< poolAssets.length; i++) {\r\n            Pool pool = Pool(DeploymentConstants.getTokenManager().getPoolAddress(poolAssets[i]));\r\n            IERC20 token = IERC20(pool.tokenAddress());\r\n            if(token.balanceOf(address(this)) < pool.getBorrowed(address(this))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n      * Helper method exposing the redstone-evm-connector getOracleNumericValuesFromTxMsg() method.\r\n      * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getPrices(bytes32[] memory symbols) external view returns (uint256[] memory) {\r\n        return getOracleNumericValuesFromTxMsg(symbols);\r\n    }\r\n\r\n    /**\r\n      * Helper method exposing the redstone-evm-connector getOracleNumericValueFromTxMsg() method.\r\n      * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getPrice(bytes32 symbol) external view returns (uint256) {\r\n        return getOracleNumericValueFromTxMsg(symbol);\r\n    }\r\n\r\n    /**\r\n      * Returns TotalWeightedValue of OwnedAssets in USD based on the supplied array of Asset/Price struct, tokenBalance and debtCoverage\r\n    **/\r\n    function _getTWVOwnedAssets(AssetPrice[] memory ownedAssetsPrices) internal view returns (uint256) {\r\n        bytes32 nativeTokenSymbol = DeploymentConstants.getNativeTokenSymbol();\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n\r\n        uint256 weightedValueOfTokens = ownedAssetsPrices[0].price * address(this).balance * tokenManager.debtCoverage(tokenManager.getAssetAddress(nativeTokenSymbol, true)) / (10 ** 26);\r\n\r\n        if (ownedAssetsPrices.length > 0) {\r\n\r\n            for (uint256 i = 0; i < ownedAssetsPrices.length; i++) {\r\n                IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssetsPrices[i].asset, true));\r\n                weightedValueOfTokens = weightedValueOfTokens + (ownedAssetsPrices[i].price * token.balanceOf(address(this)) * tokenManager.debtCoverage(address(token)) / (10 ** token.decimals() * 1e8));\r\n            }\r\n        }\r\n        return weightedValueOfTokens;\r\n    }\r\n\r\n    /**\r\n      * Returns TotalWeightedValue of StakedPositions in USD based on the supplied array of Asset/Price struct, positionBalance and debtCoverage\r\n    **/\r\n    function _getTWVStakedPositions(AssetPrice[] memory stakedPositionsPrices) internal view returns (uint256) {\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\r\n\r\n        uint256 weightedValueOfStaked;\r\n\r\n        for (uint256 i; i < positions.length; i++) {\r\n            require(stakedPositionsPrices[i].asset == positions[i].symbol, \"Position-price symbol mismatch.\");\r\n\r\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\r\n\r\n            if (success) {\r\n                uint256 balance = abi.decode(result, (uint256));\r\n\r\n                IERC20Metadata token = IERC20Metadata(DeploymentConstants.getTokenManager().getAssetAddress(stakedPositionsPrices[i].asset, true));\r\n\r\n                weightedValueOfStaked += stakedPositionsPrices[i].price * balance * tokenManager.debtCoverageStaked(positions[i].identifier) / (10 ** token.decimals() * 10**8);\r\n            }\r\n\r\n\r\n        }\r\n        return weightedValueOfStaked;\r\n    }\r\n\r\n    function _getThresholdWeightedValueBase(AssetPrice[] memory ownedAssetsPrices, AssetPrice[] memory stakedPositionsPrices) internal view virtual returns (uint256) {\r\n        return _getTWVOwnedAssets(ownedAssetsPrices) + _getTWVStakedPositions(stakedPositionsPrices);\r\n    }\r\n\r\n    /**\r\n      * Returns the threshold weighted value of assets in USD including all tokens as well as staking and LP positions\r\n      * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getThresholdWeightedValue() public view virtual returns (uint256) {\r\n        AssetPrice[] memory ownedAssetsPrices = getOwnedAssetsWithNativePrices();\r\n        AssetPrice[] memory stakedPositionsPrices = getStakedPositionsPrices();\r\n        return _getThresholdWeightedValueBase(ownedAssetsPrices, stakedPositionsPrices);\r\n    }\r\n\r\n    /**\r\n      * Returns the threshold weighted value of assets in USD including all tokens as well as staking and LP positions\r\n      * Uses provided AssetPrice struct arrays instead of extracting the pricing data from the calldata again.\r\n    **/\r\n    function getThresholdWeightedValueWithPrices(AssetPrice[] memory ownedAssetsPrices, AssetPrice[] memory stakedPositionsPrices) public view virtual returns (uint256) {\r\n        return _getThresholdWeightedValueBase(ownedAssetsPrices, stakedPositionsPrices);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the current debt denominated in USD\r\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\r\n    **/\r\n    function getDebtBase(AssetPrice[] memory debtAssetsPrices) internal view returns (uint256){\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        uint256 debt;\r\n\r\n        for (uint256 i; i < debtAssetsPrices.length; i++) {\r\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(debtAssetsPrices[i].asset, true));\r\n\r\n            Pool pool = Pool(tokenManager.getPoolAddress(debtAssetsPrices[i].asset));\r\n            //10**18 (wei in eth) / 10**8 (precision of oracle feed) = 10**10\r\n            debt = debt + pool.getBorrowed(address(this)) * debtAssetsPrices[i].price * 10 ** 10\r\n            / 10 ** token.decimals();\r\n        }\r\n\r\n        return debt;\r\n    }\r\n\r\n    /**\r\n     * Returns the current debt denominated in USD\r\n     * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getDebt() public view virtual returns (uint256) {\r\n        AssetPrice[] memory debtAssetsPrices = getDebtAssetsPrices();\r\n        return getDebtBase(debtAssetsPrices);\r\n    }\r\n\r\n    /**\r\n     * Returns the current debt denominated in USD\r\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\r\n    **/\r\n    function getDebtWithPrices(AssetPrice[] memory debtAssetsPrices) public view virtual returns (uint256) {\r\n        return getDebtBase(debtAssetsPrices);\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\r\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\r\n    **/\r\n    function _getTotalAssetsValueBase(AssetPrice[] memory ownedAssetsPrices) public view returns (uint256) {\r\n        if (ownedAssetsPrices.length > 0) {\r\n            ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n\r\n            uint256 total = address(this).balance * ownedAssetsPrices[0].price / 10 ** 8;\r\n\r\n            for (uint256 i = 0; i < ownedAssetsPrices.length; i++) {\r\n                IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssetsPrices[i].asset, true));\r\n                uint256 assetBalance = token.balanceOf(address(this));\r\n\r\n                total = total + (ownedAssetsPrices[i].price * 10 ** 10 * assetBalance / (10 ** token.decimals()));\r\n            }\r\n            return total;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\r\n     * @dev This function uses the redstone-evm-connector\r\n     **/\r\n    function getTotalAssetsValue() public view virtual returns (uint256) {\r\n        AssetPrice[] memory ownedAssetsPrices = getOwnedAssetsWithNativePrices();\r\n        return _getTotalAssetsValueBase(ownedAssetsPrices);\r\n    }\r\n\r\n    /**\r\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\r\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\r\n    **/\r\n    function getTotalAssetsValueWithPrices(AssetPrice[] memory ownedAssetsPrices) public view virtual returns (uint256) {\r\n        return _getTotalAssetsValueBase(ownedAssetsPrices);\r\n    }\r\n\r\n    /**\r\n      * Returns list of owned assets that always included NativeToken at index 0\r\n    **/\r\n    function getOwnedAssetsWithNative() public view returns(bytes32[] memory){\r\n        bytes32[] memory ownedAssets = DeploymentConstants.getAllOwnedAssets();\r\n        bytes32 nativeTokenSymbol = DeploymentConstants.getNativeTokenSymbol();\r\n\r\n        // If account already owns the native token the use ownedAssets.length; Otherwise add one element to account for additional native token.\r\n        uint256 numberOfAssets = DiamondStorageLib.hasAsset(nativeTokenSymbol) ? ownedAssets.length : ownedAssets.length + 1;\r\n        bytes32[] memory assetsWithNative = new bytes32[](numberOfAssets);\r\n\r\n        uint256 lastUsedIndex;\r\n        assetsWithNative[0] = nativeTokenSymbol; // First asset = NativeToken\r\n\r\n        for(uint i=0; i< ownedAssets.length; i++){\r\n            if(ownedAssets[i] != nativeTokenSymbol){\r\n                lastUsedIndex += 1;\r\n                assetsWithNative[lastUsedIndex] = ownedAssets[i];\r\n            }\r\n        }\r\n        return assetsWithNative;\r\n    }\r\n\r\n    /**\r\n     * Returns the current value of staked positions in USD.\r\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\r\n    **/\r\n    function _getStakedValueBase(AssetPrice[] memory stakedPositionsPrices) internal view returns (uint256) {\r\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\r\n\r\n        uint256 usdValue;\r\n\r\n        for (uint256 i; i < positions.length; i++) {\r\n            require(stakedPositionsPrices[i].asset == positions[i].symbol, \"Position-price symbol mismatch.\");\r\n\r\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\r\n\r\n            if (success) {\r\n                uint256 balance = abi.decode(result, (uint256));\r\n                IERC20Metadata token = IERC20Metadata(DeploymentConstants.getTokenManager().getAssetAddress(stakedPositionsPrices[i].asset, true));\r\n                usdValue += stakedPositionsPrices[i].price * 10 ** 10 * balance / (10 ** token.decimals());\r\n            }\r\n        }\r\n\r\n        return usdValue;\r\n    }\r\n\r\n    /**\r\n     * Returns the current value of staked positions in USD.\r\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\r\n    **/\r\n    function getStakedValueWithPrices(AssetPrice[] memory stakedPositionsPrices) public view returns (uint256) {\r\n        return _getStakedValueBase(stakedPositionsPrices);\r\n    }\r\n\r\n    /**\r\n     * Returns the current value of staked positions in USD.\r\n     * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getStakedValue() public view virtual returns (uint256) {\r\n        AssetPrice[] memory stakedPositionsPrices = getStakedPositionsPrices();\r\n        return _getStakedValueBase(stakedPositionsPrices);\r\n    }\r\n\r\n    /**\r\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\r\n     * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function getTotalValue() public view virtual returns (uint256) {\r\n        return getTotalAssetsValue() + getStakedValue();\r\n    }\r\n\r\n    /**\r\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\r\n     * Uses provided AssetPrice struct arrays instead of extracting the pricing data from the calldata again.\r\n    **/\r\n    function getTotalValueWithPrices(AssetPrice[] memory ownedAssetsPrices, AssetPrice[] memory stakedPositionsPrices) public view virtual returns (uint256) {\r\n        return getTotalAssetsValueWithPrices(ownedAssetsPrices) + getStakedValueWithPrices(stakedPositionsPrices);\r\n    }\r\n\r\n    function getFullLoanStatus() public view returns (uint256[5] memory) {\r\n        return [getTotalValue(), getDebt(), getThresholdWeightedValue(), getHealthRatio(), isSolvent() ? uint256(1) : uint256(0)];\r\n    }\r\n\r\n    /**\r\n     * Returns current health ratio (solvency) associated with the loan, defined as threshold weighted value of divided\r\n     * by current debt\r\n     * @dev This function uses the redstone-evm-connector\r\n     **/\r\n    function getHealthRatio() public view virtual returns (uint256) {\r\n        CachedPrices memory cachedPrices = getAllPricesForLiquidation(new bytes32[](0));\r\n        uint256 debt = getDebtWithPrices(cachedPrices.debtAssetsPrices);\r\n        uint256 thresholdWeightedValue = getThresholdWeightedValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices);\r\n\r\n        if (debt == 0) {\r\n            return type(uint256).max;\r\n        } else {\r\n            return thresholdWeightedValue * 1e18 / debt;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns current health ratio (solvency) associated with the loan, defined as threshold weighted value of divided\r\n     * by current debt\r\n     * Uses provided AssetPrice struct arrays instead of extracting the pricing data from the calldata again.\r\n     **/\r\n    function getHealthRatioWithPrices(CachedPrices memory cachedPrices) public view virtual returns (uint256) {\r\n        uint256 debt = getDebtWithPrices(cachedPrices.debtAssetsPrices);\r\n        uint256 thresholdWeightedValue = getThresholdWeightedValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices);\r\n\r\n        if (debt == 0) {\r\n            return type(uint256).max;\r\n        } else {\r\n            return thresholdWeightedValue * 1e18 / debt;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/SmartLoanDiamondBeacon.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport {DiamondStorageLib} from \"./lib/DiamondStorageLib.sol\";\r\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\r\n\r\n/**\r\n * @title SmartLoanDiamondBeacon\r\n * A contract that is authorised to borrow funds using delegated credit.\r\n * It maintains solvency calculating the current value of assets and borrowings.\r\n * In case the value of assets held drops below certain level, part of the funds may be forcibly repaid.\r\n * It permits only a limited and safe token transfer.\r\n *\r\n */\r\n\r\ncontract SmartLoanDiamondBeacon {\r\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\r\n        DiamondStorageLib.setContractOwner(_contractOwner);\r\n        DiamondStorageLib.setContractPauseAdmin(_contractOwner);\r\n\r\n        // Add the diamondCut external function from the diamondCutFacet\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\r\n        bytes4[] memory functionSelectors = new bytes4[](3);\r\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\r\n        functionSelectors[1] = IDiamondCut.pause.selector;\r\n        functionSelectors[2] = IDiamondCut.unpause.selector;\r\n        cut[0] = IDiamondCut.FacetCut({\r\n        facetAddress : _diamondCutFacet,\r\n        action : IDiamondCut.FacetCutAction.Add,\r\n        functionSelectors : functionSelectors\r\n        });\r\n        DiamondStorageLib.diamondCut(cut, address(0), \"\");\r\n\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        // diamondCut(); unpause()\r\n        ds.canBeExecutedWhenPaused[0x1f931c1c] = true;\r\n        ds.canBeExecutedWhenPaused[0x3f4ba83a] = true;\r\n    }\r\n\r\n    function implementation() public view returns (address) {\r\n        return address(this);\r\n    }\r\n\r\n    function canBeExecutedWhenPaused(bytes4 methodSig) external view returns (bool) {\r\n        return DiamondStorageLib.getPausedMethodExemption(methodSig);\r\n    }\r\n\r\n    function setPausedMethodExemptions(bytes4[] memory methodSigs, bool[] memory values) public {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n\r\n        for(uint i; i<methodSigs.length; i++){\r\n            require(!(methodSigs[i] == 0x3f4ba83a && values[i] == false), \"The unpause() method must be available during the paused state.\");\r\n            ds.canBeExecutedWhenPaused[methodSigs[i]] = values[i];\r\n        }\r\n    }\r\n\r\n    function getStatus() public view returns(bool) {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        return ds._active;\r\n    }\r\n\r\n    function implementation(bytes4 funcSignature) public view notPausedOrUpgrading(funcSignature) returns (address) {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        // get facet from function selector\r\n        address facet = ds.selectorToFacetAndPosition[funcSignature].facetAddress;\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        // Execute external function from facet using delegatecall and return any value.\r\n        return facet;\r\n    }\r\n\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        address facet = implementation(msg.sig);\r\n        // Execute external function from facet using delegatecall and return any value.\r\n        assembly {\r\n        // copy function selector and any arguments\r\n            calldatacopy(0, 0, calldatasize())\r\n        // execute function call using the facet\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n        // get any return value\r\n            returndatacopy(0, 0, returndatasize())\r\n        // return any return value or error back to the caller\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return (0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    function proposeBeaconOwnershipTransfer(address _newOwner) external {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        require(_newOwner != msg.sender, \"Can't propose oneself as a contract owner\");\r\n        DiamondStorageLib.setProposedOwner(_newOwner);\r\n\r\n        emit OwnershipProposalCreated(msg.sender, _newOwner);\r\n    }\r\n\r\n    function proposeBeaconPauseAdminOwnershipTransfer(address _newPauseAdmin) external {\r\n        DiamondStorageLib.enforceIsPauseAdmin();\r\n        require(_newPauseAdmin != msg.sender, \"Can't propose oneself as a contract pauseAdmin\");\r\n        DiamondStorageLib.setProposedPauseAdmin(_newPauseAdmin);\r\n\r\n        emit PauseAdminOwnershipProposalCreated(msg.sender, _newPauseAdmin);\r\n    }\r\n\r\n    function acceptBeaconOwnership() external {\r\n        require(DiamondStorageLib.proposedOwner() == msg.sender, \"Only a proposed user can accept ownership\");\r\n        DiamondStorageLib.setContractOwner(msg.sender);\r\n        DiamondStorageLib.setProposedOwner(address(0));\r\n\r\n        emit OwnershipProposalAccepted(msg.sender);\r\n    }\r\n\r\n    function acceptBeaconPauseAdminOwnership() external {\r\n        require(DiamondStorageLib.proposedPauseAdmin() == msg.sender, \"Only a proposed user can accept ownership\");\r\n        DiamondStorageLib.setContractPauseAdmin(msg.sender);\r\n        DiamondStorageLib.setProposedPauseAdmin(address(0));\r\n\r\n        emit PauseAdminOwnershipProposalAccepted(msg.sender);\r\n    }\r\n\r\n    modifier notPausedOrUpgrading(bytes4 funcSignature) {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        if(!ds._active){\r\n            if(!ds.canBeExecutedWhenPaused[funcSignature]){\r\n                revert(\"ProtocolUpgrade: paused.\");\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after creating a pauseAdmin transfer proposal by the pauseAdmin\r\n     * @param pauseAdmin address of the current pauseAdmin\r\n     * @param proposed address of the proposed pauseAdmin\r\n     **/\r\n    event PauseAdminOwnershipProposalCreated(address indexed pauseAdmin, address indexed proposed);\r\n\r\n    /**\r\n     * @dev emitted after accepting a pauseAdmin transfer proposal by the new pauseAdmin\r\n     * @param newPauseAdmin address of the new pauseAdmin\r\n     **/\r\n    event PauseAdminOwnershipProposalAccepted(address indexed newPauseAdmin);\r\n\r\n    /**\r\n     * @dev emitted after creating a ownership transfer proposal by the owner\r\n     * @param owner address of the current owner\r\n     * @param proposed address of the proposed owner\r\n     **/\r\n    event OwnershipProposalCreated(address indexed owner, address indexed proposed);\r\n\r\n    /**\r\n     * @dev emitted after accepting a ownership transfer proposal by the new owner\r\n     * @param newOwner address of the new owner\r\n     **/\r\n    event OwnershipProposalAccepted(address indexed newOwner);\r\n}"
    },
    "contracts/lib/DiamondStorageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\r\nimport \"../lib/Bytes32EnumerableMap.sol\";\r\nimport \"../interfaces/IStakingPositions.sol\";\r\n\r\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\r\n// The loupe functions are required by the EIP2535 Diamonds standard\r\n\r\nlibrary DiamondStorageLib {\r\n    using EnumerableMap for EnumerableMap.Bytes32ToAddressMap;\r\n\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n    bytes32 constant LIQUIDATION_STORAGE_POSITION = keccak256(\"diamond.standard.liquidation.storage\");\r\n    bytes32 constant SMARTLOAN_STORAGE_POSITION = keccak256(\"diamond.standard.smartloan.storage\");\r\n    bytes32 constant REENTRANCY_GUARD_STORAGE_POSITION = keccak256(\"diamond.standard.reentrancy.guard.storage\");\r\n\r\n    struct FacetAddressAndPosition {\r\n        address facetAddress;\r\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\r\n    }\r\n\r\n    struct FacetFunctionSelectors {\r\n        bytes4[] functionSelectors;\r\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\r\n    }\r\n\r\n    struct DiamondStorage {\r\n        // ----------- DIAMOND-SPECIFIC VARIABLES --------------\r\n        // maps function selector to the facet address and\r\n        // the position of the selector in the facetFunctionSelectors.selectors array\r\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\r\n        // maps facet addresses to function selectors\r\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\r\n        // facet addresses\r\n        address[] facetAddresses;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // Used to select methods that can be executed even when Diamond is paused\r\n        mapping(bytes4 => bool) canBeExecutedWhenPaused;\r\n\r\n        bool _initialized;\r\n        bool _active;\r\n\r\n        uint256 _lastBorrowTimestamp;\r\n    }\r\n\r\n    struct SmartLoanStorage {\r\n        // PauseAdmin has the power to pause/unpause the contract without the timelock delay in case of a critical bug/exploit\r\n        address pauseAdmin;\r\n        // Owner of the contract\r\n        address contractOwner;\r\n        // Proposed owner of the contract\r\n        address proposedOwner;\r\n        // Proposed pauseAdmin of the contract\r\n        address proposedPauseAdmin;\r\n        // Is contract initialized?\r\n        bool _initialized;\r\n        // TODO: mock staking tokens until redstone oracle supports them\r\n        EnumerableMap.Bytes32ToAddressMap ownedAssets;\r\n        // Staked positions of the contract\r\n        IStakingPositions.StakedPosition[] currentStakedPositions;\r\n    }\r\n\r\n    struct LiquidationStorage {\r\n        // Mapping controlling addresses that can execute the liquidation methods\r\n        mapping(address=>bool) canLiquidate;\r\n    }\r\n\r\n    struct ReentrancyGuardStorage {\r\n        uint256 _status;\r\n    }\r\n\r\n    function reentrancyGuardStorage() internal pure returns (ReentrancyGuardStorage storage rgs) {\r\n        bytes32 position = REENTRANCY_GUARD_STORAGE_POSITION;\r\n        assembly {\r\n            rgs.slot := position\r\n        }\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    function liquidationStorage() internal pure returns (LiquidationStorage storage ls) {\r\n        bytes32 position = LIQUIDATION_STORAGE_POSITION;\r\n        assembly {\r\n            ls.slot := position\r\n        }\r\n    }\r\n\r\n    function smartLoanStorage() internal pure returns (SmartLoanStorage storage sls) {\r\n        bytes32 position = SMARTLOAN_STORAGE_POSITION;\r\n        assembly {\r\n            sls.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event PauseAdminOwnershipTransferred(address indexed previousPauseAdmin, address indexed newPauseAdmin);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        SmartLoanStorage storage sls = smartLoanStorage();\r\n        address previousOwner = sls.contractOwner;\r\n        sls.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function setContractPauseAdmin(address _newPauseAdmin) internal {\r\n        SmartLoanStorage storage sls = smartLoanStorage();\r\n        address previousPauseAdmin = sls.pauseAdmin;\r\n        sls.pauseAdmin = _newPauseAdmin;\r\n        emit PauseAdminOwnershipTransferred(previousPauseAdmin, _newPauseAdmin);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = smartLoanStorage().contractOwner;\r\n    }\r\n\r\n    function pauseAdmin() internal view returns (address pauseAdmin) {\r\n        pauseAdmin = smartLoanStorage().pauseAdmin;\r\n    }\r\n\r\n    function setProposedOwner(address _newOwner) internal {\r\n        SmartLoanStorage storage sls = smartLoanStorage();\r\n        sls.proposedOwner = _newOwner;\r\n    }\r\n\r\n    function setProposedPauseAdmin(address _newPauseAdmin) internal {\r\n        SmartLoanStorage storage sls = smartLoanStorage();\r\n        sls.proposedPauseAdmin = _newPauseAdmin;\r\n    }\r\n\r\n    function getPausedMethodExemption(bytes4 _methodSig) internal view returns (bool) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        return ds.canBeExecutedWhenPaused[_methodSig];\r\n    }\r\n\r\n    function proposedOwner() internal view returns (address proposedOwner_) {\r\n        proposedOwner_ = smartLoanStorage().proposedOwner;\r\n    }\r\n\r\n    function proposedPauseAdmin() internal view returns (address proposedPauseAdmin) {\r\n        proposedPauseAdmin = smartLoanStorage().proposedPauseAdmin;\r\n    }\r\n\r\n    function stakedPositions() internal view returns (IStakingPositions.StakedPosition[] storage _positions) {\r\n        _positions = smartLoanStorage().currentStakedPositions;\r\n    }\r\n\r\n    function addStakedPosition(IStakingPositions.StakedPosition memory position) internal {\r\n        IStakingPositions.StakedPosition[] storage positions = stakedPositions();\r\n\r\n        bool found;\r\n\r\n        for (uint256 i; i < positions.length; i++) {\r\n            if (positions[i].identifier == position.identifier) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (!found) {\r\n            positions.push(position);\r\n        }\r\n    }\r\n\r\n    function removeStakedPosition(bytes32 identifier) internal {\r\n        IStakingPositions.StakedPosition[] storage positions = stakedPositions();\r\n\r\n        for (uint256 i; i < positions.length; i++) {\r\n            if (positions[i].identifier == identifier) {\r\n                positions[i] = positions[positions.length - 1];\r\n                positions.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    function addOwnedAsset(bytes32 _symbol, address _address) internal {\r\n        require(_symbol != \"\", \"Symbol cannot be empty\");\r\n        require(_address != address(0), \"Invalid AddressZero\");\r\n        SmartLoanStorage storage sls = smartLoanStorage();\r\n        EnumerableMap.set(sls.ownedAssets, _symbol, _address);\r\n    }\r\n\r\n    function hasAsset(bytes32 _symbol) internal view returns (bool){\r\n        SmartLoanStorage storage sls = smartLoanStorage();\r\n        return sls.ownedAssets.contains(_symbol);\r\n    }\r\n\r\n    function removeOwnedAsset(bytes32 _symbol) internal {\r\n        SmartLoanStorage storage sls = smartLoanStorage();\r\n        EnumerableMap.remove(sls.ownedAssets, _symbol);\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(msg.sender == smartLoanStorage().contractOwner, \"DiamondStorageLib: Must be contract owner\");\r\n    }\r\n\r\n    function enforceIsPauseAdmin() internal view {\r\n        require(msg.sender == smartLoanStorage().pauseAdmin, \"DiamondStorageLib: Must be contract pauseAdmin\");\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    // Internal function version of diamondCut\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\r\n            if (action == IDiamondCut.FacetCutAction.Add) {\r\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\r\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\r\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else {\r\n                revert(\"DiamondStorageLibCut: Incorrect FacetCutAction\");\r\n            }\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"DiamondStorageLibCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_facetAddress != address(0), \"DiamondStorageLibCut: Add facet can't be address(0)\");\r\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            addFacet(ds, _facetAddress);\r\n        }\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            require(oldFacetAddress == address(0), \"DiamondStorageLibCut: Can't add function that already exists\");\r\n            addFunction(ds, selector, selectorPosition, _facetAddress);\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"DiamondStorageLibCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_facetAddress != address(0), \"DiamondStorageLibCut: Add facet can't be address(0)\");\r\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            addFacet(ds, _facetAddress);\r\n        }\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            require(oldFacetAddress != _facetAddress, \"DiamondStorageLibCut: Can't replace function with same function\");\r\n            removeFunction(ds, oldFacetAddress, selector);\r\n            addFunction(ds, selector, selectorPosition, _facetAddress);\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"DiamondStorageLibCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        // if function does not exist then do nothing and return\r\n        require(_facetAddress == address(0), \"DiamondStorageLibCut: Remove facet address must be address(0)\");\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            removeFunction(ds, oldFacetAddress, selector);\r\n        }\r\n    }\r\n\r\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\r\n        enforceHasContractCode(_facetAddress, \"DiamondStorageLibCut: New facet has no code\");\r\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\r\n        ds.facetAddresses.push(_facetAddress);\r\n    }\r\n\r\n\r\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\r\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\r\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\r\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\r\n    }\r\n\r\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\r\n        require(_facetAddress != address(0), \"DiamondStorageLibCut: Can't remove function that doesn't exist\");\r\n        // an immutable function is a function defined directly in a diamond\r\n        require(_facetAddress != address(this), \"DiamondStorageLibCut: Can't remove immutable function\");\r\n        // replace selector with last selector, then delete last selector\r\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\r\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\r\n        // if not the same then replace _selector with lastSelector\r\n        if (selectorPosition != lastSelectorPosition) {\r\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\r\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\r\n        }\r\n        // delete the last selector\r\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\r\n        delete ds.selectorToFacetAndPosition[_selector];\r\n\r\n        // if no more selectors for facet address then delete the facet address\r\n        if (lastSelectorPosition == 0) {\r\n            // replace facet address with last facet address and delete last facet address\r\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\r\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\r\n            if (facetAddressPosition != lastFacetAddressPosition) {\r\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\r\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\r\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\r\n            }\r\n            ds.facetAddresses.pop();\r\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\r\n        }\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"DiamondStorageLibCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"DiamondStorageLibCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"DiamondStorageLibCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"DiamondStorageLibCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    function pause() external;\r\n\r\n    function unpause() external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}"
    },
    "contracts/lib/Bytes32EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\n//It's Open Zeppelin EnumerableMap library modified to accept bytes32 type as a key\r\n\r\n/**\r\n * @dev Library for managing an enumerable variant of Solidity's\r\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\r\n * type.\r\n *\r\n * Maps have the following properties:\r\n *\r\n * - Entries are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n */\r\nlibrary EnumerableMap {\r\n    using EnumerableSet for EnumerableSet.Bytes32Set;\r\n\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Map type with\r\n    // bytes32 keys and values.\r\n    // The Map implementation uses private functions, and user-facing\r\n    // implementations (such as Bytes32ToAddressMap) are just wrappers around\r\n    // the underlying Map.\r\n    // This means that we can only create new EnumerableMaps for types that fit\r\n    // in bytes32.\r\n\r\n    struct Map {\r\n        // Storage of keys\r\n        EnumerableSet.Bytes32Set _keys;\r\n        mapping(bytes32 => bytes32) _values;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function _set(\r\n        Map storage map,\r\n        bytes32 key,\r\n        bytes32 value\r\n    ) private returns (bool) {\r\n        map._values[key] = value;\r\n        return map._keys.add(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a key-value pair from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\r\n        delete map._values[key];\r\n        return map._keys.remove(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\r\n        return map._keys.contains(key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of key-value pairs in the map. O(1).\r\n     */\r\n    function _length(Map storage map) private view returns (uint256) {\r\n        return map._keys.length();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of entries inside the\r\n     * array, and it may change when more entries are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\r\n        bytes32 key = map._keys.at(index);\r\n        return (key, map._values[key]);\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`.  O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\r\n        bytes32 value = map._values[key];\r\n        if (value == bytes32(0)) {\r\n            return (_contains(map, key), bytes32(0));\r\n        } else {\r\n            return (true, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`.  O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\r\n        bytes32 value = map._values[key];\r\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\r\n     */\r\n    function _get(\r\n        Map storage map,\r\n        bytes32 key,\r\n        string memory errorMessage\r\n    ) private view returns (bytes32) {\r\n        bytes32 value = map._values[key];\r\n        require(value != 0 || _contains(map, key), errorMessage);\r\n        return value;\r\n    }\r\n\r\n    // Bytes32ToAddressMap\r\n\r\n    struct Bytes32ToAddressMap {\r\n        Map _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(\r\n        Bytes32ToAddressMap storage map,\r\n        bytes32 key,\r\n        address value\r\n    ) internal returns (bool) {\r\n        return _set(map._inner, key, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\r\n        return _remove(map._inner, key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {\r\n        return _contains(map._inner, key);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n    function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {\r\n        return _length(map._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32ToAddressMap storage map, uint256 index) internal view returns (bytes32, address) {\r\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\r\n        return (key, address(uint160(uint256(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Tries to returns the value associated with `key`.  O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryGet(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool, address) {\r\n        (bool success, bytes32 value) = _tryGet(map._inner, key);\r\n        return (success, address(uint160(uint256(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`.  O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (address) {\r\n        return address(uint160(uint256(_get(map._inner, key))));\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n    function get(\r\n        Bytes32ToAddressMap storage map,\r\n        bytes32 key,\r\n        string memory errorMessage\r\n    ) internal view returns (address) {\r\n        return address(uint160(uint256(_get(map._inner, key, errorMessage))));\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IStakingPositions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IStakingPositions\r\n * Types for staking\r\n */\r\ninterface IStakingPositions {\r\n    struct StakedPosition {\r\n        // Asset is either the token (symbol) address being staked or the address of the PTP LP token in case where a pool for that token (symbol) already exists within the VectorFinance\r\n        address asset;\r\n        bytes32 symbol;\r\n        bytes32 identifier;\r\n        bytes4 balanceSelector;\r\n        bytes4 unstakeSelector;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConstants.sol\";\nimport \"./CalldataExtractor.sol\";\n\n/**\n * @title The base contract for forwarding redstone payload to other contracts\n * @author The Redstone Oracles team\n */\ncontract ProxyConnector is RedstoneConstants, CalldataExtractor {\n  error ProxyCalldataFailedWithoutErrMsg();\n  error ProxyCalldataFailedWithStringMessage(string message);\n  error ProxyCalldataFailedWithCustomError(bytes result);\n\n  function proxyCalldata(\n    address contractAddress,\n    bytes memory encodedFunction,\n    bool forwardValue\n  ) internal returns (bytes memory) {\n    bytes memory message = _prepareMessage(encodedFunction);\n\n    (bool success, bytes memory result) =\n      contractAddress.call{value: forwardValue ? msg.value : 0}(message);\n\n    return _prepareReturnValue(success, result);\n  }\n\n  function proxyDelegateCalldata(address contractAddress, bytes memory encodedFunction)\n    internal\n    returns (bytes memory)\n  {\n    bytes memory message = _prepareMessage(encodedFunction);\n    (bool success, bytes memory result) = contractAddress.delegatecall(message);\n    return _prepareReturnValue(success, result);\n  }\n\n  function proxyCalldataView(address contractAddress, bytes memory encodedFunction)\n    internal\n    view\n    returns (bytes memory)\n  {\n    bytes memory message = _prepareMessage(encodedFunction);\n    (bool success, bytes memory result) = contractAddress.staticcall(message);\n    return _prepareReturnValue(success, result);\n  }\n\n  function _prepareMessage(bytes memory encodedFunction) private pure returns (bytes memory) {\n    uint256 encodedFunctionBytesCount = encodedFunction.length;\n    uint256 redstonePayloadByteSize = _getRedstonePayloadByteSize();\n    uint256 resultMessageByteSize = encodedFunctionBytesCount + redstonePayloadByteSize;\n\n    if (redstonePayloadByteSize > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n\n    bytes memory message;\n\n    assembly {\n      message := mload(FREE_MEMORY_PTR) // sets message pointer to first free place in memory\n\n      // Saving the byte size of the result message (it's a standard in EVM)\n      mstore(message, resultMessageByteSize)\n\n      // Copying function and its arguments\n      for {\n        let from := add(BYTES_ARR_LEN_VAR_BS, encodedFunction)\n        let fromEnd := add(from, encodedFunctionBytesCount)\n        let to := add(BYTES_ARR_LEN_VAR_BS, message)\n      } lt (from, fromEnd) {\n        from := add(from, STANDARD_SLOT_BS)\n        to := add(to, STANDARD_SLOT_BS)\n      } {\n        // Copying data from encodedFunction to message (32 bytes at a time)\n        mstore(to, mload(from))\n      }\n\n      // Copying redstone payload to the message bytes\n      calldatacopy(\n        add(message, add(BYTES_ARR_LEN_VAR_BS, encodedFunctionBytesCount)), // address\n        sub(calldatasize(), redstonePayloadByteSize), // offset\n        redstonePayloadByteSize // bytes length to copy\n      )\n\n      // Updating free memory pointer\n      mstore(\n        FREE_MEMORY_PTR,\n        add(\n          add(message, add(redstonePayloadByteSize, encodedFunctionBytesCount)),\n          BYTES_ARR_LEN_VAR_BS\n        )\n      )\n    }\n\n    return message;\n  }\n\n  function _getRedstonePayloadByteSize() private pure returns (uint256) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n\n    return calldataNegativeOffset;\n  }\n\n  function _getDataPackageByteSize(uint256 calldataNegativeOffset) private pure returns (uint256) {\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    return\n      dataPointsCount *\n      (DATA_POINT_SYMBOL_BS + eachDataPointValueByteSize) +\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n  }\n\n\n  function _prepareReturnValue(bool success, bytes memory result)\n    internal\n    pure\n    returns (bytes memory)\n  {\n    if (!success) {\n\n      if (result.length == 0) {\n        revert ProxyCalldataFailedWithoutErrMsg();\n      } else {\n        bool isStringErrorMessage;\n        assembly {\n          let first32BytesOfResult := mload(add(result, BYTES_ARR_LEN_VAR_BS))\n          isStringErrorMessage := eq(first32BytesOfResult, STRING_ERR_MESSAGE_MASK)\n        }\n\n        if (isStringErrorMessage) {\n          string memory receivedErrMsg;\n          assembly {\n            receivedErrMsg := add(result, REVERT_MSG_OFFSET)\n          }\n          revert ProxyCalldataFailedWithStringMessage(receivedErrMsg);\n        } else {\n          revert ProxyCalldataFailedWithCustomError(result);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n"
    },
    "contracts/facets/AssetsExposureController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"../interfaces/ITokenManager.sol\";\r\nimport \"../interfaces/IStakingPositions.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract AssetsExposureController {\r\n\r\n    function resetPrimeAccountAssetsExposure() external {\r\n        bytes32[] memory ownedAssets = DeploymentConstants.getAllOwnedAssets();\r\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n\r\n        for(uint i=0; i<ownedAssets.length; i++){\r\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssets[i], true));\r\n            tokenManager.decreaseProtocolExposure(ownedAssets[i], token.balanceOf(address(this)) * 1e18 / 10**token.decimals());\r\n        }\r\n        for(uint i=0; i<positions.length; i++){\r\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\r\n            if (success) {\r\n                uint256 balance = abi.decode(result, (uint256));\r\n                uint256 decimals = IERC20Metadata(tokenManager.getAssetAddress(positions[i].symbol, true)).decimals();\r\n                tokenManager.decreaseProtocolExposure(positions[i].identifier, balance * 1e18 / 10**decimals);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setPrimeAccountAssetsExposure() external {\r\n        bytes32[] memory ownedAssets = DeploymentConstants.getAllOwnedAssets();\r\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n\r\n        for(uint i=0; i<ownedAssets.length; i++){\r\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssets[i], true));\r\n            tokenManager.increaseProtocolExposure(ownedAssets[i], token.balanceOf(address(this)) * 1e18 / 10**token.decimals());\r\n        }\r\n        for(uint i=0; i<positions.length; i++){\r\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\r\n            if (success) {\r\n                uint256 balance = abi.decode(result, (uint256));\r\n                uint256 decimals = IERC20Metadata(tokenManager.getAssetAddress(positions[i].symbol, true)).decimals();\r\n                tokenManager.increaseProtocolExposure(positions[i].identifier, balance * 1e18 / 10**decimals);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/DiamondHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 97d6cc3cb60bfd6feda4ea784b13bf0e7daac710;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./interfaces/IDiamondBeacon.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"./lib/avalanche/DeploymentConstants.sol\";\r\n\r\n/**\r\n * DiamondHelper\r\n * Helper methods\r\n **/\r\ncontract DiamondHelper {\r\n    function _getFacetAddress(bytes4 methodSelector) internal view returns (address solvencyFacetAddress) {\r\n        solvencyFacetAddress = IDiamondBeacon(payable(DeploymentConstants.getDiamondAddress())).implementation(methodSelector);\r\n    }\r\n}"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\ncontract RedstoneConstants {\n  // === Abbreviations ===\n  // BS - Bytes size\n  // PTR - Pointer (memory location)\n  // SIG - Signature\n\n  // Solidity and YUL constants\n  uint256 internal constant STANDARD_SLOT_BS = 32;\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n  // RedStone protocol consts\n  uint256 internal constant SIG_BS = 65;\n  uint256 internal constant TIMESTAMP_BS = 6;\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\n  uint256 internal constant UNSGINED_METADATA_BYTE_SIZE_BS = 3;\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n  // Derived values (based on consts)\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\n  // Error messages\n  error CalldataOverOrUnderFlow();\n  error IncorrectUnsignedMetadataSize();\n  error InsufficientNumberOfUniqueSigners(uint256 receviedSignersCount, uint256 requiredSignersCount);\n  error EachSignerMustProvideTheSameValue();\n  error EmptyCalldataPointersArr();\n  error InvalidCalldataPointer();\n  error CalldataMustHaveValidPayload();\n  error SignerNotAuthorised(address receivedSigner);\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\n\n/**\n * @title The base contract with the main logic of data extraction from calldata\n * @author The Redstone Oracles team\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\n * and the ProxyConnector contracts\n */\ncontract CalldataExtractor is RedstoneConstants {\n  using SafeMath for uint256;\n\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\n    // Checking if the calldata ends with the RedStone marker\n    bool hasValidRedstoneMarker;\n    assembly {\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n      hasValidRedstoneMarker := eq(\n        REDSTONE_MARKER_MASK,\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n      )\n    }\n    if (!hasValidRedstoneMarker) {\n      revert CalldataMustHaveValidPayload();\n    }\n\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\n    uint24 unsignedMetadataByteSize;\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      unsignedMetadataByteSize := calldataload(\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\n      )\n    }\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\n      + UNSGINED_METADATA_BYTE_SIZE_BS\n      + REDSTONE_MARKER_BS;\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n      revert IncorrectUnsignedMetadataSize();\n    }\n    return calldataNegativeOffset;\n  }\n\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\n    internal\n    pure\n    returns (uint16 dataPackagesCount)\n  {\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      dataPackagesCount := calldataload(\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\n      )\n    }\n    return dataPackagesCount;\n  }\n\n  function _extractDataPointValueAndDataFeedId(\n    uint256 calldataNegativeOffsetForDataPackage,\n    uint256 defaultDataPointValueByteSize,\n    uint256 dataPointIndex\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n    uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n    uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\n      (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\n    );\n    uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\n    assembly {\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n    }\n  }\n\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\n    internal\n    pure\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\n  {\n    // Using uint24, because data points count byte size number has 3 bytes\n    uint24 dataPointsCount_;\n\n    // Using uint32, because data point value byte size has 4 bytes\n    uint32 eachDataPointValueByteSize_;\n\n    // Extract data points count\n    uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\n    uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\n    assembly {\n      dataPointsCount_ := calldataload(calldataOffset)\n    }\n\n    // Extract each data point value size\n    calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\n    assembly {\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\n    }\n\n    // Prepare returned values\n    dataPointsCount = dataPointsCount_;\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/data-services/AvalancheDataServiceConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConsumerNumericBase.sol\";\n\ncontract AvalancheDataServiceConsumerBase is RedstoneConsumerNumericBase {\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 3;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x1eA62d73EdF8AC05DfceA1A34b9796E937a29EfF) {\n      return 0;\n    } else if (signerAddress == 0x2c59617248994D12816EE1Fa77CE0a64eEB456BF) {\n      return 1;\n    } else if (signerAddress == 0x12470f7aBA85c8b81D63137DD5925D6EE114952b) {\n      return 2;\n    } else if (signerAddress == 0x109B4a318A4F5ddcbCA6349B45f881B4137deaFB) {\n      return 3;\n    } else if (signerAddress == 0x83cbA8c619fb629b81A65C2e67fE15cf3E3C9747) {\n      return 4;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConsumerBase.sol\";\n\n/**\n * @title The base contract for Redstone consumers' contracts that allows to\n * securely calculate numeric redstone oracle values\n * @author The Redstone Oracles team\n * @dev This contract can extend other contracts to allow them\n * securely fetch Redstone oracle data from transactions calldata\n */\nabstract contract RedstoneConsumerNumericBase is RedstoneConsumerBase {\n  /**\n   * @dev This function can be used in a consumer contract to securely extract an\n   * oracle value for a given data feed id. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedId bytes32 value that uniquely identifies the data feed\n   * @return Extracted and verified numeric oracle value for the given data feed id\n   */\n  function getOracleNumericValueFromTxMsg(bytes32 dataFeedId)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    bytes32[] memory dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = dataFeedId;\n    return getOracleNumericValuesFromTxMsg(dataFeedIds)[0];\n  }\n\n  /**\n   * @dev This function can be used in a consumer contract to securely extract several\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIds array\n   */\n  function getOracleNumericValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    virtual\n    returns (uint256[] memory)\n  {\n    return _securelyExtractOracleValuesFromTxMsg(dataFeedIds);\n  }\n\n  /**\n   * @dev This function works similarly to the `getOracleNumericValuesFromTxMsg` with the\n   * only difference that it allows to request oracle data for an array of data feeds\n   * that may contain duplicates\n   * \n   * @param dataFeedIdsWithDuplicates An array of data feed identifiers (duplicates are allowed)\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIdsWithDuplicates array\n   */\n  function getOracleNumericValuesWithDuplicatesFromTxMsg(bytes32[] memory dataFeedIdsWithDuplicates) internal view returns (uint256[] memory) {\n    // Building an array without duplicates\n    bytes32[] memory dataFeedIdsWithoutDuplicates = new bytes32[](dataFeedIdsWithDuplicates.length);\n    bool alreadyIncluded;\n    uint256 uniqueDataFeedIdsCount = 0;\n\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      // Checking if current element is already included in `dataFeedIdsWithoutDuplicates`\n      alreadyIncluded = false;\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < uniqueDataFeedIdsCount; indexWithoutDup++) {\n        if (dataFeedIdsWithoutDuplicates[indexWithoutDup] == dataFeedIdsWithDuplicates[indexWithDup]) {\n          alreadyIncluded = true;\n          break;\n        }\n      }\n\n      // Adding if not included\n      if (!alreadyIncluded) {\n        dataFeedIdsWithoutDuplicates[uniqueDataFeedIdsCount] = dataFeedIdsWithDuplicates[indexWithDup];\n        uniqueDataFeedIdsCount++;\n      }\n    }\n\n    // Overriding dataFeedIdsWithoutDuplicates.length\n    // Equivalent to: dataFeedIdsWithoutDuplicates.length = uniqueDataFeedIdsCount;\n    assembly {\n      mstore(dataFeedIdsWithoutDuplicates, uniqueDataFeedIdsCount)\n    }\n\n    // Requesting oracle values (without duplicates)\n    uint256[] memory valuesWithoutDuplicates = getOracleNumericValuesFromTxMsg(dataFeedIdsWithoutDuplicates);\n\n    // Preparing result values array\n    uint256[] memory valuesWithDuplicates = new uint256[](dataFeedIdsWithDuplicates.length);\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < dataFeedIdsWithoutDuplicates.length; indexWithoutDup++) {\n        if (dataFeedIdsWithDuplicates[indexWithDup] == dataFeedIdsWithoutDuplicates[indexWithoutDup]) {\n          valuesWithDuplicates[indexWithDup] = valuesWithoutDuplicates[indexWithoutDup];\n          break;\n        }\n      }\n    }\n\n    return valuesWithDuplicates;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\nimport \"./RedstoneDefaultsLib.sol\";\nimport \"./CalldataExtractor.sol\";\nimport \"../libs/BitmapLib.sol\";\nimport \"../libs/SignatureLib.sol\";\n\n/**\n * @title The base contract with the main Redstone logic\n * @author The Redstone Oracles team\n * @dev Do not use this contract directly in consumer contracts, take a\n * look at `RedstoneConsumerNumericBase` and `RedstoneConsumerBytesBase` instead\n */\nabstract contract RedstoneConsumerBase is CalldataExtractor {\n  using SafeMath for uint256;\n\n  /* ========== VIRTUAL FUNCTIONS (MAY BE OVERRIDEN IN CHILD CONTRACTS) ========== */\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return a unique index for a given signer address if the signer\n   * is authorised, otherwise it should revert\n   * @param receviedSigner The address of a signer, recovered from ECDSA signature\n   * @return Unique index for a signer in the range [0..255]\n   */\n  function getAuthorisedSignerIndex(address receviedSigner) public view virtual returns (uint8);\n\n  /**\n   * @dev This function may be overriden by the child consumer contract.\n   * It should validate the timestamp against the current time (block.timestamp)\n   * It should revert with a helpful message if the timestamp is not valid\n   * @param receivedTimestampMilliseconds Timestamp extracted from calldata\n   */\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual {\n    RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\n  }\n\n  /**\n   * @dev This function should be overriden by the child consumer contract.\n   * @return The minimum required value of unique authorised signers\n   */\n  function getUniqueSignersThreshold() public view virtual returns (uint8) {\n    return 1;\n  }\n\n  /**\n   * @dev This function may be overriden by the child consumer contract.\n   * It should aggregate values from different signers to a single uint value.\n   * By default, it calculates the median value\n   * @param values An array of uint256 values from different signers\n   * @return Result of the aggregation in the form of a single number\n   */\n  function aggregateValues(uint256[] memory values) public view virtual returns (uint256) {\n    return RedstoneDefaultsLib.aggregateValues(values);\n  }\n\n  /* ========== FUNCTIONS WITH IMPLEMENTATION (CAN NOT BE OVERRIDEN) ========== */\n\n  /**\n   * @dev This is an internal helpful function for secure extraction oracle values\n   * from the tx calldata. Security is achieved by signatures verification, timestamp\n   * validation, and aggregating values from different authorised signers into a\n   * single numeric value. If any of the required conditions (e.g. too old timestamp or\n   * insufficient number of autorised signers) do not match, the function will revert.\n   *\n   * Note! You should not call this function in a consumer contract. You can use\n   * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\n   *\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in dataFeedIds array\n   */\n  function _securelyExtractOracleValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    returns (uint256[] memory)\n  {\n    // Initializing helpful variables and allocating memory\n    uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\n    for (uint256 i = 0; i < dataFeedIds.length; i++) {\n      // The line below is commented because newly allocated arrays are filled with zeros\n      // But we left it for better readability\n      // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\n      valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\n    }\n\n    // Extracting the number of data packages from calldata\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n\n    // Saving current free memory pointer\n    uint256 freeMemPtr;\n    assembly {\n      freeMemPtr := mload(FREE_MEMORY_PTR)\n    }\n\n    // Data packages extraction in a loop\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      // Extract data package details and update calldata offset\n      uint256 dataPackageByteSize = _extractDataPackage(\n        dataFeedIds,\n        uniqueSignerCountForDataFeedIds,\n        signersBitmapForDataFeedIds,\n        valuesForDataFeeds,\n        calldataNegativeOffset\n      );\n      calldataNegativeOffset += dataPackageByteSize;\n\n      // Shifting memory pointer back to the \"safe\" value\n      assembly {\n        mstore(FREE_MEMORY_PTR, freeMemPtr)\n      }\n    }\n\n    // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\n    return _getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds);\n  }\n\n  /**\n   * @dev This is a private helpful function, which extracts data for a data package based\n   * on the given negative calldata offset, verifies them, and in the case of successful\n   * verification updates the corresponding data package values in memory\n   *\n   * @param dataFeedIds an array of unique data feed identifiers\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   * @param signersBitmapForDataFeedIds an array of sginers bitmaps for data feeds\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param calldataNegativeOffset negative calldata offset for the given data package\n   *\n   * @return An array of the aggregated values\n   */\n  function _extractDataPackage(\n    bytes32[] memory dataFeedIds,\n    uint256[] memory uniqueSignerCountForDataFeedIds,\n    uint256[] memory signersBitmapForDataFeedIds,\n    uint256[][] memory valuesForDataFeeds,\n    uint256 calldataNegativeOffset\n  ) private view returns (uint256) {\n    uint256 signerIndex;\n\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    // We use scopes to resolve problem with too deep stack\n    {\n      uint48 extractedTimestamp;\n      address signerAddress;\n      bytes32 signedHash;\n      bytes memory signedMessage;\n      uint256 signedMessageBytesCount;\n\n      signedMessageBytesCount = dataPointsCount.mul(eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS)\n        + DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS;\n\n      uint256 timestampCalldataOffset = msg.data.length.sub(\n        calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n\n      uint256 signedMessageCalldataOffset = msg.data.length.sub(\n        calldataNegativeOffset + SIG_BS + signedMessageBytesCount);\n\n      assembly {\n        // Extracting the signed message\n        signedMessage := extractBytesFromCalldata(\n          signedMessageCalldataOffset,\n          signedMessageBytesCount\n        )\n\n        // Hashing the signed message\n        signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\n\n        // Extracting timestamp\n        extractedTimestamp := calldataload(timestampCalldataOffset)\n\n        function initByteArray(bytesCount) -> ptr {\n          ptr := mload(FREE_MEMORY_PTR)\n          mstore(ptr, bytesCount)\n          ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\n          mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\n        }\n\n        function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\n          let extractedBytesStartPtr := initByteArray(bytesCount)\n          calldatacopy(\n            extractedBytesStartPtr,\n            offset,\n            bytesCount\n          )\n          extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\n        }\n      }\n\n      // Validating timestamp\n      validateTimestamp(extractedTimestamp);\n\n      // Verifying the off-chain signature against on-chain hashed data\n      signerAddress = SignatureLib.recoverSignerAddress(\n        signedHash,\n        calldataNegativeOffset + SIG_BS\n      );\n      signerIndex = getAuthorisedSignerIndex(signerAddress);\n    }\n\n    // Updating helpful arrays\n    {\n      bytes32 dataPointDataFeedId;\n      uint256 dataPointValue;\n      for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount; dataPointIndex++) {\n        // Extracting data feed id and value for the current data point\n        (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\n          calldataNegativeOffset,\n          eachDataPointValueByteSize,\n          dataPointIndex\n        );\n\n        for (\n          uint256 dataFeedIdIndex = 0;\n          dataFeedIdIndex < dataFeedIds.length;\n          dataFeedIdIndex++\n        ) {\n          if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\n            uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\n\n            if (\n              !BitmapLib.getBitFromBitmap(bitmapSignersForDataFeedId, signerIndex) && /* current signer was not counted for current dataFeedId */\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\n            ) {\n              // Increase unique signer counter\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\n\n              // Add new value\n              valuesForDataFeeds[dataFeedIdIndex][\n                uniqueSignerCountForDataFeedIds[dataFeedIdIndex] - 1\n              ] = dataPointValue;\n\n              // Update signers bitmap\n              signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\n                bitmapSignersForDataFeedId,\n                signerIndex\n              );\n            }\n\n            // Breaking, as there couldn't be several indexes for the same feed ID\n            break;\n          }\n        }\n      }\n    }\n\n    // Return total data package byte size\n    return\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS +\n      (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) *\n      dataPointsCount;\n  }\n\n  /**\n   * @dev This is a private helpful function, which aggregates values from different\n   * authorised signers for the given arrays of values for each data feed\n   *\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   *\n   * @return An array of the aggregated values\n   */\n  function _getAggregatedValues(\n    uint256[][] memory valuesForDataFeeds,\n    uint256[] memory uniqueSignerCountForDataFeedIds\n  ) private view returns (uint256[] memory) {\n    uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\n    uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\n\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\n      if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\n        revert InsufficientNumberOfUniqueSigners(\n          uniqueSignerCountForDataFeedIds[dataFeedIndex],\n          uniqueSignersThreshold);\n      }\n      uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\n      aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\n    }\n\n    return aggregatedValues;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../libs/NumericArrayLib.sol\";\n\n/**\n * @title Default implementations of virtual redstone consumer base functions\n * @author The Redstone Oracles team\n */\nlibrary RedstoneDefaultsLib {\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\n\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\n\n    if (block.timestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\n      }\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\n    }\n  }\n\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n    return NumericArrayLib.pickMedian(values);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BitmapLib {\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\n    return bitmap | (1 << bitIndex);\n  }\n\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\n    return bitAtIndex > 0;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignatureLib {\n  uint256 constant ECDSA_SIG_R_BS = 32;\n  uint256 constant ECDSA_SIG_S_BS = 32;\n\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\n      r := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\n      s := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\n    }\n    return ecrecover(signedHash, v, r, s);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary NumericArrayLib {\n  // This function sort array in memory using bubble sort algorithm,\n  // which performs even better than quick sort for small arrays\n\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 constant UINT256_VALUE_BS = 32;\n\n  error CanNotPickMedianOfEmptyArray();\n\n  // This function modifies the array\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\n    if (arr.length == 0) {\n      revert CanNotPickMedianOfEmptyArray();\n    }\n    sort(arr);\n    uint256 middleIndex = arr.length / 2;\n    if (arr.length % 2 == 0) {\n      uint256 sum = SafeMath.add(arr[middleIndex - 1], arr[middleIndex]);\n      return sum / 2;\n    } else {\n      return arr[middleIndex];\n    }\n  }\n\n  function sort(uint256[] memory arr) internal pure {\n    assembly {\n      let arrLength := mload(arr)\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\n      for {\n        let arrIPtr := valuesPtr\n      } lt(arrIPtr, endPtr) {\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\n      } {\n        for {\n          let arrJPtr := valuesPtr\n        } lt(arrJPtr, arrIPtr) {\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\n        } {\n          let arrI := mload(arrIPtr)\n          let arrJ := mload(arrJPtr)\n          if lt(arrI, arrJ) {\n            mstore(arrIPtr, arrJ)\n            mstore(arrJPtr, arrI)\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\ninterface IIndex {\r\n\r\n    function setRate(uint256 _rate) external;\r\n\r\n    function updateUser(address user) external;\r\n\r\n    function getIndex() external view returns (uint256);\r\n\r\n    function getIndexedValue(uint256 value, address user) external view returns (uint256);\r\n\r\n}\r\n"
    },
    "contracts/interfaces/IRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IRatesCalculator\r\n * @dev Interface defining base method for contracts implementing interest rates calculation.\r\n * The calculated value could be based on the relation between funds borrowed and deposited.\r\n */\r\ninterface IRatesCalculator {\r\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external view returns (uint256);\r\n\r\n    function calculateDepositRate(uint256 totalLoans, uint256 totalDeposits) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IBorrowersRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IBorrowersRegistry\r\n * Keeps a registry of created trading accounts to verify their borrowing rights\r\n */\r\ninterface IBorrowersRegistry {\r\n    function canBorrow(address _account) external view returns (bool);\r\n\r\n    function getLoanForOwner(address _owner) external view returns (address);\r\n\r\n    function getOwnerOfLoan(address _loan) external view returns (address);\r\n}\r\n"
    },
    "contracts/interfaces/IPoolRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity ^0.8.17;\r\n\r\ninterface IPoolRewarder {\r\n\r\n    function stakeFor(uint _amount, address _stakeFor) external;\r\n\r\n    function withdrawFor(uint _amount, address _unstakeFor) external returns (uint);\r\n\r\n    function getRewardsFor(address _user) external;\r\n\r\n    function earned(address _account) external view returns (uint);\r\n\r\n    function balanceOf(address _account) external view returns (uint);\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/interfaces/IDiamondBeacon.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IDiamondBeacon {\r\n\r\n    function implementation() external view returns (address);\r\n\r\n    /**\r\n     * @dev Must return an address that can be used as a delegate call target.\r\n     *\r\n     * {SmartLoanDiamondProxy} will check that this address is a contract.\r\n     */\r\n    function implementation(bytes4) external view returns (address);\r\n\r\n    function getStatus() external view returns (bool);\r\n\r\n    function proposeBeaconOwnershipTransfer(address _newOwner) external;\r\n\r\n    function acceptBeaconOwnership() external;\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/facets/SmartLoanWrappedNativeTokenFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: bdee015765a0dd3731205df659aae576d57dd473;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"../interfaces/IWrappedNativeToken.sol\";\r\nimport \"../lib/SolvencyMethods.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract SmartLoanWrappedNativeTokenFacet is SolvencyMethods {\r\n    using TransferHelper for address payable;\r\n\r\n    function wrapNativeToken(uint256 amount) onlyOwner public {\r\n        require(amount <= address(this).balance, \"Not enough native token to wrap\");\r\n        IWrappedNativeToken wrapped = IWrappedNativeToken(DeploymentConstants.getNativeToken());\r\n        wrapped.deposit{value : amount}();\r\n\r\n        if (wrapped.balanceOf(address(this)) != 0) {\r\n            DiamondStorageLib.addOwnedAsset(DeploymentConstants.getNativeTokenSymbol(), address(wrapped));\r\n        }\r\n\r\n        emit WrapNative(msg.sender, amount, block.timestamp);\r\n    }\r\n\r\n    function depositNativeToken() public payable virtual {\r\n        IWrappedNativeToken wrapped = IWrappedNativeToken(DeploymentConstants.getNativeToken());\r\n        wrapped.deposit{value : msg.value}();\r\n\r\n        if (wrapped.balanceOf(address(this)) != 0) {\r\n            DiamondStorageLib.addOwnedAsset(DeploymentConstants.getNativeTokenSymbol(), address(wrapped));\r\n        }\r\n\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        tokenManager.increaseProtocolExposure(DeploymentConstants.getNativeTokenSymbol(), msg.value);\r\n\r\n        emit DepositNative(msg.sender, msg.value, block.timestamp);\r\n    }\r\n\r\n    function unwrapAndWithdraw(uint256 _amount) onlyOwner remainsSolvent canRepayDebtFully public payable virtual {\r\n        IWrappedNativeToken wrapped = IWrappedNativeToken(DeploymentConstants.getNativeToken());\r\n        _amount = Math.min(wrapped.balanceOf(address(this)), _amount);\r\n        require(wrapped.balanceOf(address(this)) >= _amount, \"Not enough native token to unwrap and withdraw\");\r\n\r\n        wrapped.withdraw(_amount);\r\n\r\n        if (wrapped.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(DeploymentConstants.getNativeTokenSymbol());\r\n        }\r\n\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        tokenManager.decreaseProtocolExposure(DeploymentConstants.getNativeTokenSymbol(), _amount);\r\n\r\n        payable(msg.sender).safeTransferETH(_amount);\r\n\r\n        emit UnwrapAndWithdraw(msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n    * @dev emitted when native tokens are wrapped in the SmartLoan\r\n    * @param user the address initiating wrap\r\n    * @param amount of wrapped funds\r\n    * @param timestamp of wrap\r\n    **/\r\n    event WrapNative(address indexed user, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n    * @dev emitted when native tokens are deposited to the SmartLoan\r\n    * @param user the address initiating deposit of native token\r\n    * @param amount of deposited funds\r\n    * @param timestamp of deposit\r\n    **/\r\n    event DepositNative(address indexed user, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n    * @dev emitted when native tokens are unwrapped and withdrawn from the SmartLoan\r\n    * @param user the address initiating unwrap and withdraw of native token\r\n    * @param amount of unwrapped and withdrawn funds\r\n    * @param timestamp of unwrap and withdraw\r\n    **/\r\n    event UnwrapAndWithdraw(address indexed user, uint256 amount, uint256 timestamp);\r\n\r\n}"
    },
    "contracts/integrations/celo/UbeswapIntermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../UniswapV2Intermediary.sol\";\r\nimport \"../../lib/avalanche/DeploymentConstants.sol\";\r\n\r\n/**\r\n * @title UbeswapIntermediary\r\n * @dev Contract allows user to swap ERC20 tokens on DEX\r\n * This implementation uses the Ubeswap DEX\r\n */\r\ncontract UbeswapIntermediary is UniswapV2Intermediary {\r\n\r\n  /**\r\n   * Returns a path containing tokens' addresses\r\n   * @dev _token ERC20 token's address\r\n   **/\r\n  function getPath(address _token1, address _token2) internal override pure returns (address[] memory) {\r\n    address[] memory path;\r\n    path = new address[](2);\r\n    path[0] = _token1;\r\n    path[1] = _token2;\r\n\r\n    return path;\r\n  }\r\n\r\n  function getNativeTokenAddress() override internal pure returns (address) {\r\n    return DeploymentConstants.getNativeToken();\r\n  }\r\n}"
    },
    "contracts/integrations/UniswapV2Intermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\r\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"../ReentrancyGuardKeccak.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"../interfaces/IAssetsExchange.sol\";\r\nimport \"../TokenList.sol\";\r\nimport \"../interfaces/ITokenManager.sol\";\r\n\r\n/**\r\n * @title UniswapV2Intermediary\r\n * @dev Contract allows user to swap ERC20 tokens on DEX\r\n * This implementation supports UniswapV2-like DEXs\r\n */\r\ncontract UniswapV2Intermediary is TokenListOwnableUpgreadable, IAssetsExchange, ReentrancyGuardKeccak {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    /* ========= STATE VARIABLES ========= */\r\n    IUniswapV2Router01 router;\r\n    IUniswapV2Factory factory;\r\n    ITokenManager tokenManager;\r\n\r\n    function initialize(address _router, address _tokenManager, address[] memory _whitelistedTokens) external initializer {\r\n        tokenManager = ITokenManager(_tokenManager);\r\n        router = IUniswapV2Router01(_router);\r\n        factory = IUniswapV2Factory(router.factory());\r\n\r\n        __TokenList_init(_whitelistedTokens);\r\n    }\r\n\r\n    /*\r\n     * Swaps selected ERC20 token with other ERC20 token\r\n     * @param soldToken_ sold ERC20 token's address\r\n     * @param boughtToken_ bought ERC20 token's address\r\n     * @param _exactSold exact amount of ERC20 token to be sold\r\n     * @param _minimumBought minimum amount of ERC20 token to be bought\r\n     **/\r\n    function swap(address _soldToken, address _boughtToken, uint256 _exactSold, uint256 _minimumBought) external override nonReentrant returns (uint256[] memory amounts) {\r\n        require(_exactSold > 0, \"Amount of tokens to sell has to be greater than 0\");\r\n\r\n        _soldToken.safeApprove(address(router), 0);\r\n        _soldToken.safeApprove(address(router), _exactSold);\r\n\r\n        require(isTokenWhitelisted[_boughtToken], 'Trying to buy unsupported token');\r\n\r\n        if (_minimumBought > 0) {\r\n            require(_exactSold >= getMinimumTokensNeeded(_minimumBought, _soldToken, _boughtToken), \"Not enough funds were provided\");\r\n        }\r\n\r\n        amounts = router.swapExactTokensForTokens(_exactSold, _minimumBought, getPath(_soldToken, _boughtToken), msg.sender, block.timestamp);\r\n\r\n        uint256 residualBalance = IERC20Metadata(_soldToken).balanceOf(address(this));\r\n\r\n        if (residualBalance > 0) {\r\n            _soldToken.safeTransfer(msg.sender, residualBalance);\r\n        }\r\n\r\n        return amounts;\r\n    }\r\n\r\n\r\n    /*\r\n     * addLiquidity selected ERC20 tokens\r\n     **/\r\n    function addLiquidity(address tokenA, address tokenB, uint amountA, uint amountB, uint amountAMin, uint amountBMin) external override nonReentrant returns (address, uint, uint, uint) {\r\n        require(amountA > 0, \"amountADesired has to be greater than 0\");\r\n        require(amountB > 0, \"amountBDesired to sell has to be greater than 0\");\r\n        require(amountAMin > 0, \"amountAMin has to be greater than 0\");\r\n        require(amountBMin > 0, \"amountBMin has to be greater than 0\");\r\n\r\n        tokenA.safeApprove(address(router), amountA);\r\n        tokenB.safeApprove(address(router), amountB);\r\n\r\n        address lpTokenAddress = getPair(tokenA, tokenB);\r\n\r\n        require(isTokenWhitelisted[tokenA], 'Trying to LP unsupported token');\r\n        require(isTokenWhitelisted[tokenB], 'Trying to LP unsupported token');\r\n        require(tokenManager.isTokenAssetActive(lpTokenAddress), 'Trying to add unsupported LP token');\r\n\r\n        uint liquidity;\r\n        (amountA, amountB, liquidity) =\r\n           router.addLiquidity(tokenA, tokenB, amountA, amountB, amountAMin, amountBMin, address(this), block.timestamp);\r\n\r\n        lpTokenAddress.safeTransfer(msg.sender, IERC20Metadata(lpTokenAddress).balanceOf(address(this)));\r\n        if (IERC20Metadata(tokenA).balanceOf(address(this)) > 0) {\r\n            tokenA.safeTransfer(msg.sender, IERC20Metadata(tokenA).balanceOf(address(this)));\r\n        }\r\n        if ( IERC20Metadata(tokenB).balanceOf(address(this)) > 0) {\r\n            tokenB.safeTransfer(msg.sender, IERC20Metadata(tokenB).balanceOf(address(this)));\r\n        }\r\n\r\n        return (lpTokenAddress, amountA, amountB, liquidity);\r\n    }\r\n\r\n\r\n    /*\r\n     *  removeLiquidity selected ERC20 tokens\r\n     **/\r\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountA, uint amountB) external override nonReentrant returns (uint, uint) {\r\n        require(amountA > 0, \"amountA has to be greater than 0\");\r\n        require(amountB > 0, \"amountB has to be greater than 0\");\r\n\r\n        address lpTokenAddress = getPair(tokenA, tokenB);\r\n\r\n        lpTokenAddress.safeApprove(address(router), liquidity);\r\n\r\n        require(isTokenWhitelisted[tokenA], 'Trying to remove LP of unsupported token');\r\n        require(isTokenWhitelisted[tokenB], 'Trying to remove LP of unsupported token');\r\n        //TODO: handle paused LP tokens\r\n        require(tokenManager.isTokenAssetActive(lpTokenAddress), 'Trying to remove unsupported LP token');\r\n\r\n        (amountA, amountB) =\r\n         router.removeLiquidity(tokenA, tokenB, liquidity, amountA, amountB, address(this), block.timestamp);\r\n\r\n        lpTokenAddress.safeTransfer(msg.sender, IERC20Metadata(lpTokenAddress).balanceOf(address(this)));\r\n        tokenA.safeTransfer(msg.sender, IERC20Metadata(tokenA).balanceOf(address(this)));\r\n        tokenB.safeTransfer(msg.sender, IERC20Metadata(tokenB).balanceOf(address(this)));\r\n\r\n        return (amountA, amountB);\r\n    }\r\n\r\n\r\n    /* ========== RECEIVE AVAX FUNCTION ========== */\r\n    receive() external payable {}\r\n\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Returns the minimum _soldToken amount that is required to be sold to receive _exactAmountOut of a _boughtToken.\r\n     * Can revert due to insufficient liquidity\r\n     **/\r\n    function getMinimumTokensNeeded(uint256 _exactAmountOut, address _soldToken, address _boughtToken) public view override returns (uint256) {\r\n        address[] memory path = getPath(_soldToken, _boughtToken);\r\n\r\n        (bool success, bytes memory result) = address(router).staticcall(\r\n            abi.encodeWithSignature(\"getAmountsIn(uint256,address[])\", _exactAmountOut, path)\r\n        );\r\n\r\n        require(success, \"Error when calculating amounts needed\");\r\n\r\n        uint256[] memory amounts = abi.decode(result, (uint256[]));\r\n\r\n        return amounts[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum _boughtToken amount that will be obtained in the event of selling _amountIn of _soldToken token.\r\n     **/\r\n    function getMaximumTokensReceived(uint256 _amountIn, address _soldToken, address _boughtToken) public view override returns (uint256) {\r\n        address[] memory path = getPath(_soldToken, _boughtToken);\r\n\r\n        return router.getAmountsOut(_amountIn, path)[1];\r\n    }\r\n\r\n    /**\r\n     * Returns a path containing tokens' addresses\r\n     * @param _token1 ERC20 token's address\r\n     * @param _token2 ERC20 token's address\r\n     **/\r\n    function getPath(address _token1, address _token2) internal virtual view returns (address[] memory) {\r\n        address[] memory path;\r\n\r\n        if (_token1 != getNativeTokenAddress() && _token2 != getNativeTokenAddress()) {\r\n            path = new address[](3);\r\n            path[0] = _token1;\r\n            path[1] = getNativeTokenAddress();\r\n            path[2] = _token2;\r\n        } else {\r\n            path = new address[](2);\r\n            path[0] = _token1;\r\n            path[1] = _token2;\r\n        }\r\n\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Returns an address of LP token\r\n     * @param _token1 ERC20 token's address\r\n     * @param _token2 ERC20 token's address\r\n     **/\r\n    function getPair(address _token1, address _token2) public virtual view returns (address) {\r\n        return factory.getPair(_token1, _token2);\r\n    }\r\n\r\n    function getNativeTokenAddress() virtual internal view returns (address) {\r\n        //address of WETH9 on Ethereum network. Must be overriden in implementations on other chains\r\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    }\r\n}"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/interfaces/IAssetsExchange.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title IAssetExchange\r\n * @dev Basic interface for investing into assets\r\n * It could be linked either to DEX or to a synthetic assets platform\r\n */\r\ninterface IAssetsExchange {\r\n\r\n    /*\r\n     * Swaps selected ERC20 token with other ERC20 token\r\n     * @param soldToken_ sold ERC20 token's address\r\n     * @param boughtToken_ bought ERC20 token's address\r\n     * @param _amountSold exact amount of ERC20 token to be sold\r\n     * @param _amountBought minimum amount of ERC20 token to be bought\r\n     **/\r\n    function swap(address soldToken_, address boughtToken_, uint256 _exactAmountIn, uint256 _minAmountOut) external returns (uint256[] memory);\r\n\r\n    /*\r\n     * Adds liquidity of ERC20 tokens\r\n     */\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) external returns (address, uint, uint, uint);\r\n\r\n    /*\r\n     * Removes liquidity of ERC20 tokens\r\n     */\r\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin) external returns (uint, uint);\r\n\r\n    /**\r\n     * Returns the minimum _soldToken amount that is required to be sold to receive _exactAmountOut of a _boughtToken.\r\n     **/\r\n    function getMinimumTokensNeeded(uint256 _exactAmountOut, address _soldToken, address _boughtToken) external returns (uint256);\r\n\r\n    /**\r\n     * Returns the maximum _boughtToken amount that will be obtained in the event of selling _amountIn of _soldToken token.\r\n     **/\r\n    function getMaximumTokensReceived(uint256 _amountIn, address _soldToken, address _boughtToken) external returns (uint256);\r\n\r\n    /**\r\n     * getPair\r\n     **/\r\n    function getPair(address _tokenA, address _tokenB) external returns (address);\r\n\r\n}\r\n"
    },
    "contracts/TokenList.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\ncontract TokenListOwnableUpgreadable is OwnableUpgradeable {\r\n    mapping(address => bool) isTokenWhitelisted;\r\n    mapping(address => uint256) tokenPositionInList;\r\n    address[] whitelistedTokensList;\r\n\r\n    function __TokenList_init(address[] memory _whitelistedTokens) internal onlyInitializing {\r\n        for (uint256 i = 0; i < _whitelistedTokens.length; i++) {\r\n            require(_whitelistToken(_whitelistedTokens[i], false), \"Whitelisting token failed\");\r\n        }\r\n\r\n        __Ownable_init();\r\n    }\r\n\r\n    // PUBLIC MUTATIVE FUNCTIONS\r\n\r\n    function whitelistTokens(address[] memory tokensToWhitelist) public onlyOwner {\r\n        for (uint256 i = 0; i < tokensToWhitelist.length; i++) {\r\n            require(_whitelistToken(tokensToWhitelist[i], true), \"Whitelisting token failed\");\r\n        }\r\n    }\r\n\r\n    function delistTokens(address[] memory tokensToDelist) public onlyOwner {\r\n        for (uint256 i = 0; i < tokensToDelist.length; i++) {\r\n            require(_delistToken(tokensToDelist[i], true), \"Delisting token failed\");\r\n        }\r\n    }\r\n\r\n    // PUBLIC VIEW FUNCTIONS\r\n\r\n    function getAllWhitelistedTokens() public view returns (address[] memory) {\r\n        return whitelistedTokensList;\r\n    }\r\n\r\n    // Already auto-generated because of the public visibility modifier\r\n    // function isTokenWhitelisted(address token) public view returns (bool) {\r\n    //     return isTokenWhitelisted[token];\r\n    // }\r\n\r\n    // INTERNAL MUTATIVE FUNCTIONS\r\n\r\n    function _whitelistToken(address token, bool revertOnDuplicates) internal returns (bool){\r\n        require(token != address(0), \"Cannot whitelist a zero address\");\r\n\r\n        if (!isTokenWhitelisted[token]) {\r\n            whitelistedTokensList.push(token);\r\n            tokenPositionInList[token] = whitelistedTokensList.length - 1;\r\n            isTokenWhitelisted[token] = true;\r\n            emit TokenWhitelisted(msg.sender, token, block.timestamp);\r\n            return true;\r\n\r\n        } else if (revertOnDuplicates) {\r\n            revert(\"Token already whitelisted\");\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _delistToken(address token, bool revertOnNonListedTokens) internal returns (bool){\r\n        if (isTokenWhitelisted[token]) {\r\n            _removeTokenFromList(token);\r\n            isTokenWhitelisted[token] = false;\r\n            emit TokenDelisted(msg.sender, token, block.timestamp);\r\n            return true;\r\n\r\n        } else if (revertOnNonListedTokens) {\r\n            revert(\"Token was not whitelisted before\");\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // INTERNAL HELPER MUTATIVE FUNCTIONS\r\n\r\n    function _removeTokenFromList(address tokenToRemove) internal {\r\n        // Move last address token to the `tokenToRemoveIndex` position (index of an asset that is being removed) in the address[] whitelistedTokensList\r\n        // and update map(address=>uint256) tokenPostitionInList if the token is not already the last element\r\n        uint256 tokenToRemoveIndex = tokenPositionInList[tokenToRemove];\r\n        if (tokenToRemoveIndex != (whitelistedTokensList.length - 1)) {\r\n            address currentLastToken = whitelistedTokensList[whitelistedTokensList.length - 1];\r\n            tokenPositionInList[currentLastToken] = tokenToRemoveIndex;\r\n            whitelistedTokensList[tokenToRemoveIndex] = currentLastToken;\r\n        }\r\n        // Remove last element - that is either the token that is being removed (if was already at the end)\r\n        // or some other asset that at this point was already copied to the `index` positon\r\n        whitelistedTokensList.pop();\r\n        tokenPositionInList[tokenToRemove] = 0;\r\n    }\r\n\r\n    // EVENTS\r\n    /**\r\n    * @dev emitted after whitelisting a token\r\n    * @param user performing the transaction\r\n    * @param token address of whitelisted token\r\n    * @param timestamp of change\r\n    **/\r\n    event TokenWhitelisted(address indexed user, address token, uint256 timestamp);\r\n\r\n    /**\r\n    * @dev emitted after delisting a token\r\n    * @param user performing the transaction\r\n    * @param token address of delisted token\r\n    * @param timestamp of change\r\n    **/\r\n    event TokenDelisted(address indexed user, address token, uint256 timestamp);\r\n}"
    },
    "contracts/integrations/avalanche/TraderJoeIntermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../UniswapV2Intermediary.sol\";\r\nimport \"../../lib/avalanche/DeploymentConstants.sol\";\r\n\r\n/**\r\n * @title TraderJoeIntermediary\r\n * @dev Contract allows user to swap ERC20 tokens on DEX\r\n * This implementation uses the TraderJoe DEX\r\n */\r\ncontract TraderJoeIntermediary is UniswapV2Intermediary {\r\n\r\n    function getNativeTokenAddress() override internal pure returns (address) {\r\n        return DeploymentConstants.getNativeToken();\r\n    }\r\n}"
    },
    "contracts/lib/local/DeploymentConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity ^0.8.17;\r\n\r\nimport \"../../interfaces/ITokenManager.sol\";\r\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\r\n\r\n/**\r\n * DeploymentConstants\r\n * These constants are updated during test and prod deployments using JS scripts. Defined as constants\r\n * to decrease gas costs. Not meant to be updated unless really necessary.\r\n * BE CAREFUL WHEN UPDATING. CONSTANTS CAN BE USED AMONG MANY FACETS.\r\n **/\r\nlibrary DeploymentConstants {\r\n\r\n    // Used for LiquidationBonus calculations\r\n    uint256 private constant _PERCENTAGE_PRECISION = 1000;\r\n\r\n    bytes32 private constant _NATIVE_TOKEN_SYMBOL = 'AVAX';\r\n\r\n    address private constant _NATIVE_ADDRESS = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\r\n\r\n    address private constant _DIAMOND_BEACON_ADDRESS = 0x02df3a3F960393F5B349E40A599FEda91a7cc1A7;\r\n\r\n    address private constant _SMART_LOANS_FACTORY_ADDRESS = 0x8F4ec854Dd12F1fe79500a1f53D0cbB30f9b6134;\r\n\r\n    address private constant _TOKEN_MANAGER_ADDRESS = 0xdFdE6B33f13de2CA1A75A6F7169f50541B14f75b;\r\n\r\n    //implementation-specific\r\n\r\n    function getPercentagePrecision() internal pure returns (uint256) {\r\n        return _PERCENTAGE_PRECISION;\r\n    }\r\n\r\n    //blockchain-specific\r\n\r\n    function getNativeTokenSymbol() internal pure returns (bytes32 symbol) {\r\n        return _NATIVE_TOKEN_SYMBOL;\r\n    }\r\n\r\n    function getNativeToken() internal pure returns (address payable) {\r\n        return payable(_NATIVE_ADDRESS);\r\n    }\r\n\r\n    //deployment-specific\r\n\r\n    function getDiamondAddress() internal pure returns (address) {\r\n        return _DIAMOND_BEACON_ADDRESS;\r\n    }\r\n\r\n    function getSmartLoansFactoryAddress() internal pure returns (address) {\r\n        return _SMART_LOANS_FACTORY_ADDRESS;\r\n    }\r\n\r\n    function getTokenManager() internal pure returns (ITokenManager) {\r\n        return ITokenManager(_TOKEN_MANAGER_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * Returns all owned assets keys\r\n    **/\r\n    function getAllOwnedAssets() internal view returns (bytes32[] memory result) {\r\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\r\n        return sls.ownedAssets._inner._keys._inner._values;\r\n    }\r\n}"
    },
    "contracts/lib/celo/DeploymentConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../interfaces/ITokenManager.sol\";\r\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\r\n\r\n/**\r\n * DeploymentConstants\r\n * These constants are updated during test and prod deployments using JS scripts. Defined as constants\r\n * to decrease gas costs. Not meant to be updated unless really necessary.\r\n * BE CAREFUL WHEN UPDATING. CONSTANTS CAN BE USED AMONG MANY FACETS.\r\n **/\r\nlibrary DeploymentConstants {\r\n\r\n    // Used for LiquidationBonus calculations\r\n    uint256 private constant _PERCENTAGE_PRECISION = 1000;\r\n\r\n    bytes32 private constant _NATIVE_TOKEN_SYMBOL = 'CELO';\r\n\r\n    address private constant _NATIVE_ADDRESS = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\r\n\r\n    address private constant _DIAMOND_BEACON_ADDRESS = 0x8198f5d8F8CfFE8f9C413d98a0A55aEB8ab9FbB7;\r\n\r\n    address private constant _SMART_LOANS_FACTORY_ADDRESS = 0x4EE6eCAD1c2Dae9f525404De8555724e3c35d07B;\r\n\r\n    address private constant _TOKEN_MANAGER_ADDRESS = 0x4EE6eCAD1c2Dae9f525404De8555724e3c35d07B;\r\n\r\n    //implementation-specific\r\n\r\n    function getPercentagePrecision() internal pure returns (uint256) {\r\n        return _PERCENTAGE_PRECISION;\r\n    }\r\n\r\n    //blockchain-specific\r\n\r\n    function getNativeTokenSymbol() internal pure returns (bytes32 symbol) {\r\n        return _NATIVE_TOKEN_SYMBOL;\r\n    }\r\n\r\n    function getNativeToken() internal pure returns (address payable) {\r\n        return payable(_NATIVE_ADDRESS);\r\n    }\r\n\r\n    //deployment-specific\r\n\r\n    function getDiamondAddress() internal pure returns (address) {\r\n        return _DIAMOND_BEACON_ADDRESS;\r\n    }\r\n\r\n    function getSmartLoansFactoryAddress() internal pure returns (address) {\r\n        return _SMART_LOANS_FACTORY_ADDRESS;\r\n    }\r\n\r\n    function getTokenManager() internal pure returns (ITokenManager) {\r\n        return ITokenManager(_TOKEN_MANAGER_ADDRESS);\r\n    }\r\n\r\n    /**\r\n    * Returns all owned assets keys\r\n    **/\r\n    function getAllOwnedAssets() internal view returns (bytes32[] memory result) {\r\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\r\n        return sls.ownedAssets._inner._keys._inner._values;\r\n    }\r\n}"
    },
    "contracts/facets/SmartLoanViewFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../ReentrancyGuardKeccak.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"../lib/SolvencyMethods.sol\";\r\nimport \"../Pool.sol\";\r\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract SmartLoanViewFacet is ReentrancyGuardKeccak, SolvencyMethods {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    struct AssetNameBalance {\r\n        bytes32 name;\r\n        uint256 balance;\r\n    }\r\n\r\n    struct AssetNameDebt {\r\n        bytes32 name;\r\n        uint256 debt;\r\n    }\r\n\r\n    struct AssetNamePrice {\r\n        bytes32 name;\r\n        uint256 price;\r\n    }\r\n\r\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\r\n\r\n    function initialize(address owner) external {\r\n        require(owner != address(0), \"Initialize: Cannot set the owner to a zero address\");\r\n\r\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\r\n        require(!sls._initialized, \"DiamondInit: contract is already initialized\");\r\n        DiamondStorageLib.setContractOwner(owner);\r\n        sls._initialized = true;\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    function getPercentagePrecision() public view virtual returns (uint256) {\r\n        return DeploymentConstants.getPercentagePrecision();\r\n    }\r\n\r\n\r\n    /**\r\n    * Returns a current balance of the asset held by the smart loan\r\n    * @param _asset the code of an asset\r\n    **/\r\n    function getBalance(bytes32 _asset) public view returns (uint256) {\r\n        IERC20 token = IERC20(DeploymentConstants.getTokenManager().getAssetAddress(_asset, true));\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    function getAllOwnedAssets() external view returns (bytes32[] memory result) {\r\n        return DeploymentConstants.getAllOwnedAssets();\r\n    }\r\n\r\n    function getSupportedTokensAddresses() external view returns (address[] memory) {\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        return tokenManager.getSupportedTokensAddresses();\r\n    }\r\n\r\n    function getAllAssetsBalances() public view returns (AssetNameBalance[] memory) {\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        bytes32[] memory assets = tokenManager.getAllTokenAssets();\r\n        AssetNameBalance[] memory result = new AssetNameBalance[](assets.length);\r\n\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            result[i] = AssetNameBalance({\r\n            name : assets[i],\r\n            balance : IERC20(tokenManager.getAssetAddress(assets[i], true)).balanceOf(address(this))\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function getDebts() public view returns (AssetNameDebt[] memory) {\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        bytes32[] memory assets = tokenManager.getAllPoolAssets();\r\n        AssetNameDebt[] memory result = new AssetNameDebt[](assets.length);\r\n\r\n        for (uint256 i = 0; i < assets.length; i++) {\r\n            Pool pool = Pool(tokenManager.getPoolAddress(assets[i]));\r\n\r\n            result[i] = AssetNameDebt({\r\n            name : assets[i],\r\n            debt : pool.getBorrowed(address(this))\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the prices of all assets supported by the TokenManager\r\n     * It could be used as a helper method for UI\r\n     * @dev This function uses the redstone-evm-connector\r\n     **/\r\n    function getAllAssetsPrices() public returns (AssetNamePrice[] memory) {\r\n        bytes32[] memory assets = DeploymentConstants.getTokenManager().getAllTokenAssets();\r\n        uint256[] memory prices = SolvencyMethods.getPrices(assets);\r\n        AssetNamePrice[] memory result = new AssetNamePrice[](assets.length);\r\n        for (uint i = 0; i < assets.length; i++) {\r\n            result[i] = AssetNamePrice({\r\n                name : assets[i],\r\n                price : prices[i]\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getContractOwner() external view returns (address _owner) {\r\n        _owner = DiamondStorageLib.contractOwner();\r\n    }\r\n\r\n    function getProposedOwner() external view returns (address _proposed) {\r\n        _proposed = DiamondStorageLib.proposedOwner();\r\n    }\r\n\r\n    function getStakedPositions() external view returns (IStakingPositions.StakedPosition[] memory  _positions) {\r\n        _positions = DiamondStorageLib.stakedPositions();\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n}"
    },
    "contracts/interfaces/facets/ISmartLoanViewFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\nimport \"../../facets/SmartLoanViewFacet.sol\";\r\n\r\ninterface ISmartLoanViewFacet {\r\n    function getAllAssetsBalances() external view returns (SmartLoanViewFacet.AssetNameBalance[] memory);\r\n\r\n    function getDebts() external view returns (SmartLoanViewFacet.AssetNameDebt[] memory);\r\n\r\n    function getAllAssetsPrices() external view returns (SmartLoanViewFacet.AssetNamePrice[] memory);\r\n\r\n    function getAllOwnedAssets() external view returns (bytes32[] memory result);\r\n\r\n    function getTotalAssetsValue() external view returns (uint256);\r\n\r\n    function getSupportedTokensAddresses() external view returns (address[] memory result);\r\n\r\n    function getBalance(bytes32 _asset) external view returns (uint256);\r\n\r\n    function getPercentagePrecision() external view returns (uint256);\r\n\r\n    function getContractOwner() external view returns (address _owner);\r\n\r\n    function getProposedOwner() external view returns (address _proposed);\r\n\r\n    function getStakedPositions() external view returns (IStakingPositions.StakedPosition[] memory  _positions);\r\n\r\n    function initialize(address owner) external;\r\n}\r\n"
    },
    "contracts/interfaces/SmartLoanGigaChadInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"./facets/avalanche/IYieldYakFacet.sol\";\r\nimport \"./facets/avalanche/IYieldYakSwapFacet.sol\";\r\nimport \"./facets/avalanche/IPangolinDEXFacet.sol\";\r\nimport \"./facets/avalanche/ITraderJoeDEXFacet.sol\";\r\nimport \"./facets/IAssetsOperationsFacet.sol\";\r\nimport \"./facets/IOwnershipFacet.sol\";\r\nimport \"./facets/ISmartLoanViewFacet.sol\";\r\nimport \"./facets/ISmartLoanLiquidationFacet.sol\";\r\nimport \"./facets/ISmartLoanWrappedNativeTokenFacet.sol\";\r\nimport \"./facets/ISolvencyFacetProd.sol\";\r\nimport \"./IDiamondLoupe.sol\";\r\nimport \"./facets/celo/IUbeswapDEXFacet.sol\";\r\nimport \"./facets/avalanche/IVectorFinanceFacet.sol\";\r\nimport \"./facets/avalanche/IBeefyFinanceFacet.sol\";\r\n\r\ninterface SmartLoanGigaChadInterface is IYieldYakSwapFacet, IDiamondLoupe, IBeefyFinanceFacet, ISmartLoanWrappedNativeTokenFacet, IPangolinDEXFacet, IAssetsOperationsFacet, IOwnershipFacet, ISmartLoanLiquidationFacet, ISmartLoanViewFacet, ISolvencyFacetProd, IYieldYakFacet, IVectorFinanceFacet, IUbeswapDEXFacet, ITraderJoeDEXFacet {\r\n\r\n}\r\n"
    },
    "contracts/interfaces/facets/avalanche/IYieldYakFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface IYieldYakFacet {\r\n    function stakeAVAXYak(uint256 amount) external;\r\n\r\n    function stakeSAVAXYak(uint256 amount) external;\r\n\r\n    function stakePNGAVAXUSDCYak(uint256 amount) external;\r\n\r\n    function stakePNGAVAXETHYak(uint256 amount) external;\r\n\r\n    function stakeTJAVAXUSDCYak(uint256 amount) external;\r\n\r\n    function stakeTJAVAXETHYak(uint256 amount) external;\r\n\r\n    function stakeTJAVAXSAVAXYak(uint256 amount) external;\r\n\r\n    function unstakeAVAXYak(uint256 amount) external;\r\n\r\n    function unstakeSAVAXYak(uint256 amount) external;\r\n\r\n    function unstakePNGAVAXUSDCYak(uint256 amount) external;\r\n\r\n    function unstakePNGAVAXETHYak(uint256 amount) external;\r\n\r\n    function unstakeTJAVAXUSDCYak(uint256 amount) external;\r\n\r\n    function unstakeTJAVAXETHYak(uint256 amount) external;\r\n\r\n    function unstakeTJAVAXSAVAXYak(uint256 amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/facets/avalanche/IYieldYakSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.17;\r\n\r\ninterface IYieldYakSwapFacet {\r\n    function yakSwap(uint256 _amountIn, uint256 _amountOut, address[] calldata _path, address[] calldata _adapters) external;\r\n}"
    },
    "contracts/interfaces/facets/avalanche/IPangolinDEXFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface IPangolinDEXFacet {\r\n    function swapPangolin(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) external returns (uint256[] memory);\r\n\r\n    function addLiquidityPangolin(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) external;\r\n\r\n    function removeLiquidityPangolin(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) external;\r\n\r\n}\r\n"
    },
    "contracts/interfaces/facets/avalanche/ITraderJoeDEXFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface ITraderJoeDEXFacet {\r\n    function swapTraderJoe(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) external returns (uint256[] memory);\r\n\r\n    function addLiquidityTraderJoe(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) external;\r\n\r\n    function removeLiquidityTraderJoe(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) external;\r\n}\r\n"
    },
    "contracts/interfaces/facets/IAssetsOperationsFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface IAssetsOperationsFacet {\r\n    function borrow(bytes32 _asset, uint256 _amount) external;\r\n\r\n    function fund(bytes32 _fundedAsset, uint256 _amount) external;\r\n\r\n    function repay(bytes32 _asset, uint256 _amount) payable external;\r\n\r\n    function withdraw(bytes32 _withdrawnAsset, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/facets/IOwnershipFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface IOwnershipFacet {\r\n    function proposeOwnershipTransfer(address _newOwner) external;\r\n\r\n    function acceptOwnership() external;\r\n\r\n    function owner() external view returns (address owner_);\r\n\r\n    function proposedOwner() external view returns (address proposedOwner_);\r\n\r\n    function pauseAdmin() external view returns (address pauseAdmin);\r\n\r\n    function proposedPauseAdmin() external view returns (address proposedPauseAdmin);\r\n}\r\n"
    },
    "contracts/interfaces/facets/ISmartLoanLiquidationFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface ISmartLoanLiquidationFacet {\r\n  function _getLTV (  ) external returns ( uint256 ltv );\r\n  function getMaxLiquidationBonus (  ) external view returns ( uint256 );\r\n  function getMaxLtv (  ) external view returns ( uint256 );\r\n  function getMinLtvAfterLiquidation (  ) external view returns ( uint256 );\r\n  function getPrice ( bytes32 symbol ) external view returns ( uint256 price );\r\n  function getPrices ( bytes32[] memory symbols ) external view returns ( uint256[] memory prices );\r\n  function liquidateLoan ( bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonus ) external;\r\n  function unsafeLiquidateLoan ( bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonus ) external;\r\n  function whitelistLiquidators(address[] memory _liquidators) external;\r\n  function delistLiquidators(address[] memory _liquidators) external;\r\n  function isLiquidatorWhitelisted(address _liquidator) view external returns(bool);\r\n}\r\n"
    },
    "contracts/interfaces/facets/ISmartLoanWrappedNativeTokenFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface ISmartLoanWrappedNativeTokenFacet {\r\n    function depositNativeToken() payable external;\r\n\r\n    function unwrapAndWithdraw(uint256 _amount) payable external;\r\n\r\n    function wrapNativeToken(uint256 amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/facets/ISolvencyFacetProd.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface ISolvencyFacetProd {\r\n    function getDebt() external view returns (uint256);\r\n\r\n    function getFullLoanStatus() external view returns (uint256[5] memory);\r\n\r\n    function getHealthRatio() external view returns (uint256);\r\n\r\n    function getThresholdWeightedValue() external view returns (uint256);\r\n\r\n    function getMaxDataTimestampDelay() external view returns (uint256);\r\n\r\n    function getTotalValue() external view returns (uint256);\r\n\r\n    function isSignerAuthorized(address _receivedSigner) external view returns (bool);\r\n\r\n    function isSolvent() external view returns (bool);\r\n\r\n    function isTimestampValid(uint256 _receivedTimestamp) external view returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}"
    },
    "contracts/interfaces/facets/celo/IUbeswapDEXFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface IUbeswapDEXFacet {\r\n    function swapUbeswap(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) external returns (uint256[] memory);\r\n}\r\n"
    },
    "contracts/interfaces/facets/avalanche/IVectorFinanceFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface IVectorFinanceFacet {\r\n    function vectorStakeUSDC1(uint256 amount) external;\r\n\r\n    function vectorStakeWAVAX1(uint256 amount) external;\r\n\r\n    function vectorStakeSAVAX1(uint256 amount) external;\r\n\r\n    function vectorUnstakeUSDC1(uint256 amount, uint256 minAmount) external;\r\n\r\n    function vectorUnstakeWAVAX1(uint256 amount, uint256 minAmount) external;\r\n\r\n    function vectorUnstakeSAVAX1(uint256 amount, uint256 minAmount) external;\r\n\r\n    function vectorUSDC1Balance() external view returns(uint256);\r\n\r\n    function vectorWAVAX1Balance() external view returns(uint256);\r\n\r\n    function vectorSAVAX1Balance() external view returns(uint256);\r\n}\r\n"
    },
    "contracts/interfaces/facets/avalanche/IBeefyFinanceFacet.sol": {
      "content": "interface IBeefyFinanceFacet {\r\n    function stakePngUsdcAvaxLpBeefy(uint256 amount) external;\r\n\r\n    function stakePngUsdceAvaxLpBeefy(uint256 amount) external;\r\n\r\n    function stakeTjUsdcAvaxLpBeefy(uint256 amount) external;\r\n\r\n    function unstakePngUsdcAvaxLpBeefy(uint256 amount) external;\r\n\r\n    function unstakePngUsdceAvaxLpBeefy(uint256 amount) external;\r\n\r\n    function unstakeTjUsdcAvaxLpBeefy(uint256 amount) external;\r\n}\r\n"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\nimport {DiamondStorageLib} from  \"../lib/DiamondStorageLib.sol\";\r\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\r\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\n\r\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\r\n// The EIP-2535 Diamond standard requires these functions.\r\n\r\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n    //\r\n    // struct Facet {\r\n    //     address facetAddress;\r\n    //     bytes4[] functionSelectors;\r\n    // }\r\n\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external override view returns (Facet[] memory facets_) {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        uint256 numFacets = ds.facetAddresses.length;\r\n        facets_ = new Facet[](numFacets);\r\n        for (uint256 i; i < numFacets; i++) {\r\n            address facetAddress_ = ds.facetAddresses[i];\r\n            facets_[i].facetAddress = facetAddress_;\r\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors provided by a facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory facetFunctionSelectors_) {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        facetAddresses_ = ds.facetAddresses;\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        return ds.supportedInterfaces[_interfaceId];\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/facets/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n*\r\n* Implementation of a diamond.\r\n/******************************************************************************/\r\n\r\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\r\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\r\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\r\nimport {IERC173} from \"../interfaces/IERC173.sol\";\r\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\n\r\n// It is exapected that this contract is customized if you want to deploy your diamond\r\n// with data from a deployment script. Use the init function to initialize state variables\r\n// of your diamond. Add parameters to the init funciton if you need to.\r\n\r\ncontract DiamondInit {\r\n\r\n    // You can add parameters to this function in order to pass in \r\n    // data to set your own state variables\r\n    function init() external {\r\n        // DiamondStorage\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n\r\n        require(!ds._initialized, \"DiamondInit: contract is already initialized\");\r\n\r\n        // adding ERC165 data\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n\r\n        DiamondStorageLib.setContractOwner(msg.sender);\r\n        ds._initialized = true;\r\n        ds._active = false;\r\n\r\n        // add your own state variables \r\n        // EIP-2535 specifies that the `diamondCut` function takes two optional \r\n        // arguments: address _init and bytes calldata _calldata\r\n        // These arguments are used to execute an arbitrary function using delegatecall\r\n        // in order to set state variables in the diamond during deployment or an upgrade\r\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \r\n    }\r\n\r\n\r\n}"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\r\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\r\n\r\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\r\n// The loupe functions are required by the EIP2535 Diamonds standard\r\n\r\ncontract DiamondCutFacet is IDiamondCut {\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external override paused {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        DiamondStorageLib.diamondCut(_diamondCut, _init, _calldata);\r\n    }\r\n\r\n    function unpause() external override {\r\n        DiamondStorageLib.enforceIsPauseAdmin();\r\n\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        require(!ds._active, \"ProtocolUpgrade: already unpaused.\");\r\n        ds._active = true;\r\n    }\r\n\r\n    function pause() external override {\r\n        DiamondStorageLib.enforceIsPauseAdmin();\r\n\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        require(ds._active, \"ProtocolUpgrade: already paused.\");\r\n        ds._active = false;\r\n    }\r\n\r\n    modifier paused() {\r\n        DiamondStorageLib.DiamondStorage storage ds;\r\n        bytes32 position = DiamondStorageLib.DIAMOND_STORAGE_POSITION;\r\n        // get diamond storage\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        require(!ds._active, \"ProtocolUpgrade: not paused.\");\r\n\r\n        _;\r\n    }\r\n}"
    },
    "contracts/facets/SmartLoanLiquidationFacetDebug.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"../ReentrancyGuardKeccak.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../lib/SolvencyMethods.sol\";\r\nimport \"../Pool.sol\";\r\nimport \"../interfaces/ITokenManager.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\nimport \"../interfaces/facets/ISmartLoanLiquidationFacet.sol\";\r\n\r\nimport \"./SolvencyFacetProd.sol\";\r\nimport \"../SmartLoanDiamondBeacon.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract SmartLoanLiquidationFacetDebug is ReentrancyGuardKeccak, SolvencyMethods {\r\n    //IMPORTANT: KEEP IT IDENTICAL ACROSS FACETS TO BE PROPERLY UPDATED BY DEPLOYMENT SCRIPTS\r\n    uint256 private constant _MAX_HEALTH_AFTER_LIQUIDATION = 1.042e18;\r\n\r\n    //IMPORTANT: KEEP IT IDENTICAL ACROSS FACETS TO BE PROPERLY UPDATED BY DEPLOYMENT SCRIPTS\r\n    uint256 private constant _MAX_LIQUIDATION_BONUS = 100;\r\n\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    /** @param assetsToRepay names of tokens to be repaid to pools\r\n    /** @param amountsToRepay amounts of tokens to be repaid to pools\r\n      * @param liquidationBonus per mille bonus for liquidator. Must be smaller or equal to getMaxLiquidationBonus(). Defined for\r\n      * liquidating loans where debt ~ total value\r\n      * @param allowUnprofitableLiquidation allows performing liquidation of bankrupt loans (total value smaller than debt)\r\n    **/\r\n\r\n    struct LiquidationConfig {\r\n        bytes32[] assetsToRepay;\r\n        uint256[] amountsToRepay;\r\n        uint256 liquidationBonusPercent;\r\n        bool allowUnprofitableLiquidation;\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n      * Returns maximum acceptable health ratio after liquidation\r\n      **/\r\n    function getMaxHealthAfterLiquidation() public pure returns (uint256) {\r\n        return _MAX_HEALTH_AFTER_LIQUIDATION;\r\n    }\r\n\r\n    /**\r\n      * Returns maximum acceptable liquidation bonus (bonus is provided by a liquidator)\r\n      **/\r\n    function getMaxLiquidationBonus() public pure returns (uint256) {\r\n        return _MAX_LIQUIDATION_BONUS;\r\n    }\r\n\r\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\r\n\r\n    function whitelistLiquidators(address[] memory _liquidators) external onlyOwner {\r\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\r\n\r\n        for(uint i; i<_liquidators.length; i++){\r\n            ls.canLiquidate[_liquidators[i]] = true;\r\n            emit LiquidatorWhitelisted(_liquidators[i], msg.sender, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function delistLiquidators(address[] memory _liquidators) external onlyOwner {\r\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\r\n        for(uint i; i<_liquidators.length; i++){\r\n            ls.canLiquidate[_liquidators[i]] = false;\r\n            emit LiquidatorDelisted(_liquidators[i], msg.sender, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function isLiquidatorWhitelisted(address _liquidator) public view returns(bool){\r\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\r\n        return ls.canLiquidate[_liquidator];\r\n    }\r\n\r\n    /**\r\n    * This function can be accessed by any user when Prime Account is insolvent or bankrupt and repay part of the loan\r\n    * with his approved tokens.\r\n    * BE CAREFUL: in contrast to liquidateLoan() method, this one doesn't necessarily return tokens to liquidator, nor give him\r\n    * a bonus. It's purpose is to bring the loan to a solvent position even if it's unprofitable for liquidator.\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param assetsToRepay bytes32[] names of tokens provided by liquidator for repayment\r\n    * @param amountsToRepay utin256[] amounts of tokens provided by liquidator for repayment\r\n    * @param _liquidationBonusPercent per mille bonus for liquidator. Must be lower than or equal to getMaxliquidationBonus()\r\n    **/\r\n    function unsafeLiquidateLoan(bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonusPercent) external payable onlyWhitelistedLiquidators nonReentrant {\r\n        liquidate(\r\n            LiquidationConfig({\r\n                assetsToRepay : assetsToRepay,\r\n                amountsToRepay : amountsToRepay,\r\n                liquidationBonusPercent : _liquidationBonusPercent,\r\n                allowUnprofitableLiquidation : true\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n    * This function can be accessed by any user when Prime Account is insolvent and liquidate part of the loan\r\n    * with his approved tokens.\r\n    * A liquidator has to approve adequate amount of tokens to repay debts to liquidity pools if\r\n    * there is not enough of them in a SmartLoan. For that he will receive the corresponding amount from SmartLoan\r\n    * with the same USD value + bonus.\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param assetsToRepay bytes32[] names of tokens provided by liquidator for repayment\r\n    * @param amountsToRepay utin256[] amounts of tokens provided by liquidator for repayment\r\n    * @param _liquidationBonusPercent per mille bonus for liquidator. Must be lower than or equal to  getMaxLiquidationBonus()\r\n    **/\r\n    function liquidateLoan(bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonusPercent) external payable onlyWhitelistedLiquidators nonReentrant {\r\n        liquidate(\r\n            LiquidationConfig({\r\n                assetsToRepay : assetsToRepay,\r\n                amountsToRepay : amountsToRepay,\r\n                liquidationBonusPercent : _liquidationBonusPercent,\r\n                allowUnprofitableLiquidation : false\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n    * This function can be accessed when Prime Account is insolvent and perform a partial liquidation of the loan\r\n    * (selling assets, closing positions and repaying debts) to bring the account back to a solvent state. At the end\r\n    * of liquidation resulting solvency of account is checked to make sure that the account is between maximum and minimum\r\n    * solvency.\r\n    * To diminish the potential effect of manipulation of liquidity pools by a liquidator, there are no swaps performed\r\n    * during liquidation.\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param config configuration for liquidation\r\n    **/\r\n    function liquidate(LiquidationConfig memory config) internal {\r\n        console.log('Welcome to the liquidation sir');\r\n        SolvencyFacetProd.CachedPrices memory cachedPrices = _getAllPricesForLiquidation(config.assetsToRepay);\r\n        \r\n        uint256 initialTotal = _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices); \r\n        uint256 initialDebt = _getDebtWithPrices(cachedPrices.debtAssetsPrices); \r\n\r\n        require(config.liquidationBonusPercent <= getMaxLiquidationBonus(), \"Defined liquidation bonus higher than max. value\");\r\n        require(!_isSolventWithPrices(cachedPrices), \"Cannot sellout a solvent account\");\r\n\r\n        //healing means bringing a bankrupt loan to a state when debt is smaller than total value again\r\n        bool healingLoan = initialDebt > initialTotal;\r\n        if(healingLoan){\r\n            console.log('HEALING LOAN');\r\n        } else{\r\n            console.log('NOT A HEALING LOAN');\r\n        }\r\n        console.log(initialTotal);\r\n        console.log(initialDebt);\r\n        require(!healingLoan || config.allowUnprofitableLiquidation, \"Trying to liquidate bankrupt loan\");\r\n\r\n\r\n        uint256 suppliedInUSD;\r\n        uint256 repaidInUSD;\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n\r\n        console.log('1');\r\n\r\n        for (uint256 i = 0; i < config.assetsToRepay.length; i++) {\r\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(config.assetsToRepay[i], true));\r\n\r\n            uint256 balance = token.balanceOf(address(this));\r\n            uint256 supplyAmount;\r\n\r\n            if (balance < config.amountsToRepay[i]) {\r\n                supplyAmount = config.amountsToRepay[i] - balance;\r\n            }\r\n\r\n            if (supplyAmount > 0) {\r\n                address(token).safeTransferFrom(msg.sender, address(this), supplyAmount);\r\n                // supplyAmount is denominated in token.decimals(). Price is denominated in 1e8. To achieve 1e18 decimals we need to multiply by 1e10.\r\n                suppliedInUSD += supplyAmount * cachedPrices.assetsToRepayPrices[i].price * 10 ** 10 / 10 ** token.decimals();\r\n            }\r\n\r\n            Pool pool = Pool(tokenManager.getPoolAddress(config.assetsToRepay[i]));\r\n\r\n            uint256 repayAmount = Math.min(pool.getBorrowed(address(this)), config.amountsToRepay[i]);\r\n\r\n            address(token).safeApprove(address(pool), 0);\r\n            address(token).safeApprove(address(pool), repayAmount);\r\n\r\n            // repayAmount is denominated in token.decimals(). Price is denominated in 1e8. To achieve 1e18 decimals we need to multiply by 1e10.\r\n            repaidInUSD += repayAmount * cachedPrices.assetsToRepayPrices[i].price * 10 ** 10 / 10 ** token.decimals();\r\n\r\n            pool.repay(repayAmount);\r\n\r\n            if (token.balanceOf(address(this)) == 0) {\r\n                DiamondStorageLib.removeOwnedAsset(config.assetsToRepay[i]);\r\n            }\r\n\r\n            emit LiquidationRepay(msg.sender, config.assetsToRepay[i], repayAmount, block.timestamp);\r\n        }\r\n\r\n        console.log('2');\r\n\r\n        bytes32[] memory assetsOwned = DeploymentConstants.getAllOwnedAssets();\r\n        uint256 bonusInUSD;\r\n\r\n        //after healing bankrupt loan (debt > total value), no tokens are returned to liquidator\r\n\r\n        bonusInUSD = repaidInUSD * config.liquidationBonusPercent / DeploymentConstants.getPercentagePrecision();\r\n\r\n        //meaning returning all tokens\r\n        uint256 partToReturn = 10 ** 18; // 1\r\n        uint256 assetsValue = _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices);\r\n\r\n        if (!healingLoan && assetsValue >= suppliedInUSD + bonusInUSD) {\r\n            //in that scenario we calculate how big part of token to return\r\n            partToReturn = (suppliedInUSD + bonusInUSD) * 10 ** 18 / assetsValue;\r\n        }\r\n\r\n        // Native token transfer\r\n        if (address(this).balance > 0) {\r\n            payable(msg.sender).safeTransferETH(address(this).balance * partToReturn / 10 ** 18);\r\n        }\r\n\r\n        console.log('3');\r\n\r\n        for (uint256 i; i < assetsOwned.length; i++) {\r\n            IERC20Metadata token = getERC20TokenInstance(assetsOwned[i], true);\r\n            uint256 balance = token.balanceOf(address(this));\r\n\r\n            address(token).safeTransfer(msg.sender, balance * partToReturn / 10 ** 18);\r\n            emit LiquidationTransfer(msg.sender, assetsOwned[i], balance * partToReturn / 10 ** 18, block.timestamp);\r\n        }\r\n\r\n        console.log('4');\r\n\r\n        uint256 health = _getHealthRatioWithPrices(cachedPrices);\r\n\r\n        console.log('5');\r\n\r\n        if (healingLoan) {\r\n            require(_getDebtWithPrices(cachedPrices.debtAssetsPrices) == 0, \"Healing a loan must end up with 0 debt\");\r\n            require(_getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices) == 0, \"Healing a loan must end up with 0 total value\");\r\n        } else {\r\n            require(health <= getMaxHealthAfterLiquidation(), \"This operation would result in a loan with health ratio higher than Maxium Health Ratio which would put loan's owner in a risk of an unnecessarily high loss\");\r\n        }\r\n\r\n        console.log('6');\r\n\r\n        console.log('TV: %s', _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices));\r\n        console.log('Debt: %s', _getDebtWithPrices(cachedPrices.debtAssetsPrices));\r\n\r\n        console.log('Health: %s', health);\r\n\r\n        require(health >= 1e18, \"This operation would not result in bringing the loan back to a solvent state\");\r\n\r\n        console.log('FINISHED');\r\n\r\n        //TODO: include final debt and tv\r\n        emit Liquidated(msg.sender, healingLoan, initialTotal, initialDebt, repaidInUSD, bonusInUSD, health, block.timestamp);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelistedLiquidators() {\r\n        // External call in order to execute this method in the SmartLoanDiamondBeacon contract storage\r\n        require(ISmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender), \"Only whitelisted liquidators can execute this method\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after a successful liquidation operation\r\n     * @param liquidator the address that initiated the liquidation operation\r\n     * @param healing was the liquidation covering the bad debt (unprofitable liquidation)\r\n     * @param initialTotal total value of assets before the liquidation\r\n     * @param initialDebt sum of all debts before the liquidation\r\n     * @param repayAmount requested amount (USD) of liquidation\r\n     * @param bonusInUSD an amount of bonus (USD) received by the liquidator\r\n     * @param health a new health ratio after the liquidation operation\r\n     * @param timestamp a time of the liquidation\r\n     **/\r\n    event Liquidated(address indexed liquidator, bool indexed healing, uint256 initialTotal, uint256 initialDebt, uint256 repayAmount, uint256 bonusInUSD, uint256 health, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when funds are repaid to the pool during a liquidation\r\n     * @param liquidator the address initiating repayment\r\n     * @param asset asset repaid by a liquidator\r\n     * @param amount of repaid funds\r\n     * @param timestamp of the repayment\r\n     **/\r\n    event LiquidationRepay(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when funds are sent to liquidator during liquidation\r\n     * @param liquidator the address initiating repayment\r\n     * @param asset token sent to a liquidator\r\n     * @param amount of sent funds\r\n     * @param timestamp of the transfer\r\n     **/\r\n    event LiquidationTransfer(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when a new liquidator gets whitelisted\r\n     * @param liquidator the address being whitelisted\r\n     * @param performer the address initiating whitelisting\r\n     * @param timestamp of the whitelisting\r\n     **/\r\n    event LiquidatorWhitelisted(address indexed liquidator, address performer, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when a liquidator gets delisted\r\n     * @param liquidator the address being delisted\r\n     * @param performer the address initiating delisting\r\n     * @param timestamp of the delisting\r\n     **/\r\n    event LiquidatorDelisted(address indexed liquidator, address performer, uint256 timestamp);\r\n}\r\n\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/facets/mock/SolvencyFacetMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\r\nimport \"../SolvencyFacetProd.sol\";\r\n\r\ncontract SolvencyFacetMock is SolvencyFacetProd, AuthorisedMockSignersBase {\r\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes; // Test sometimes be slow\r\n\r\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\r\n\r\n    error TimestampIsNotValid();\r\n\r\n    function getAuthorisedSignerIndex(address signerAddress)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint8)\r\n    {\r\n        return getAuthorisedMockSignerIndex(signerAddress);\r\n    }\r\n\r\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\r\n        if (receivedTimestampMilliseconds < MIN_TIMESTAMP_MILLISECONDS) {\r\n            revert TimestampIsNotValid();\r\n        }\r\n    }\r\n}\r\n"
    },
    "@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConstants.sol\";\n\nabstract contract AuthorisedMockSignersBase is RedstoneConstants {\n  function getAuthorisedMockSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    returns (uint8)\n  {\n    return getAllMockExceptLastOneAuthorised(signerAddress);\n  }\n\n  function getAllMockExceptLastOneAuthorised(address signerAddress)\n    public\n    view\n    virtual\n    returns (uint8)\n  {\n    if (signerAddress == 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199) {\n      revert SignerNotAuthorised(signerAddress);\n    } else {\n      return getAllMockAuthorised(signerAddress);\n    }\n  }\n\n  function getAllMockAuthorised(address signerAddress) public view virtual returns (uint8) {\n    // Looks like an array but consumes less gas\n    if (signerAddress == 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) {\n      return 0;\n    } else if (signerAddress == 0x70997970C51812dc3A010C7d01b50e0d17dc79C8) {\n      return 1;\n    } else if (signerAddress == 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC) {\n      return 2;\n    } else if (signerAddress == 0x90F79bf6EB2c4f870365E785982E1f101E93b906) {\n      return 3;\n    } else if (signerAddress == 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65) {\n      return 4;\n    } else if (signerAddress == 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc) {\n      return 5;\n    } else if (signerAddress == 0x976EA74026E726554dB657fA54763abd0C3a0aa9) {\n      return 6;\n    } else if (signerAddress == 0x14dC79964da2C08b23698B3D3cc7Ca32193d9955) {\n      return 7;\n    } else if (signerAddress == 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f) {\n      return 8;\n    } else if (signerAddress == 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720) {\n      return 9;\n    } else if (signerAddress == 0xBcd4042DE499D14e55001CcbB24a551F3b954096) {\n      return 10;\n    } else if (signerAddress == 0x71bE63f3384f5fb98995898A86B02Fb2426c5788) {\n      return 11;\n    } else if (signerAddress == 0xFABB0ac9d68B0B445fB7357272Ff202C5651694a) {\n      return 12;\n    } else if (signerAddress == 0x1CBd3b2770909D4e10f157cABC84C7264073C9Ec) {\n      return 13;\n    } else if (signerAddress == 0xdF3e18d64BC6A983f673Ab319CCaE4f1a57C7097) {\n      return 14;\n    } else if (signerAddress == 0xcd3B766CCDd6AE721141F452C550Ca635964ce71) {\n      return 15;\n    } else if (signerAddress == 0x2546BcD3c84621e976D8185a91A922aE77ECEc30) {\n      return 16;\n    } else if (signerAddress == 0xbDA5747bFD65F08deb54cb465eB87D40e51B197E) {\n      return 17;\n    } else if (signerAddress == 0xdD2FD4581271e230360230F9337D5c0430Bf44C0) {\n      return 18;\n    } else if (signerAddress == 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199) {\n      return 19;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/mock/DoubleBorrowExecInSingleTx.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"../facets/AssetsOperationsFacet.sol\";\r\nimport \"../facets/avalanche/PangolinDEXFacet.sol\";\r\nimport \"../SmartLoansFactory.sol\";\r\n\r\n\r\n/**\r\n * @title DoubleBorrowExecInSingleTx\r\n * @dev For tests\r\n */\r\ncontract DoubleBorrowExecInSingleTx is ProxyConnector {\r\n\r\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    address constant WAVAX_ADDRESS = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\r\n\r\n    function createLoan(address factoryAddress) public {\r\n        SmartLoansFactory factory = SmartLoansFactory(factoryAddress);\r\n        factory.createLoan();\r\n    }\r\n\r\n    function execute(address smartLoanAddress) public {\r\n        IERC20 token = IERC20(WAVAX_ADDRESS);\r\n        token.approve(smartLoanAddress, 1 ether);\r\n\r\n        proxyCalldata(address(smartLoanAddress), abi.encodeWithSelector(AssetsOperationsFacet.fund.selector, stringToBytes32(\"AVAX\"), 1 ether), false);\r\n\r\n        proxyCalldata(address(smartLoanAddress), abi.encodeWithSelector(AssetsOperationsFacet.borrow.selector, stringToBytes32(\"AVAX\"), 1 ether), false);\r\n        // Should fail with: \"Borrowing must happen in a standalone transaction\"\r\n        proxyCalldata(address(smartLoanAddress), abi.encodeWithSelector(PangolinDEXFacet.swapPangolin.selector, stringToBytes32(\"AVAX\"), stringToBytes32(\"USDC\"), 1 ether, 1 ether), false);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/facets/AssetsOperationsFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"../ReentrancyGuardKeccak.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\r\nimport \"../lib/SolvencyMethods.sol\";\r\nimport \"../interfaces/ITokenManager.sol\";\r\n\r\n//this path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract AssetsOperationsFacet is ReentrancyGuardKeccak, SolvencyMethods {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n    * Funds the loan with a specified amount of a defined token\r\n    * @dev Requires approval for ERC20 token on frontend side\r\n    * @param _fundedAsset asset to be funded\r\n    * @param _amount to be funded\r\n    **/\r\n    function fund(bytes32 _fundedAsset, uint256 _amount) public virtual {\r\n        IERC20Metadata token = getERC20TokenInstance(_fundedAsset, false);\r\n        address(token).safeTransferFrom(msg.sender, address(this), _amount);\r\n        if (token.balanceOf(address(this)) > 0) {\r\n            DiamondStorageLib.addOwnedAsset(_fundedAsset, address(token));\r\n        }\r\n\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        tokenManager.increaseProtocolExposure(_fundedAsset, _amount * 1e18 / 10 ** token.decimals());\r\n\r\n        emit Funded(msg.sender, _fundedAsset, _amount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * Withdraws an amount of a defined asset from the loan\r\n    * This method could be used to cash out profits from investments\r\n    * The loan needs to remain solvent after the withdrawal\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param _withdrawnAsset asset to be withdrawn\r\n    * @param _amount to be withdrawn\r\n    **/\r\n    function withdraw(bytes32 _withdrawnAsset, uint256 _amount) public virtual onlyOwner nonReentrant canRepayDebtFully remainsSolvent{\r\n        IERC20Metadata token = getERC20TokenInstance(_withdrawnAsset, true);\r\n        require(getBalance(_withdrawnAsset) >= _amount, \"There is not enough funds to withdraw\");\r\n\r\n        address(token).safeTransfer(msg.sender, _amount);\r\n        if (token.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(_withdrawnAsset);\r\n        }\r\n\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        tokenManager.decreaseProtocolExposure(_withdrawnAsset, _amount * 1e18 / 10 ** token.decimals());\r\n\r\n        emit Withdrawn(msg.sender, _withdrawnAsset, _amount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * Borrows funds from the pool\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param _asset to be borrowed\r\n    * @param _amount of funds to borrow\r\n    **/\r\n    function borrow(bytes32 _asset, uint256 _amount) external onlyOwner remainsSolvent {\r\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\r\n        ds._lastBorrowTimestamp = block.timestamp;\r\n\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        Pool pool = Pool(tokenManager.getPoolAddress(_asset));\r\n        pool.borrow(_amount);\r\n\r\n        IERC20Metadata token = getERC20TokenInstance(_asset, false);\r\n        if (token.balanceOf(address(this)) > 0) {\r\n            DiamondStorageLib.addOwnedAsset(_asset, address(token));\r\n        }\r\n\r\n        emit Borrowed(msg.sender, _asset, _amount, block.timestamp);\r\n    }\r\n\r\n\r\n    /**\r\n     * Repays funds to the pool\r\n     * @dev This function uses the redstone-evm-connector\r\n     * @param _asset to be repaid\r\n     * @param _amount of funds to repay\r\n     **/\r\n    function repay(bytes32 _asset, uint256 _amount) public payable {\r\n        IERC20Metadata token = getERC20TokenInstance(_asset, true);\r\n\r\n        if (_isSolvent()) {\r\n            DiamondStorageLib.enforceIsContractOwner();\r\n        }\r\n\r\n        Pool pool = Pool(DeploymentConstants.getTokenManager().getPoolAddress(_asset));\r\n\r\n        _amount = Math.min(_amount, pool.getBorrowed(address(this)));\r\n        require(token.balanceOf(address(this)) >= _amount, \"There is not enough funds to repay\");\r\n\r\n        address(token).safeApprove(address(pool), 0);\r\n        address(token).safeApprove(address(pool), _amount);\r\n\r\n        pool.repay(_amount);\r\n\r\n        if (token.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(_asset);\r\n        }\r\n\r\n        emit Repaid(msg.sender, _asset, _amount, block.timestamp);\r\n    }\r\n\r\n    /* ======= VIEW FUNCTIONS ======*/\r\n\r\n    /**\r\n    * Returns a current balance of the asset held by the smart loan\r\n    * @param _asset the code of an asset\r\n    **/\r\n    function getBalance(bytes32 _asset) internal view returns (uint256) {\r\n        IERC20 token = IERC20(DeploymentConstants.getTokenManager().getAssetAddress(_asset, true));\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @dev emitted after a loan is funded\r\n     * @param user the address which funded the loan\r\n     * @param asset funded by a user\r\n     * @param amount the amount of funds\r\n     * @param timestamp time of funding\r\n     **/\r\n    event Funded(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after the funds are withdrawn from the loan\r\n     * @param user the address which withdraws funds from the loan\r\n     * @param asset withdrawn by a user\r\n     * @param amount of funds withdrawn\r\n     * @param timestamp of the withdrawal\r\n     **/\r\n    event Withdrawn(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when funds are borrowed from the pool\r\n     * @param user the address of borrower\r\n     * @param asset borrowed by an= user\r\n     * @param amount of the borrowed funds\r\n     * @param timestamp time of the borrowing\r\n     **/\r\n    event Borrowed(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted when funds are repaid to the pool\r\n     * @param user the address initiating repayment\r\n     * @param asset asset repaid by a user\r\n     * @param amount of repaid funds\r\n     * @param timestamp of the repayment\r\n     **/\r\n    event Repaid(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\r\n}"
    },
    "contracts/facets/avalanche/PangolinDEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 71813826f564de63a2462d95b5c15944fcdf686e;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../UniswapV2DEXFacet.sol\";\r\n\r\ncontract PangolinDEXFacet is UniswapV2DEXFacet {\r\n    function getProtocolID() pure internal override returns (bytes32) {\r\n        return \"PNG\";\r\n    }\r\n\r\n    /**\r\n      * Swaps one asset to another\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param _soldAsset asset to be sold\r\n      * @param _boughtAsset asset to be bought\r\n      * @param _exactSold exact amount of asset to be sold\r\n      * @param _minimumBought minimum amount of asset to be bought\r\n    **/\r\n    function swapPangolin(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) public noBorrowInTheSameBlock onlyOwner returns (uint256[] memory) {\r\n        return swapAssets(_soldAsset, _boughtAsset, _exactSold, _minimumBought);\r\n    }\r\n\r\n    function addLiquidityPangolin(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) public onlyOwner {\r\n        addLiquidity(_firstAsset, _secondAsset, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n    }\r\n\r\n    //onlOwnerOrInsolvent inside UniswapDexFacet\r\n    function removeLiquidityPangolin(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) public {\r\n        removeLiquidity(_firstAsset, _secondAsset, liquidity, amountAMin, amountBMin);\r\n    }\r\n\r\n    /**\r\n     * Returns address of UniswapV2-like exchange\r\n     **/\r\n    function getExchangeIntermediaryContract() public override returns (address) {\r\n        return 0xdB5D94B8Ed491B058F3e74D029775A14477cF7fA;\r\n    }\r\n}"
    },
    "contracts/SmartLoansFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\r\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"./SmartLoanDiamondBeacon.sol\";\r\nimport \"./proxies/SmartLoanDiamondProxy.sol\";\r\nimport \"./facets/AssetsOperationsFacet.sol\";\r\nimport \"./facets/OwnershipFacet.sol\";\r\nimport \"./facets/SmartLoanViewFacet.sol\";\r\n\r\n/**\r\n * @title SmartLoansFactory\r\n * @dev Contract responsible for creating new instances of SmartLoans (SmartLoanDiamondBeacon).\r\n * It's possible to either simply create a new loan or create and fund it with an ERC20 asset as well as borrow in a single transaction.\r\n * At the time of creating a loan, SmartLoansFactory contract is the owner for the sake of being able to perform the fund() and borrow() operations.\r\n * At the end of the createAndFundLoan the ownership is transferred to the msg.sender.\r\n * It's also responsible for keeping track of the loans, ensuring one loan per wallet rule, ownership transfers proposals/execution and\r\n * authorizes registered loans to borrow from lending pools.\r\n */\r\ncontract SmartLoansFactory is OwnableUpgradeable, IBorrowersRegistry, ProxyConnector {\r\n    using TransferHelper for address;\r\n    using TransferHelper for address payable;\r\n\r\n    modifier hasNoLoan() {\r\n        require(!_hasLoan(msg.sender), \"Only one loan per owner is allowed\");\r\n        _;\r\n    }\r\n\r\n\r\n    SmartLoanDiamondBeacon public smartLoanDiamond;\r\n\r\n    mapping(address => address) public ownersToLoans;\r\n    mapping(address => address) public loansToOwners;\r\n\r\n    address[] loans;\r\n\r\n    function _hasLoan(address user) internal view returns (bool) {\r\n        return ownersToLoans[user] != address(0);\r\n    }\r\n\r\n    function changeOwnership(address _newOwner) public {\r\n        address loan = msg.sender;\r\n        address oldOwner = loansToOwners[loan];\r\n\r\n        require(oldOwner != address(0), \"Only a SmartLoan can change it's owner\");\r\n        require(!_hasLoan(_newOwner), \"New owner already has a loan\");\r\n\r\n        ownersToLoans[oldOwner] = address(0);\r\n        ownersToLoans[_newOwner] = loan;\r\n        loansToOwners[loan] = _newOwner;\r\n    }\r\n\r\n    function initialize(address payable _smartLoanDiamond) external initializer {\r\n        smartLoanDiamond = SmartLoanDiamondBeacon(_smartLoanDiamond);\r\n        __Ownable_init();\r\n    }\r\n\r\n    function createLoan() public virtual hasNoLoan returns (SmartLoanDiamondBeacon) {\r\n        SmartLoanDiamondProxy beaconProxy = new SmartLoanDiamondProxy(\r\n            payable(address(smartLoanDiamond)),\r\n        // Setting SLFactory as the initial owner and then using .transferOwnership to change the owner to msg.sender\r\n        // It is possible to set msg.sender as the initial owner if our loan-creation flow would change\r\n            abi.encodeWithSelector(SmartLoanViewFacet.initialize.selector, msg.sender)\r\n        );\r\n        SmartLoanDiamondBeacon smartLoan = SmartLoanDiamondBeacon(payable(address(beaconProxy)));\r\n\r\n        //Update registry and emit event\r\n        updateRegistry(address(smartLoan), msg.sender);\r\n\r\n        emit SmartLoanCreated(address(smartLoan), msg.sender, \"\", 0);\r\n        return smartLoan;\r\n    }\r\n\r\n    function createAndFundLoan(bytes32 _fundedAsset, address _assetAddress, uint256 _amount) public virtual hasNoLoan returns (SmartLoanDiamondBeacon) {\r\n        SmartLoanDiamondProxy beaconProxy = new SmartLoanDiamondProxy(payable(address(smartLoanDiamond)),\r\n            abi.encodeWithSelector(SmartLoanViewFacet.initialize.selector, msg.sender)\r\n        );\r\n        SmartLoanDiamondBeacon smartLoan = SmartLoanDiamondBeacon(payable(address(beaconProxy)));\r\n\r\n        //Fund account with own funds and credit\r\n        IERC20Metadata token = IERC20Metadata(_assetAddress);\r\n        address(token).safeTransferFrom(msg.sender, address(this), _amount);\r\n        address(token).safeApprove(address(smartLoan), _amount);\r\n\r\n        //Update registry and emit event\r\n        updateRegistry(address(smartLoan), msg.sender);\r\n\r\n        (bool success, bytes memory result) = address(smartLoan).call(abi.encodeWithSelector(AssetsOperationsFacet.fund.selector, _fundedAsset, _amount));\r\n        ProxyConnector._prepareReturnValue(success, result);\r\n\r\n        emit SmartLoanCreated(address(smartLoan), msg.sender, _fundedAsset, _amount);\r\n\r\n        return smartLoan;\r\n    }\r\n\r\n    function updateRegistry(address loan, address owner) internal {\r\n        ownersToLoans[owner] = loan;\r\n        loansToOwners[loan] = owner;\r\n        loans.push(loan);\r\n    }\r\n\r\n    function canBorrow(address _account) external view override returns (bool) {\r\n        return loansToOwners[_account] != address(0);\r\n    }\r\n\r\n    function getLoanForOwner(address _user) external view override returns (address) {\r\n        return ownersToLoans[_user];\r\n    }\r\n\r\n    function getOwnerOfLoan(address _loan) external view override returns (address) {\r\n        return loansToOwners[_loan];\r\n    }\r\n\r\n    function getAllLoans() public view returns (address[] memory) {\r\n        return loans;\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override {}\r\n\r\n    /**\r\n     * @dev emitted after creating a loan by the owner\r\n     * @param accountAddress address of a new SmartLoanDiamondBeacon\r\n     * @param creator account creating a SmartLoanDiamondBeacon\r\n     * @param collateralAsset asset used as initial collateral\r\n     * @param collateralAmount amount of asset used as initial collateral\r\n     **/\r\n    event SmartLoanCreated(address indexed accountAddress, address indexed creator, bytes32 collateralAsset, uint256 collateralAmount);\r\n}"
    },
    "contracts/facets/UniswapV2DEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"../ReentrancyGuardKeccak.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"../lib/SolvencyMethods.sol\";\r\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\r\nimport \"../OnlyOwnerOrInsolvent.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\nimport \"../interfaces/IAssetsExchange.sol\";\r\n\r\ncontract UniswapV2DEXFacet is ReentrancyGuardKeccak, SolvencyMethods, OnlyOwnerOrInsolvent {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    function getProtocolID() pure internal virtual returns (bytes32) {\r\n        return \"\";\r\n    }\r\n\r\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\r\n        uint8 i = 0;\r\n        while(i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n\r\n    /**\r\n    * Swaps one asset with another\r\n    * @param _soldAsset asset to be sold\r\n    * @param _boughtAsset asset to be bought\r\n    * @param _exactSold exact amount of asset to be sold\r\n    * @param _minimumBought minimum amount of asset to be bought\r\n    **/\r\n    function swapAssets(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) internal recalculateAssetsExposure remainsSolvent returns (uint256[] memory) {\r\n        IERC20Metadata soldToken = getERC20TokenInstance(_soldAsset, true);\r\n        IERC20Metadata boughtToken = getERC20TokenInstance(_boughtAsset, false);\r\n\r\n        require(soldToken.balanceOf(address(this)) >= _exactSold, \"Not enough token to sell\");\r\n        address(soldToken).safeTransfer(getExchangeIntermediaryContract(), _exactSold);\r\n\r\n        IAssetsExchange exchange = IAssetsExchange(getExchangeIntermediaryContract());\r\n\r\n        uint256[] memory amounts = exchange.swap(address(soldToken), address(boughtToken), _exactSold, _minimumBought);\r\n\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        // Add asset to ownedAssets\r\n        address boughtAssetAddress = tokenManager.getAssetAddress(_boughtAsset, false);\r\n\r\n        if (boughtToken.balanceOf(address(this)) > 0) {\r\n            DiamondStorageLib.addOwnedAsset(_boughtAsset, boughtAssetAddress);\r\n        }\r\n\r\n        // Remove asset from ownedAssets if the asset balance is 0 after the swap\r\n        if (soldToken.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(_soldAsset);\r\n        }\r\n\r\n        emit Swap(msg.sender, _soldAsset, _boughtAsset, amounts[0], amounts[amounts.length - 1], block.timestamp);\r\n\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n    * Adds liquidity\r\n    **/\r\n    function addLiquidity(bytes32 _assetA, bytes32 _assetB, uint amountA, uint amountB, uint amountAMin, uint amountBMin) internal recalculateAssetsExposure remainsSolvent {\r\n        IERC20Metadata tokenA = getERC20TokenInstance(_assetA, false);\r\n        IERC20Metadata tokenB = getERC20TokenInstance(_assetB, false);\r\n\r\n        require(tokenA.balanceOf(address(this)) >= amountA, \"Not enough tokenA to provide\");\r\n        require(tokenB.balanceOf(address(this)) >= amountB, \"Not enough tokenB to provide\");\r\n\r\n        address(tokenA).safeTransfer(getExchangeIntermediaryContract(), amountA);\r\n        address(tokenB).safeTransfer(getExchangeIntermediaryContract(), amountB);\r\n\r\n        IAssetsExchange exchange = IAssetsExchange(getExchangeIntermediaryContract());\r\n\r\n        address lpTokenAddress;\r\n        uint liquidity;\r\n\r\n        (lpTokenAddress, amountA, amountB, liquidity)\r\n          = exchange.addLiquidity(address(tokenA), address(tokenB), amountA, amountB, amountAMin, amountBMin);\r\n\r\n        if (IERC20Metadata(lpTokenAddress).balanceOf(address(this)) > 0) {\r\n            bytes32 lpToken = calculateLpTokenSymbol(_assetA, _assetB);\r\n            DiamondStorageLib.addOwnedAsset(lpToken, lpTokenAddress);\r\n        }\r\n\r\n        // Remove asset from ownedAssets if the asset balance is 0 after the LP\r\n        if (tokenA.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(_assetA);\r\n        }\r\n\r\n        if (tokenB.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(_assetB);\r\n        }\r\n\r\n        emit AddLiquidity(msg.sender, lpTokenAddress, _assetA, _assetB, liquidity, amountA, amountB, block.timestamp);\r\n    }\r\n\r\n    /**\r\n    * Removes liquidity\r\n    **/\r\n    function removeLiquidity(bytes32 _assetA, bytes32 _assetB, uint liquidity, uint amountAMin, uint amountBMin) internal recalculateAssetsExposure onlyOwnerOrInsolvent{\r\n        IERC20Metadata tokenA = getERC20TokenInstance(_assetA, true);\r\n        IERC20Metadata tokenB = getERC20TokenInstance(_assetB, true);\r\n\r\n        IAssetsExchange exchange = IAssetsExchange(getExchangeIntermediaryContract());\r\n\r\n        address lpTokenAddress = exchange.getPair(address(tokenA), address(tokenB));\r\n        liquidity = Math.min(liquidity, IERC20(lpTokenAddress).balanceOf(address(this)));\r\n\r\n        lpTokenAddress.safeTransfer(getExchangeIntermediaryContract(), liquidity);\r\n\r\n        (uint amountA, uint amountB) = exchange.removeLiquidity(address(tokenA), address(tokenB), liquidity, amountAMin, amountBMin);\r\n\r\n        // Remove asset from ownedAssets if the asset balance is 0 after the LP\r\n        if (IERC20Metadata(lpTokenAddress).balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(calculateLpTokenSymbol(_assetA, _assetB));\r\n        }\r\n        DiamondStorageLib.addOwnedAsset(_assetA, address(tokenA));\r\n        DiamondStorageLib.addOwnedAsset(_assetB, address(tokenB));\r\n\r\n        emit RemoveLiquidity(msg.sender, lpTokenAddress, _assetA, _assetB, liquidity, amountA, amountB, block.timestamp);\r\n    }\r\n\r\n    function calculateLpTokenSymbol(bytes32 _assetA, bytes32 _assetB) internal pure returns (bytes32 name) {\r\n        (bytes32 token0, bytes32 token1) = _assetA < _assetB ? (_assetA, _assetB) : (_assetB, _assetA);\r\n        name = stringToBytes32(string.concat(\r\n                bytes32ToString(getProtocolID()),\r\n                '_',\r\n                bytes32ToString(token0),\r\n                '_',\r\n                bytes32ToString(token1),\r\n                '_LP'\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns address of DeltaPrime intermediary contract of UniswapV2-like exchange\r\n     **/\r\n    //TO BE OVERRIDDEN\r\n    function getExchangeIntermediaryContract() public virtual returns (address) {\r\n        return address(0);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after a swap of assets\r\n     * @param user the address of user making the purchase\r\n     * @param soldAsset sold by the user\r\n     * @param boughtAsset bought by the user\r\n     * @param maximumSold maximum to be sold\r\n     * @param minimumBought minimum to be bought\r\n     * @param timestamp time of the swap\r\n     **/\r\n    event Swap(address indexed user, bytes32 indexed soldAsset, bytes32 indexed boughtAsset, uint256 maximumSold, uint256 minimumBought, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after providing liquidity\r\n     * @param user the address of user providing liquidity\r\n     * @param lpToken the address LP token\r\n     * @param firstAsset first asset provided for liquidity\r\n     * @param secondAsset second asset provided for liquidity\r\n     * @param liquidity amount of liquidity (LP token) added\r\n     * @param firstAmount amount of the first asset used\r\n     * @param secondAmount amount of the second asset used\r\n     * @param timestamp time of the transaction\r\n     **/\r\n    event AddLiquidity(address indexed user, address indexed lpToken, bytes32 firstAsset, bytes32 secondAsset, uint liquidity, uint firstAmount, uint secondAmount, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after removing liquidity\r\n     * @param user the address of user providing liquidity\r\n     * @param lpToken the address LP token\r\n     * @param firstAsset first asset from LP position\r\n     * @param secondAsset second asset from LP position\r\n     * @param liquidity amount of liquidity (LP token) removed\r\n     * @param firstAmount amount of the first asset obtained\r\n     * @param secondAmount amount of the second asset obtained\r\n     * @param timestamp time of the transaction\r\n     **/\r\n    event RemoveLiquidity(address indexed user, address indexed lpToken, bytes32 firstAsset, bytes32 secondAsset, uint liquidity, uint firstAmount, uint secondAmount, uint256 timestamp);\r\n}"
    },
    "contracts/OnlyOwnerOrInsolvent.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Modified version of Openzeppelin (OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)) ReentrancyGuard\r\n// contract that uses keccak slots instead of the standard storage layout.\r\n\r\nimport {DiamondStorageLib} from \"./lib/DiamondStorageLib.sol\";\r\nimport \"./lib/SolvencyMethods.sol\";\r\nimport \"./facets/SmartLoanLiquidationFacet.sol\";\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Enforces ownership only if there is no liquidation ongoing\r\n */\r\nabstract contract OnlyOwnerOrInsolvent is SolvencyMethods {\r\n\r\n    /**\r\n     * @dev Enforces ownership only if there is no liquidation ongoing\r\n     */\r\n    modifier onlyOwnerOrInsolvent() {\r\n        bool wasSolvent = _isSolvent();\r\n        if (wasSolvent) {\r\n            DiamondStorageLib.enforceIsContractOwner();\r\n        } else {\r\n            require(SmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender), \"Only whitelisted accounts can perform this action\");\r\n        }\r\n\r\n        _;\r\n\r\n        if (wasSolvent) {\r\n            require(_isSolvent(), \"Must stay solvent\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "contracts/proxies/SmartLoanDiamondProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./openzeppelinVirtual/BeaconProxyVirtual.sol\";\r\n\r\n/**\r\n * @dev This is a copy of OpenZeppelin BeaconProxy (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol) contract.\r\n * The only difference is usage of overriding the ERC1967Upgrade._upgradeBeaconToAndCall and BeaconProxy._implementation() methods.\r\n */\r\n\r\ncontract SmartLoanDiamondProxy is BeaconProxyVirtual {\r\n    constructor(address beacon, bytes memory data) payable BeaconProxyVirtual(beacon, data) {}\r\n\r\n    /* ========== RECEIVE AVAX FUNCTION ========== */\r\n    receive() external payable override {}\r\n\r\n    /**\r\n     * @dev Returns the current implementation address of the associated beacon.\r\n     */\r\n    function _implementation() internal view virtual override returns (address) {\r\n        return IDiamondBeacon(_getBeacon()).implementation(msg.sig);\r\n    }\r\n\r\n    /**\r\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n     *\r\n     * Emits a {BeaconUpgraded} event.\r\n     */\r\n    function _upgradeBeaconToAndCall(\r\n        address newBeacon,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal override {\r\n        _setBeacon(newBeacon);\r\n        emit BeaconUpgraded(newBeacon);\r\n        if (data.length > 0 || forceCall) {\r\n            // 0xc4d66de8 = initialize(address owner)\r\n            Address.functionDelegateCall(IDiamondBeacon(newBeacon).implementation(0xc4d66de8), data);\r\n        }\r\n    }\r\n}"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "\r\n// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport { DiamondStorageLib } from \"../lib/DiamondStorageLib.sol\";\r\nimport \"../SmartLoansFactory.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract OwnershipFacet {\r\n    function proposeOwnershipTransfer(address _newOwner) external {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        require(_newOwner != msg.sender, \"Can't propose oneself as a contract owner\");\r\n        require(SmartLoansFactory(DeploymentConstants.getSmartLoansFactoryAddress()).getLoanForOwner(_newOwner) == address(0),\r\n            \"Can't propose an address that already has a loan\");\r\n        DiamondStorageLib.setProposedOwner(_newOwner);\r\n\r\n        emit OwnershipProposalCreated(msg.sender, _newOwner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(DiamondStorageLib.proposedOwner() == msg.sender, \"Only a proposed user can accept ownership\");\r\n        DiamondStorageLib.setContractOwner(msg.sender);\r\n        DiamondStorageLib.setProposedOwner(address(0));\r\n        SmartLoansFactory(DeploymentConstants.getSmartLoansFactoryAddress()).changeOwnership(msg.sender);\r\n\r\n        emit OwnershipProposalAccepted(msg.sender);\r\n    }\r\n\r\n    function owner() external view returns (address owner_) {\r\n        owner_ = DiamondStorageLib.contractOwner();\r\n    }\r\n\r\n    function proposedOwner() external view returns (address proposedOwner_) {\r\n        proposedOwner_ = DiamondStorageLib.proposedOwner();\r\n    }\r\n\r\n    function pauseAdmin() external view returns (address pauseAdmin) {\r\n        pauseAdmin = DiamondStorageLib.pauseAdmin();\r\n    }\r\n\r\n    function proposedPauseAdmin() external view returns (address proposedPauseAdmin) {\r\n        proposedPauseAdmin = DiamondStorageLib.proposedPauseAdmin();\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after creating a ownership transfer proposal by the owner\r\n     * @param owner address of the current owner\r\n     * @param proposed address of the proposed owner\r\n     **/\r\n    event OwnershipProposalCreated(address indexed owner, address indexed proposed);\r\n\r\n    /**\r\n     * @dev emitted after accepting a ownership transfer proposal by the new owner\r\n     * @param newOwner address of the new owner\r\n     **/\r\n    event OwnershipProposalAccepted(address indexed newOwner);\r\n}"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/proxies/openzeppelinVirtual/BeaconProxyVirtual.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/BeaconProxy.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\r\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\r\nimport \"./ERC1967UpgradeVirtual.sol\";\r\nimport \"../../interfaces/IDiamondBeacon.sol\";\r\n\r\n/**\r\n * @dev This is a copy of OpenZeppelin BeaconProxy (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol) contract.\r\n * The only difference is usage of ERC1967UpgradeVirtual contract that allows overriding the ERC1967Upgrade._upgradeBeaconToAndCall method and removing the obsolete BeaconProxy._setBeacon() method.\r\n */\r\ncontract BeaconProxyVirtual is Proxy, ERC1967UpgradeVirtual {\r\n    /**\r\n     * @dev Initializes the proxy with `beacon`.\r\n     *\r\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\r\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\r\n     * constructor.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `beacon` must be a contract with the interface {IDiamondBeacon}.\r\n     */\r\n    constructor(address beacon, bytes memory data) payable {\r\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\r\n        _upgradeBeaconToAndCall(beacon, data, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current beacon address.\r\n     */\r\n    function _beacon() internal view virtual returns (address) {\r\n        return _getBeacon();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation address of the associated beacon.\r\n     */\r\n    function _implementation() internal view virtual override returns (address) {\r\n        return IDiamondBeacon(_getBeacon()).implementation();\r\n    }\r\n}"
    },
    "contracts/proxies/openzeppelinVirtual/ERC1967UpgradeVirtual.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\r\nimport \"../../interfaces/IDiamondBeacon.sol\";\r\n\r\n/**\r\n * @dev This is a copy of OpenZeppelin ERC1967Upgrade (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/ERC1967/ERC1967Upgrade.sol) contract.\r\n * The only difference is the possibility of overriding the ERC1967Upgrade._upgradeBeaconToAndCall method.\r\n */\r\nabstract contract ERC1967UpgradeVirtual {\r\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\r\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _getImplementation() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCall(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _upgradeTo(newImplementation);\r\n        if (data.length > 0 || forceCall) {\r\n            Address.functionDelegateCall(newImplementation, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCallUUPS(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\r\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\r\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\r\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\r\n            _setImplementation(newImplementation);\r\n        } else {\r\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\r\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\r\n            } catch {\r\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\r\n            }\r\n            _upgradeToAndCall(newImplementation, data, forceCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _getAdmin() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     */\r\n    function _changeAdmin(address newAdmin) internal {\r\n        emit AdminChanged(_getAdmin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\r\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\r\n     */\r\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n\r\n    /**\r\n     * @dev Emitted when the beacon is upgraded.\r\n     */\r\n    event BeaconUpgraded(address indexed beacon);\r\n\r\n    /**\r\n     * @dev Returns the current beacon.\r\n     */\r\n    function _getBeacon() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\r\n     */\r\n    function _setBeacon(address newBeacon) internal {\r\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\r\n        require(\r\n            Address.isContract(IDiamondBeacon(newBeacon).implementation()),\r\n            \"ERC1967: beacon implementation is not a contract\"\r\n        );\r\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n     *\r\n     * Emits a {BeaconUpgraded} event.\r\n     */\r\n    function _upgradeBeaconToAndCall(\r\n        address newBeacon,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal virtual {\r\n        _setBeacon(newBeacon);\r\n        emit BeaconUpgraded(newBeacon);\r\n        if (data.length > 0 || forceCall) {\r\n            // 0xe1c7392a = init()\r\n            Address.functionDelegateCall(IDiamondBeacon(newBeacon).implementation(0xe1c7392a), data);\r\n        }\r\n    }\r\n}"
    },
    "contracts/upgraded/SmartLoansFactoryWithAccessNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 0fbd3d2132ce3d3a12c966ee5e6ffba53aae9d33;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../abstract/NFTAccess.sol\";\r\nimport \"../SmartLoansFactory.sol\";\r\n\r\ncontract SmartLoansFactoryWithAccessNFT is NFTAccess, SmartLoansFactory {\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override(SmartLoansFactory, OwnableUpgradeable) {}\r\n\r\n    function createLoan() public override hasNoLoan hasAccessNFT returns (SmartLoanDiamondBeacon) {\r\n        return super.createLoan();\r\n    }\r\n\r\n    function createAndFundLoan(bytes32 _fundedAsset, address _assetAddress, uint256 _amount) public override hasNoLoan hasAccessNFT returns (SmartLoanDiamondBeacon) {\r\n        return super.createAndFundLoan(_fundedAsset, _assetAddress, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/abstract/NFTAccess.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\r\n\r\nabstract contract NFTAccess is OwnableUpgradeable {\r\n    bytes32 internal constant ACCESS_NFT_SLOT = bytes32(uint256(keccak256('ACCESS_NFT_SLOT')) - 1);\r\n\r\n    function setAccessNFT(ERC721 nftAddress) external onlyOwner {\r\n        // Setting nftAddress to a address(0) removes the lock\r\n        if (address(nftAddress) != address(0)) {\r\n            require(AddressUpgradeable.isContract(address(nftAddress)), \"Cannot set nftAddress to a non-contract instance\");\r\n            (bool success, bytes memory result) = address(nftAddress).call(\r\n                abi.encodeWithSignature(\"balanceOf(address)\", msg.sender)\r\n            );\r\n            require(success && result.length > 0, \"Contract has to support the ERC721 balanceOf() interface\");\r\n        }\r\n\r\n        bytes32 slot = ACCESS_NFT_SLOT;\r\n        assembly {\r\n            sstore(slot, nftAddress)\r\n        }\r\n    }\r\n\r\n    function getAccessNFT() external view returns (ERC721 accessNFT) {\r\n        bytes32 slot = ACCESS_NFT_SLOT;\r\n        assembly {\r\n            accessNFT := sload(slot)\r\n        }\r\n    }\r\n\r\n    modifier hasAccessNFT {\r\n        bytes32 slot = ACCESS_NFT_SLOT;\r\n        ERC721 accessNFT;\r\n        assembly {\r\n            accessNFT := sload(slot)\r\n        }\r\n        if (address(accessNFT) != address(0)) {\r\n            require(accessNFT.balanceOf(msg.sender) > 0, \"Access NFT required\");\r\n        }\r\n        _;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/upgraded/PoolWithAccessNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 0fbd3d2132ce3d3a12c966ee5e6ffba53aae9d33;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../abstract/NFTAccess.sol\";\r\nimport \"../Pool.sol\";\r\n\r\ncontract PoolWithAccessNFT is NFTAccess, Pool {\r\n    using TransferHelper for address payable;\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override(Pool, OwnableUpgradeable) {}\r\n\r\n    /**\r\n      * Requires access NFT\r\n      * Deposits the message value\r\n      * It updates user deposited balance, total deposited and rates\r\n    **/\r\n    function deposit(uint256 amount) public override hasAccessNFT {\r\n        super.deposit(amount);\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockUpgradedPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../Pool.sol\";\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\n/**\r\n * @title MockUpgradedPool\r\n * @dev A mock implementation of a Pool to check if upgrade mechanism correctly update contrac logic\r\n */\r\ncontract MockUpgradedPool is Pool {\r\n    /**\r\n     * Dummy implementation recording double deposits\r\n     * used to test upgrade of contract logic\r\n     **/\r\n    function deposit(uint256 amount) public override nonReentrant {\r\n        _accumulateDepositInterest(msg.sender);\r\n\r\n        _transferToPool(msg.sender, amount);\r\n\r\n        //change to original deposit method\r\n        _mint(msg.sender, amount * 2);\r\n        _updateRates();\r\n\r\n        emit Deposit(msg.sender, amount, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "contracts/proxies/tup/TokenManagerTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract TokenManagerTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/SmartLoansFactoryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract SmartLoansFactoryTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/celo/UbeswapIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract UbeswapIntermediaryTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/celo/CeloPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 97d6cc3cb60bfd6feda4ea784b13bf0e7daac710;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract CeloPoolTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/celo/CeloDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract CeloDepositIndexTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/celo/CeloBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract CeloBorrowIndexTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/avalanche/WavaxPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract WavaxPoolTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/avalanche/WavaxDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract WavaxDepositIndexTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/avalanche/WavaxBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract WavaxBorrowIndexTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/avalanche/UsdcPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract UsdcPoolTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/avalanche/UsdcDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract UsdcDepositIndexTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/avalanche/UsdcBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract UsdcBorrowIndexTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/avalanche/TraderJoeIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract TraderJoeIntermediaryTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/proxies/tup/avalanche/PangolinIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\r\n\r\ncontract PangolinIntermediaryTUP is TransparentUpgradeableProxy {\r\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\r\n}\r\n"
    },
    "contracts/TokenManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./lib/Bytes32EnumerableMap.sol\";\r\nimport \"./interfaces/IBorrowersRegistry.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\ncontract TokenManager is OwnableUpgradeable {\r\n    /**\r\n     * For adding supported assets\r\n     **/\r\n    struct Asset {\r\n        bytes32 asset;\r\n        address assetAddress;\r\n        uint256 debtCoverage;\r\n    }\r\n\r\n    /**\r\n     * For adding supported lending pools\r\n     **/\r\n    struct poolAsset {\r\n        bytes32 asset;\r\n        address poolAddress;\r\n    }\r\n\r\n    struct Exposure {\r\n        uint256 current;\r\n        uint256 max; // Setting max to 0 means no exposure limitations.\r\n    }\r\n\r\n    using EnumerableMap for EnumerableMap.Bytes32ToAddressMap;\r\n\r\n    uint256 private constant _NOT_SUPPORTED = 0;\r\n    uint256 private constant _INACTIVE = 1;\r\n    uint256 private constant _ACTIVE = 2;\r\n\r\n    // Stores an asset's bytes32 symbol representation to pool's address mapping\r\n    EnumerableMap.Bytes32ToAddressMap private assetToPoolAddress;\r\n    // Stores an asset's bytes32 symbol representation to asset's address mapping\r\n    EnumerableMap.Bytes32ToAddressMap private assetToTokenAddress;\r\n    mapping(address => bytes32) public tokenAddressToSymbol;\r\n    mapping(address => uint256) private tokenPositionInList;\r\n    // used for defining different leverage ratios for tokens\r\n    mapping(address => uint256) public debtCoverage;\r\n    address[] public supportedTokensList;\r\n\r\n    mapping(address => uint256) public tokenToStatus;\r\n    // used for defining different leverage ratios for staked assets\r\n    mapping(bytes32 => uint256) public debtCoverageStaked;\r\n\r\n    mapping(bytes32 => bytes32) public identifierToExposureGroup;\r\n    mapping(bytes32 => Exposure) public groupToExposure;\r\n\r\n    function initialize(Asset[] memory tokenAssets, poolAsset[] memory poolAssets) external initializer {\r\n        __Ownable_init();\r\n\r\n        addTokenAssets(tokenAssets);\r\n        addPoolAssets(poolAssets);\r\n    }\r\n\r\n    function getAllPoolAssets() public view returns (bytes32[] memory result) {\r\n        return assetToPoolAddress._inner._keys._inner._values;\r\n    }\r\n\r\n    function getSupportedTokensAddresses() public view returns (address[] memory) {\r\n        return supportedTokensList;\r\n    }\r\n\r\n    function getAllTokenAssets() public view returns (bytes32[] memory result) {\r\n        return assetToTokenAddress._inner._keys._inner._values;\r\n    }\r\n\r\n    /**\r\n    * Returns address of an asset\r\n    **/\r\n    function getAssetAddress(bytes32 _asset, bool allowInactive) public view returns (address) {\r\n        (, address assetAddress) = assetToTokenAddress.tryGet(_asset);\r\n        require(assetAddress != address(0), \"Asset not supported.\");\r\n        if (!allowInactive) {\r\n            require(tokenToStatus[assetAddress] == _ACTIVE, \"Asset inactive\");\r\n        }\r\n\r\n        return assetAddress;\r\n    }\r\n\r\n    /**\r\n    * Returns address of an asset's lending pool\r\n    **/\r\n    function getPoolAddress(bytes32 _asset) public view returns (address) {\r\n        (, address assetAddress) = assetToPoolAddress.tryGet(_asset);\r\n        require(assetAddress != address(0), \"Pool asset not supported.\");\r\n\r\n        return assetAddress;\r\n    }\r\n\r\n    function increaseProtocolExposure(bytes32 assetIdentifier, uint256 exposureIncrease) public onlyPrimeAccountOrOwner {\r\n        bytes32 group = identifierToExposureGroup[assetIdentifier];\r\n        if(group != \"\"){\r\n            Exposure storage exposure = groupToExposure[group];\r\n            if(exposure.max != 0){\r\n                exposure.current += exposureIncrease;\r\n                require(exposure.current <= exposure.max, \"Max asset exposure breached\");\r\n                emit ProtocolExposureChanged(msg.sender, group, exposureIncrease, block.timestamp);\r\n            }\r\n        }\r\n    }\r\n\r\n    function decreaseProtocolExposure(bytes32 assetIdentifier, uint256 exposureDecrease) public onlyPrimeAccountOrOwner {\r\n        bytes32 group = identifierToExposureGroup[assetIdentifier];\r\n        if(group != \"\"){\r\n            Exposure storage exposure = groupToExposure[group];\r\n            if(exposure.max != 0){\r\n                exposure.current = exposure.current <= exposureDecrease ? 0 : exposure.current - exposureDecrease;\r\n                emit ProtocolExposureChanged(msg.sender, group, exposureDecrease, block.timestamp);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setMaxProtocolsExposure(bytes32[] memory groupIdentifiers, uint256[] memory maxExposures) public onlyOwner {\r\n        require(groupIdentifiers.length == maxExposures.length, \"Arrays lengths mismatch\");\r\n        for (uint256 i = 0; i < groupIdentifiers.length; i++) {\r\n            _setMaxProtocolExposure(groupIdentifiers[i], maxExposures[i]);\r\n        }\r\n    }\r\n\r\n    function _setMaxProtocolExposure(bytes32 groupIdentifier, uint256 maxExposure) internal {\r\n        require(groupIdentifier != \"\", \"Cannot set an empty string asset.\");\r\n        uint256 prevExposure = groupToExposure[groupIdentifier].max;\r\n        groupToExposure[groupIdentifier].max = maxExposure;\r\n\r\n        emit ProtocolExposureSet(msg.sender, groupIdentifier, prevExposure, maxExposure, groupToExposure[groupIdentifier].current , block.timestamp);\r\n    }\r\n\r\n    function setIdentifiersToExposureGroups(bytes32[] memory identifiers, bytes32[] memory exposureGroups) public onlyOwner {\r\n        require(identifiers.length == exposureGroups.length, \"Arrays lengths mismatch\");\r\n        for(uint i=0; i<identifiers.length; i++){\r\n            identifierToExposureGroup[identifiers[i]] = exposureGroups[i];\r\n            emit IdentifierToExposureGroupSet(msg.sender, identifiers[i], exposureGroups[i], block.timestamp);\r\n        }\r\n\r\n    }\r\n\r\n    function addPoolAssets(poolAsset[] memory poolAssets) public onlyOwner {\r\n        for (uint256 i = 0; i < poolAssets.length; i++) {\r\n            _addPoolAsset(poolAssets[i].asset, poolAssets[i].poolAddress);\r\n        }\r\n    }\r\n\r\n    function _addPoolAsset(bytes32 _asset, address _poolAddress) internal {\r\n        require(Address.isContract(_poolAddress), \"TokenManager: Pool must be a contract\");\r\n        require(!assetToPoolAddress.contains(_asset), \"Asset's pool already exists\");\r\n        assetToPoolAddress.set(_asset, _poolAddress);\r\n        emit PoolAssetAdded(msg.sender, _asset, _poolAddress, block.timestamp);\r\n    }\r\n\r\n    function addTokenAssets(Asset[] memory tokenAssets) public onlyOwner {\r\n        for (uint256 i = 0; i < tokenAssets.length; i++) {\r\n            _addTokenAsset(tokenAssets[i].asset, tokenAssets[i].assetAddress, tokenAssets[i].debtCoverage);\r\n        }\r\n    }\r\n\r\n    function isTokenAssetActive(address token) external view returns(bool) {\r\n        return tokenToStatus[token] == 2;\r\n    }\r\n\r\n    function activateToken(address token) public onlyOwner {\r\n        require(tokenToStatus[token] == _INACTIVE, \"Must be inactive\");\r\n        tokenToStatus[token] = _ACTIVE;\r\n        emit TokenAssetActivated(msg.sender, token, block.timestamp);\r\n    }\r\n\r\n    function deactivateToken(address token) public onlyOwner {\r\n        require(tokenToStatus[token] == _ACTIVE, \"Must be active\");\r\n        tokenToStatus[token] = _INACTIVE;\r\n        emit TokenAssetDeactivated(msg.sender, token, block.timestamp);\r\n    }\r\n\r\n    function _addTokenAsset(bytes32 _asset, address _tokenAddress, uint256 _debtCoverage) internal {\r\n        require(_asset != \"\", \"Cannot set an empty string asset.\");\r\n        require(_tokenAddress != address(0), \"Cannot set an empty address.\");\r\n        require(!assetToTokenAddress.contains(_asset), \"Asset's token already exists\");\r\n        require(tokenAddressToSymbol[_tokenAddress] == 0, \"Asset address is already in use\");\r\n        setDebtCoverage(_tokenAddress, _debtCoverage);\r\n\r\n        assetToTokenAddress.set(_asset, _tokenAddress);\r\n        tokenAddressToSymbol[_tokenAddress] = _asset;\r\n        tokenToStatus[_tokenAddress] = _ACTIVE;\r\n\r\n        supportedTokensList.push(_tokenAddress);\r\n        tokenPositionInList[_tokenAddress] = supportedTokensList.length - 1;\r\n\r\n        emit TokenAssetAdded(msg.sender, _asset, _tokenAddress, block.timestamp);\r\n    }\r\n\r\n    function _removeTokenFromList(address tokenToRemove) internal {\r\n        // Move last address token to the `tokenToRemoveIndex` position (index of an asset that is being removed) in the address[] supportedTokensList\r\n        // and update map(address=>uint256) tokenPostitionInList if the token is not already the last element\r\n        uint256 tokenToRemoveIndex = tokenPositionInList[tokenToRemove];\r\n        if (tokenToRemoveIndex != (supportedTokensList.length - 1)) {\r\n            address currentLastToken = supportedTokensList[supportedTokensList.length - 1];\r\n            tokenPositionInList[currentLastToken] = tokenToRemoveIndex;\r\n            supportedTokensList[tokenToRemoveIndex] = currentLastToken;\r\n        }\r\n        // Remove last element - that is either the token that is being removed (if was already at the end)\r\n        // or some other asset that at this point was already copied to the `index` positon\r\n        supportedTokensList.pop();\r\n        tokenPositionInList[tokenToRemove] = 0;\r\n    }\r\n\r\n    function removeTokenAssets(bytes32[] memory _tokenAssets) public onlyOwner {\r\n        for (uint256 i = 0; i < _tokenAssets.length; i++) {\r\n            _removeTokenAsset(_tokenAssets[i]);\r\n        }\r\n    }\r\n\r\n    function _removeTokenAsset(bytes32 _tokenAsset) internal {\r\n        address tokenAddress = getAssetAddress(_tokenAsset, true);\r\n        EnumerableMap.remove(assetToTokenAddress, _tokenAsset);\r\n        tokenAddressToSymbol[tokenAddress] = 0;\r\n        tokenToStatus[tokenAddress] = _NOT_SUPPORTED;\r\n        debtCoverage[tokenAddress] = 0;\r\n        _removeTokenFromList(tokenAddress);\r\n        emit TokenAssetRemoved(msg.sender, _tokenAsset, block.timestamp);\r\n    }\r\n\r\n    function removePoolAssets(bytes32[] memory _poolAssets) public onlyOwner {\r\n        for (uint256 i = 0; i < _poolAssets.length; i++) {\r\n            _removePoolAsset(_poolAssets[i]);\r\n        }\r\n    }\r\n\r\n    function _removePoolAsset(bytes32 _poolAsset) internal {\r\n        address poolAddress = getPoolAddress(_poolAsset);\r\n        EnumerableMap.remove(assetToPoolAddress, _poolAsset);\r\n        emit PoolAssetRemoved(msg.sender, _poolAsset, poolAddress, block.timestamp);\r\n    }\r\n\r\n    function setDebtCoverage(address token, uint256 coverage) public onlyOwner {\r\n        //LTV must be lower than 5\r\n        require(coverage <= 0.833333333333333333e18, 'Debt coverage higher than maximum acceptable');\r\n        debtCoverage[token] = coverage;\r\n    }\r\n\r\n    function setDebtCoverageStaked(bytes32 stakedAsset, uint256 coverage) public onlyOwner {\r\n        //LTV must be lower than 5\r\n        require(coverage <= 0.833333333333333333e18, 'Debt coverage higher than maximum acceptable');\r\n        debtCoverageStaked[stakedAsset] = coverage;\r\n    }\r\n\r\n    function getSmartLoansFactoryAddress() public view virtual returns (address) {\r\n        return 0x3Ea9D480295A73fd2aF95b4D96c2afF88b21B03D;\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override {}\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyPrimeAccountOrOwner() {\r\n        IBorrowersRegistry borrowersRegistry = IBorrowersRegistry(getSmartLoansFactoryAddress());\r\n        require(borrowersRegistry.canBorrow(msg.sender) || owner() == _msgSender(), \"Only PrimeAccount or owner can change protocol exposure\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after changing current protocol exposure\r\n     * @param performer an address of the wallet changing the exposure\r\n     * @param identifier group identifier\r\n     * @param newExposure new current protocol exposure\r\n     * @param timestamp time of associating identifier with a exposure group\r\n     **/\r\n    event ProtocolExposureChanged(address indexed performer, bytes32 indexed identifier, uint256 newExposure, uint256 timestamp);\r\n\r\n\r\n    /**\r\n     * @dev emitted after associating identifier with a exposure group\r\n     * @param performer an address of the wallet setting max exposure\r\n     * @param identifier asset identifier\r\n     * @param exposureGroup exposure group identifier\r\n     * @param timestamp time of associating identifier with a exposure group\r\n     **/\r\n    event IdentifierToExposureGroupSet(address indexed performer, bytes32 indexed identifier, bytes32 indexed exposureGroup, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after setting max exposure for a given protocol.\r\n     * @param performer an address of the wallet setting max exposure\r\n     * @param groupIdentifier exposure group identifier\r\n     * @param prevMaxExposure previous max protocol exposure\r\n     * @param newMaxExposure new max protocol exposure\r\n     * @param currentExposure current protocol exposure\r\n     * @param timestamp time of setting max exposure\r\n     **/\r\n    event ProtocolExposureSet(address indexed performer, bytes32 indexed groupIdentifier, uint256 prevMaxExposure, uint256 newMaxExposure, uint256 currentExposure, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after adding a token asset\r\n     * @param performer an address of the wallet adding a token asset\r\n     * @param tokenAsset token asset\r\n     * @param assetAddress an address of the token asset\r\n     * @param timestamp time of adding a token asset\r\n     **/\r\n    event TokenAssetAdded(address indexed performer, bytes32 indexed tokenAsset, address assetAddress, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after activating a token asset\r\n     * @param performer an address of the wallet activating a token asset\r\n     * @param assetAddress an address of the token asset\r\n     * @param timestamp time of activating a token asset\r\n     **/\r\n    event TokenAssetActivated(address indexed performer, address assetAddress, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after deactivating a token asset\r\n     * @param performer an address of the wallet deactivating a token asset\r\n     * @param assetAddress an address of the token asset\r\n     * @param timestamp time of deactivating a token asset\r\n     **/\r\n    event TokenAssetDeactivated(address indexed performer, address assetAddress, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after removing a token asset\r\n     * @param performer an address of the wallet removing a token asset\r\n     * @param tokenAsset token asset\r\n     * @param timestamp time a token asset removal\r\n     **/\r\n    event TokenAssetRemoved(address indexed performer, bytes32 indexed tokenAsset, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after adding a pool asset\r\n     * @param performer an address of wallet adding the pool asset\r\n     * @param poolAsset pool asset\r\n     * @param poolAddress an address of the pool asset\r\n     * @param timestamp time of the pool asset addition\r\n     **/\r\n    event PoolAssetAdded(address indexed performer, bytes32 indexed poolAsset, address poolAddress, uint256 timestamp);\r\n\r\n    /**\r\n     * @dev emitted after removing a pool asset\r\n     * @param performer an address of wallet removing the pool asset\r\n     * @param poolAsset pool asset\r\n     * @param poolAddress an address of the pool asset\r\n     * @param timestamp time of a pool asset removal\r\n     **/\r\n    event PoolAssetRemoved(address indexed performer, bytes32 indexed poolAsset, address poolAddress, uint256 timestamp);\r\n}\r\n"
    },
    "contracts/LinearIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 97d6cc3cb60bfd6feda4ea784b13bf0e7daac710;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\nimport \"./interfaces/IIndex.sol\";\r\n\r\n/**\r\n * LinearIndex\r\n * The contract contains logic for time-based index recalculation with minimal memory footprint.\r\n * It could be used as a base building block for any index-based entities like deposits and loans.\r\n * The index is updated on a linear basis to the compounding happens when a user decide to accumulate the interests\r\n **/\r\ncontract LinearIndex is IIndex, OwnableUpgradeable {\r\n\r\n    uint256 private constant SECONDS_IN_YEAR = 365 days;\r\n    uint256 private constant BASE_RATE = 1e18;\r\n\r\n    uint256 public index;\r\n    uint256 public indexUpdateTime;\r\n\r\n    mapping(uint256 => uint256) prevIndex;\r\n    mapping(address => uint256) userUpdateTime;\r\n\r\n    uint256 public rate;\r\n\r\n    function initialize(address owner_) external initializer {\r\n        index = BASE_RATE;\r\n        indexUpdateTime = block.timestamp;\r\n\r\n        __Ownable_init();\r\n        if (address(owner_) != address(0)) {\r\n            transferOwnership(owner_);\r\n        }\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * Sets the new rate\r\n     * Before the new rate is set, the index is updated accumulating interest\r\n     * @dev _rate the value of updated rate\r\n   **/\r\n    function setRate(uint256 _rate) public override onlyOwner {\r\n        updateIndex();\r\n        rate = _rate;\r\n        emit RateUpdated(rate, block.timestamp);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Updates user index\r\n     * It persists the update time and the update index time->index mapping\r\n     * @dev user address of the index owner\r\n   **/\r\n    function updateUser(address user) public override onlyOwner {\r\n        userUpdateTime[user] = block.timestamp;\r\n        prevIndex[block.timestamp] = getIndex();\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Gets current value of the linear index\r\n     * It recalculates the value on-demand without updating the storage\r\n     **/\r\n    function getIndex() public view override returns (uint256) {\r\n        uint256 period = block.timestamp - indexUpdateTime;\r\n        if (period > 0) {\r\n            return index * getLinearFactor(period) / 1e27;\r\n        } else {\r\n            return index;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the user value recalculated to the current index\r\n     * It recalculates the value on-demand without updating the storage\r\n     * Ray operations round up the result, but it is only an issue for very small values (with an order of magnitude\r\n     * of 1 Wei)\r\n     **/\r\n    function getIndexedValue(uint256 value, address user) public view override returns (uint256) {\r\n        uint256 userTime = userUpdateTime[user];\r\n        uint256 prevUserIndex = userTime == 0 ? BASE_RATE : prevIndex[userTime];\r\n\r\n        return value * getIndex() / prevUserIndex;\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function updateIndex() internal {\r\n        prevIndex[indexUpdateTime] = index;\r\n\r\n        index = getIndex();\r\n        indexUpdateTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * Returns a linear factor in Ray\r\n     **/\r\n    function getLinearFactor(uint256 period) virtual internal view returns (uint256) {\r\n        return rate * period * 1e9 / SECONDS_IN_YEAR + 1e27;\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override {}\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @dev Emitted after updating the current rate\r\n     * @param updatedRate the value of updated rate\r\n     * @param timestamp of the rate update\r\n     **/\r\n    event RateUpdated(uint256 updatedRate, uint256 timestamp);\r\n}"
    },
    "contracts/deployment/avalanche/WavaxDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../LinearIndex.sol\";\r\n\r\ncontract WavaxDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/WavaxBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../LinearIndex.sol\";\r\n\r\ncontract WavaxBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/UsdcDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../LinearIndex.sol\";\r\n\r\ncontract UsdcDepositIndex is LinearIndex {}"
    },
    "contracts/CompoundingIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./lib/WadRayMath.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./interfaces/IIndex.sol\";\r\n\r\n/**\r\n * CompoundingIndex\r\n * The contract contains logic for time-based index recalculation with minimal memory footprint.\r\n * It could be used as a base building block for any index-based entities like deposits and loans.\r\n **/\r\ncontract CompoundingIndex is IIndex, Ownable {\r\n    using WadRayMath for uint256;\r\n\r\n    uint256 private constant SECONDS_IN_YEAR = 365 days;\r\n    uint256 private constant BASE_RATE = 1e18;\r\n\r\n    uint256 public index = BASE_RATE;\r\n    uint256 public indexUpdateTime = block.timestamp;\r\n\r\n    mapping(uint256 => uint256) prevIndex;\r\n    mapping(address => uint256) userUpdateTime;\r\n\r\n    uint256 public rate;\r\n\r\n    constructor(address owner_) {\r\n        if (address(owner_) != address(0)) {\r\n            transferOwnership(owner_);\r\n        }\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * Sets the new rate\r\n     * Before the new rate is set, the index is updated accumulating interest\r\n     * @dev _rate the value of updated rate\r\n     **/\r\n    function setRate(uint256 _rate) public override onlyOwner {\r\n        updateIndex();\r\n        rate = _rate;\r\n        emit RateUpdated(rate, block.timestamp);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Updates user index\r\n     * It persists the update time and the update index time->index mapping\r\n     * @dev user address of the index owner\r\n     **/\r\n    function updateUser(address user) public override onlyOwner {\r\n        userUpdateTime[user] = block.timestamp;\r\n        prevIndex[block.timestamp] = getIndex();\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Gets current value of the compounding index\r\n     * It recalculates the value on-demand without updating the storage\r\n     **/\r\n    function getIndex() public view override returns (uint256) {\r\n        uint256 period = block.timestamp - indexUpdateTime;\r\n        if (period > 0) {\r\n            return index.wadToRay().rayMul(getCompoundedFactor(period)).rayToWad();\r\n        } else {\r\n            return index;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the user value recalculated to the current index\r\n     * It recalculates the value on-demand without updating the storage\r\n     * Ray operations round up the result, but it is only an issue for very small values (with an order of magnitude\r\n     * of 1 Wei)\r\n     **/\r\n    function getIndexedValue(uint256 value, address user) public view override returns (uint256) {\r\n        uint256 userTime = userUpdateTime[user];\r\n        uint256 prevUserIndex = userTime == 0 ? BASE_RATE : prevIndex[userTime];\r\n\r\n        return value.wadToRay().rayMul(getIndex().wadToRay()).rayDiv(prevUserIndex.wadToRay()).rayToWad();\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function updateIndex() internal {\r\n        prevIndex[indexUpdateTime] = index;\r\n\r\n        index = getIndex();\r\n        indexUpdateTime = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * Returns compounded factor in Ray\r\n     **/\r\n    function getCompoundedFactor(uint256 period) internal view returns (uint256) {\r\n        return ((rate.wadToRay() / SECONDS_IN_YEAR) + WadRayMath.ray()).rayPow(period);\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @dev Emitted after updating the current rate\r\n     * @param updatedRate the value of updated rate\r\n     * @param timestamp of the rate update\r\n     **/\r\n    event RateUpdated(uint256 updatedRate, uint256 timestamp);\r\n}\r\n"
    },
    "contracts/lib/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL3\r\npragma solidity 0.8.17;\r\n\r\n/******************\r\n@title WadRayMath library\r\n@author Aave\r\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\r\n@dev https://github.com/aave/aave-protocol/blob/master/contracts/libraries/WadRayMath.sol\r\n */\r\n\r\nlibrary WadRayMath {\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant halfWAD = WAD / 2;\r\n\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant halfRAY = RAY / 2;\r\n\r\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\r\n\r\n    function ray() internal pure returns (uint256) {\r\n        return RAY;\r\n    }\r\n\r\n    function wad() internal pure returns (uint256) {\r\n        return WAD;\r\n    }\r\n\r\n    function halfRay() internal pure returns (uint256) {\r\n        return halfRAY;\r\n    }\r\n\r\n    function halfWad() internal pure returns (uint256) {\r\n        return halfWAD;\r\n    }\r\n\r\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        //return halfWAD.add(a.mul(b)).div(WAD);\r\n        return (halfWAD + (a * b)) / WAD;\r\n    }\r\n\r\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        //return halfB.add(a.mul(WAD)).div(b);\r\n        return (halfB + (a * WAD)) / b;\r\n    }\r\n\r\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        //return halfRAY.add(a.mul(b)).div(RAY);\r\n        return (halfRAY + (a * b)) / RAY;\r\n    }\r\n\r\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 halfB = b / 2;\r\n\r\n        //return halfB.add(a.mul(RAY)).div(b);\r\n        return (halfB + (a * RAY)) / b;\r\n    }\r\n\r\n    function rayToWad(uint256 a) internal pure returns (uint256) {\r\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\r\n\r\n        //return halfRatio.add(a).div(WAD_RAY_RATIO);\r\n        return (halfRatio + a) / WAD_RAY_RATIO;\r\n    }\r\n\r\n    function wadToRay(uint256 a) internal pure returns (uint256) {\r\n        //return a.mul(WAD_RAY_RATIO);\r\n        return a * WAD_RAY_RATIO;\r\n    }\r\n\r\n    /**\r\n     * @dev calculates base^exp. The code uses the ModExp precompile\r\n     */\r\n    //solium-disable-next-line\r\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rayMul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rayMul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockVariableUtilisationRatesCalculatorChangedOffset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 48991ca286a107aedf142ae9fd21b421b08f5025;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/IRatesCalculator.sol\";\r\n\r\n/**\r\n * @title MockVariableUtilisationRatesCalculatorChangedOffset\r\n * @dev Contract which calculates the interest rates based on pool utilisation.\r\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\r\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\r\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\r\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\r\n **/\r\ncontract MockVariableUtilisationRatesCalculatorChangedOffset is IRatesCalculator, Ownable {\r\n    uint256 public constant SLOPE_1 = 0;\r\n    uint256 public constant OFFSET_1 = 0.05e18;\r\n\r\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\r\n\r\n    uint256 public constant SLOPE_2 = 0.45e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_2 = 0.24e18;\r\n\r\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\r\n\r\n    uint256 public constant SLOPE_3 = 3.15e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_3 = 2.4e18;\r\n\r\n    // BREAKPOINT must be lower than 1e18\r\n    uint256 public constant MAX_RATE = 0.75e18;\r\n\r\n    //accuracy of 1e18\r\n    uint256 public depositRateFactor = 1e18 - 1e12;\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Returns the pool utilisation, which is a ratio between loans and deposits\r\n     * utilisation = value_of_loans / value_of_deposits\r\n     * @param _totalLoans total value of loans\r\n     * @param _totalDeposits total value of deposits\r\n     **/\r\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\r\n        if (_totalDeposits == 0) return 0;\r\n\r\n        return (_totalLoans * 1e18) / _totalDeposits;\r\n    }\r\n\r\n    /**\r\n     * Returns the current deposit rate\r\n     * The value is based on the current borrowing rate and satisfies the invariant:\r\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\r\n     * @param _totalLoans total value of loans\r\n     * @param _totalDeposits total value of deposits\r\n     **/\r\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\r\n        if (_totalDeposits == 0) return 0;\r\n\r\n        if (_totalLoans >= _totalDeposits) {\r\n            return MAX_RATE * depositRateFactor / 1e18;\r\n        } else {\r\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * depositRateFactor * _totalLoans / (_totalDeposits * 1e18);\r\n            return rate;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the current borrowing rate\r\n     * The value is based on the pool utilisation according to the piecewise linear formula:\r\n     * 1) for pool utilisation lower than or equal to breakpoint:\r\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\r\n     * 2) for pool utilisation greater than breakpoint:\r\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\r\n     * @param totalLoans total value of loans\r\n     * @param totalDeposits total value of deposits\r\n     **/\r\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\r\n        if (totalDeposits == 0) return OFFSET_1;\r\n\r\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\r\n\r\n        if (poolUtilisation >= 1e18) {\r\n            return MAX_RATE;\r\n        } else if (poolUtilisation <= BREAKPOINT_1) {\r\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\r\n        } else if (poolUtilisation <= BREAKPOINT_2) {\r\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\r\n        } else {\r\n            // full formula derived from piecewise linear function calculation except for SLOPE_2 subtraction (separated for\r\n            // unsigned integer safety check)\r\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\r\n        }\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n    /**\r\n     * Sets deposit rate factor\r\n     * This factor is needed to account for arithmetic inaccuracy and keep pool balanced. Should be close to 1000\r\n     * @param factor total value of loans\r\n     **/\r\n    function setDepositRateFactor(uint256 factor) external onlyOwner {\r\n        depositRateFactor = factor;\r\n    }\r\n}"
    },
    "contracts/mock/MockVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/IRatesCalculator.sol\";\r\n\r\n/**\r\n * @title MockVariableUtilisationRatesCalculator\r\n * @dev Contract which calculates the interest rates based on pool utilisation.\r\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\r\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\r\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\r\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\r\n **/\r\ncontract MockVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\r\n    uint256 public constant SLOPE_1 = 0;\r\n    uint256 public constant OFFSET_1 = 0.03e18;\r\n\r\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\r\n\r\n    uint256 public constant SLOPE_2 = 0.45e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_2 = 0.24e18;\r\n\r\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\r\n\r\n    uint256 public constant SLOPE_3 = 3.15e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_3 = 2.4e18;\r\n\r\n    // BREAKPOINT must be lower than 1e18\r\n    uint256 public constant MAX_RATE = 0.75e18;\r\n\r\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\r\n    //profit generation\r\n    uint256 public spread = 1e12;\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Returns the pool utilisation, which is a ratio between loans and deposits\r\n     * utilisation = value_of_loans / value_of_deposits\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\r\n        if (_totalDeposits == 0) return 0;\r\n\r\n        return (_totalLoans * 1e18) / _totalDeposits;\r\n    }\r\n\r\n    /**\r\n     * Returns the current deposit rate\r\n     * The value is based on the current borrowing rate and satisfies the invariant:\r\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\r\n        if (_totalDeposits == 0) return 0;\r\n\r\n        if (_totalLoans >= _totalDeposits) {\r\n            return MAX_RATE * (1e18 - spread) / 1e18;\r\n        } else {\r\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\r\n            return rate;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the current borrowing rate\r\n     * The value is based on the pool utilisation according to the piecewise linear formula:\r\n     * 1) for pool utilisation lower than or equal to breakpoint:\r\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\r\n     * 2) for pool utilisation greater than breakpoint:\r\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\r\n        if (totalDeposits == 0) return OFFSET_1;\r\n\r\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\r\n\r\n        if (poolUtilisation >= 1e18) {\r\n            return MAX_RATE;\r\n        } else if (poolUtilisation <= BREAKPOINT_1) {\r\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\r\n        } else if (poolUtilisation <= BREAKPOINT_2) {\r\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\r\n        } else {\r\n            // full formula derived from piecewise linear function calculation except for SLOPE_2 subtraction (separated for\r\n            // unsigned integer safety check)\r\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\r\n        }\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n    /**\r\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\r\n     * @param _spread spread defined by user\r\n     **/\r\n    function setSpread(uint256 _spread) external onlyOwner {\r\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\r\n        spread = _spread;\r\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override {}\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @dev emitted after changing the spread\r\n     * @param performer an address of wallet setting a new spread\r\n     * @param newSpread new spread\r\n     * @param timestamp time of a spread change\r\n     **/\r\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\r\n}"
    },
    "contracts/deployment/avalanche/WavaxVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: edb582f05f0fb0098ca7ee750c8fde8a8032d991;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../../interfaces/IRatesCalculator.sol\";\r\n\r\n/**\r\n * @title WavaxVariableUtilisationRatesCalculator\r\n * @dev Contract which calculates the interest rates based on pool utilisation.\r\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\r\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\r\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\r\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\r\n **/\r\ncontract WavaxVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\r\n    uint256 public constant SLOPE_1 = 0.125e18;\r\n    uint256 public constant OFFSET_1 = 0;\r\n\r\n    uint256 public constant BREAKPOINT_1 = 0.4e18;\r\n\r\n    uint256 public constant SLOPE_2 = 0.2e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_2 = 0.03e18;\r\n\r\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\r\n\r\n    uint256 public constant SLOPE_3 = 0.7e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_3 = 0.43e18;\r\n\r\n    // BREAKPOINT must be lower than 1e18\r\n\r\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\r\n\r\n    uint256 public constant SLOPE_4= 29e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_4 = 25.9e18;\r\n\r\n    uint256 public constant MAX_RATE = 3.1e18;\r\n\r\n\r\n\r\n\r\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\r\n    //profit generation\r\n    uint256 public spread = 1e12;\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Returns the pool utilisation, which is a ratio between loans and deposits\r\n     * utilisation = value_of_loans / value_of_deposits\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\r\n        if (_totalDeposits == 0) return 0;\r\n\r\n        return (_totalLoans * 1e18) / _totalDeposits;\r\n    }\r\n\r\n    /**\r\n     * Returns the current deposit rate\r\n     * The value is based on the current borrowing rate and satisfies the invariant:\r\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\r\n        if (_totalDeposits == 0) return 0;\r\n\r\n        if (_totalLoans >= _totalDeposits) {\r\n            return MAX_RATE * (1e18 - spread) / 1e18;\r\n        } else {\r\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\r\n            return rate;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the current borrowing rate\r\n     * The value is based on the pool utilisation according to the piecewise linear formula:\r\n     * 1) for pool utilisation lower than or equal to breakpoint:\r\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\r\n     * 2) for pool utilisation greater than breakpoint:\r\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\r\n        if (totalDeposits == 0) return OFFSET_1;\r\n\r\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\r\n\r\n        if (poolUtilisation >= 1e18) {\r\n            return MAX_RATE;\r\n        } else if (poolUtilisation <= BREAKPOINT_1) {\r\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\r\n        } else if (poolUtilisation <= BREAKPOINT_2) {\r\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\r\n        } else if (poolUtilisation <= BREAKPOINT_3) {\r\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\r\n        } else {\r\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\r\n            // unsigned integer safety check)\r\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\r\n        }\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n    /**\r\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\r\n     * @param _spread spread defined by user\r\n     **/\r\n    function setSpread(uint256 _spread) external onlyOwner {\r\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\r\n        spread = _spread;\r\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override {}\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @dev emitted after changing the spread\r\n     * @param performer an address of wallet setting a new spread\r\n     * @param newSpread new spread\r\n     * @param timestamp time of a spread change\r\n     **/\r\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\r\n}"
    },
    "contracts/deployment/avalanche/UsdcVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: edb582f05f0fb0098ca7ee750c8fde8a8032d991;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../../interfaces/IRatesCalculator.sol\";\r\n\r\n/**\r\n * @title UsdcVariableUtilisationRatesCalculator\r\n * @dev Contract which calculates the interest rates based on pool utilisation.\r\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\r\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\r\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\r\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\r\n **/\r\ncontract UsdcVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\r\n    uint256 public constant SLOPE_1 = 0.05e18;\r\n    uint256 public constant OFFSET_1 = 0;\r\n\r\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\r\n\r\n    uint256 public constant SLOPE_2 = 0.2e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_2 = 0.09e18;\r\n\r\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\r\n\r\n    uint256 public constant SLOPE_3 = 0.5e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_3 = 0.33e18;\r\n\r\n    // BREAKPOINT must be lower than 1e18\r\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\r\n\r\n    uint256 public constant SLOPE_4 = 4.8e18;\r\n    //negative, hence minus in calculations\r\n    uint256 public constant OFFSET_4 = 4.2e18;\r\n\r\n    uint256 public constant MAX_RATE = 0.6e18;\r\n\r\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\r\n    //profit generation\r\n    uint256 public spread = 1e12;\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * Returns the pool utilisation, which is a ratio between loans and deposits\r\n     * utilisation = value_of_loans / value_of_deposits\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\r\n        if (_totalDeposits == 0) return 0;\r\n\r\n        return (_totalLoans * 1e18) / _totalDeposits;\r\n    }\r\n\r\n    /**\r\n     * Returns the current deposit rate\r\n     * The value is based on the current borrowing rate and satisfies the invariant:\r\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\r\n        if (_totalDeposits == 0) return 0;\r\n\r\n        if (_totalLoans >= _totalDeposits) {\r\n            return MAX_RATE * (1e18 - spread) / 1e18;\r\n        } else {\r\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\r\n            return rate;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the current borrowing rate\r\n     * The value is based on the pool utilisation according to the piecewise linear formula:\r\n     * 1) for pool utilisation lower than or equal to breakpoint:\r\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\r\n     * 2) for pool utilisation greater than breakpoint:\r\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\r\n     * @dev _totalLoans total value of loans\r\n     * @dev _totalDeposits total value of deposits\r\n     **/\r\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\r\n        if (totalDeposits == 0) return OFFSET_1;\r\n\r\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\r\n\r\n        if (poolUtilisation >= 1e18) {\r\n            return MAX_RATE;\r\n        } else if (poolUtilisation <= BREAKPOINT_1) {\r\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\r\n        } else if (poolUtilisation <= BREAKPOINT_2) {\r\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\r\n        } else if (poolUtilisation <= BREAKPOINT_3) {\r\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\r\n        } else {\r\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\r\n            // unsigned integer safety check)\r\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\r\n        }\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n    /**\r\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\r\n     * @param _spread spread defined by user\r\n     **/\r\n    function setSpread(uint256 _spread) external onlyOwner {\r\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\r\n        spread = _spread;\r\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function renounceOwnership() public virtual override {}\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    /**\r\n     * @dev emitted after changing the spread\r\n     * @param performer an address of wallet setting a new spread\r\n     * @param newSpread new spread\r\n     * @param timestamp time of a spread change\r\n     **/\r\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\r\n}"
    },
    "contracts/facets/celo/UbeswapDEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../UniswapV2DEXFacet.sol\";\r\n\r\ncontract UbeswapDEXFacet is UniswapV2DEXFacet {\r\n\r\n    /**\r\n    * Swaps one asset to another\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param _soldAsset asset to be sold\r\n    * @param _boughtAsset asset to be bought\r\n    * @param _exactSold exact amount of asset to be sold\r\n    * @param _minimumBought minimum amount of asset to be bought\r\n    **/\r\n    function swapUbeswap(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) public onlyOwner returns (uint256[] memory) {\r\n        return swapAssets(_soldAsset, _boughtAsset, _exactSold, _minimumBought);\r\n    }\r\n\r\n    /**\r\n     * Returns address of UniswapV2-like exchange\r\n     **/\r\n    function getExchangeIntermediaryContract() public override returns (address) {\r\n        return 0xd8edCc7162281abFFbd65d4a1b260ef1275e1EAc;\r\n    }\r\n}"
    },
    "contracts/facets/avalanche/TraderJoeDEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 71813826f564de63a2462d95b5c15944fcdf686e;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../UniswapV2DEXFacet.sol\";\r\n\r\ncontract TraderJoeDEXFacet is UniswapV2DEXFacet {\r\n    function getProtocolID() pure internal override returns (bytes32) {\r\n        return \"TJ\";\r\n    }\r\n\r\n    /**\r\n      * Swaps one asset to another\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param _soldAsset asset to be sold\r\n      * @param _boughtAsset asset to be bought\r\n      * @param _exactSold exact amount of asset to be sold\r\n      * @param _minimumBought minimum amount of asset to be bought\r\n    **/\r\n    function swapTraderJoe(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) public noBorrowInTheSameBlock onlyOwner returns (uint256[] memory) {\r\n        return swapAssets(_soldAsset, _boughtAsset, _exactSold, _minimumBought);\r\n    }\r\n\r\n    function addLiquidityTraderJoe(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) public onlyOwner {\r\n        addLiquidity(_firstAsset, _secondAsset, amountADesired, amountBDesired, amountAMin, amountBMin);\r\n    }\r\n\r\n    //onlOwnerOrInsolvent inside UniswapDexFacet\r\n    function removeLiquidityTraderJoe(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) public {\r\n        removeLiquidity(_firstAsset, _secondAsset, liquidity, amountAMin, amountBMin);\r\n    }\r\n\r\n    /**\r\n     * Returns address of UniswapV2-like exchange\r\n     **/\r\n    function getExchangeIntermediaryContract() public override returns (address) {\r\n        return 0x4eEcb72b47a32786e08581D6226e95d9AE3bB1Af;\r\n    }\r\n}"
    },
    "contracts/facets/avalanche/YieldYakFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: bdee015765a0dd3731205df659aae576d57dd473;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\n\r\nimport \"../../ReentrancyGuardKeccak.sol\";\r\nimport \"../../lib/SolvencyMethods.sol\";\r\nimport \"../../interfaces/facets/avalanche/IYieldYak.sol\";\r\nimport \"../../OnlyOwnerOrInsolvent.sol\";\r\n\r\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\r\nimport \"../../interfaces/IWrappedNativeToken.sol\";\r\n\r\n// TODO: Check STATUS (tokenManager) of Vault tokens before allowing to stake\r\n//This path is updated during deployment\r\nimport \"../../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract YieldYakFacet is ReentrancyGuardKeccak, SolvencyMethods, OnlyOwnerOrInsolvent {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    // Staking Vaults tokens\r\n    address private constant YY_AAVE_AVAX = 0xaAc0F2d0630d1D09ab2B5A400412a4840B866d95;\r\n    address private constant YY_PTP_sAVAX = 0xb8f531c0d3c53B1760bcb7F57d87762Fd25c4977;\r\n\r\n    // Staking Vaults LPs\r\n    address private constant YY_PNG_AVAX_USDC_LP = 0xC0cd58661b68e10b49D3Bec4bC5E44e7A7c20656;\r\n    address private constant YY_PNG_AVAX_ETH_LP = 0xFCD2050E213cC54db2c9c99632AC870574FbC261;\r\n    address private constant YY_TJ_AVAX_USDC_LP = 0xDEf94a13fF31FB6363f1e03bF18fe0F59Db83BBC;\r\n    address private constant YY_TJ_AVAX_ETH_LP = 0x5219558ee591b030E075892acc41334A1694fd8A;\r\n    address private constant YY_TJ_AVAX_sAVAX_LP = 0x22EDe03f1115666CF05a4bAfafaEe8F43D42cD56;\r\n\r\n    // Tokens\r\n    address private constant SAVAX_TOKEN = 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE;\r\n    address private constant AVAX_TOKEN = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\r\n    // LPs\r\n    address private constant PNG_AVAX_USDC_LP = 0x0e0100Ab771E9288e0Aa97e11557E6654C3a9665;\r\n    address private constant PNG_AVAX_ETH_LP = 0x7c05d54fc5CB6e4Ad87c6f5db3b807C94bB89c52;\r\n\r\n    address private constant TJ_AVAX_USDC_LP = 0xf4003F4efBE8691B60249E6afbD307aBE7758adb;\r\n    address private constant TJ_AVAX_ETH_LP = 0xFE15c2695F1F920da45C30AAE47d11dE51007AF9;\r\n    address private constant TJ_AVAX_sAVAX_LP = 0x4b946c91C2B1a7d7C40FB3C130CdfBaf8389094d;\r\n\r\n    // ----- STAKE -----\r\n\r\n    /**\r\n        * Stakes AVAX in Yield Yak protocol\r\n        * @dev This function uses the redstone-evm-connector\r\n        * @param amount amount of AVAX to be staked\r\n    **/\r\n    function stakeAVAXYak(uint256 amount) public onlyOwner nonReentrant recalculateAssetsExposure remainsSolvent {\r\n        require(amount > 0, \"Cannot stake 0 tokens\");\r\n        amount = Math.min(IWrappedNativeToken(AVAX_TOKEN).balanceOf(address(this)), amount);\r\n        IERC20Metadata yrtToken = IERC20Metadata(YY_AAVE_AVAX);\r\n        uint256 initialYRTBalance = yrtToken.balanceOf(address(this));\r\n\r\n        IWrappedNativeToken(AVAX_TOKEN).withdraw(amount);\r\n        IYieldYak(YY_AAVE_AVAX).deposit{value: amount}();\r\n\r\n        DiamondStorageLib.addOwnedAsset(\"YY_AAVE_AVAX\", YY_AAVE_AVAX);\r\n\r\n        emit Staked(\r\n            msg.sender,\r\n            \"AVAX\",\r\n            YY_AAVE_AVAX,\r\n            amount,\r\n            yrtToken.balanceOf(address(this)) - initialYRTBalance,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n       * Stakes sAVAX in Yield Yak protocol\r\n       * @dev This function uses the redstone-evm-connector\r\n       * @param amount amount of sAVAX to be staked\r\n    **/\r\n    function stakeSAVAXYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\r\n            tokenAddress: SAVAX_TOKEN,\r\n            vaultAddress: YY_PTP_sAVAX,\r\n            tokenSymbol: \"sAVAX\",\r\n            vaultTokenSymbol: \"YY_PTP_sAVAX\",\r\n            amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Stakes PNG_AVAX_USDC_LP in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of PNG_AVAX_USDC_LP to be staked\r\n    **/\r\n    function stakePNGAVAXUSDCYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: PNG_AVAX_USDC_LP,\r\n        vaultAddress: YY_PNG_AVAX_USDC_LP,\r\n        tokenSymbol: \"PNG_AVAX_USDC_LP\",\r\n        vaultTokenSymbol: \"YY_PNG_AVAX_USDC_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Stakes PNG_AVAX_ETH_LP in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of PNG_AVAX_ETH_LP to be staked\r\n    **/\r\n    function stakePNGAVAXETHYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: PNG_AVAX_ETH_LP,\r\n        vaultAddress: YY_PNG_AVAX_ETH_LP,\r\n        tokenSymbol: \"PNG_AVAX_ETH_LP\",\r\n        vaultTokenSymbol: \"YY_PNG_AVAX_ETH_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Stakes TJ_AVAX_USDC in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of TJ_AVAX_USDC to be staked\r\n    **/\r\n    function stakeTJAVAXUSDCYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: TJ_AVAX_USDC_LP,\r\n        vaultAddress: YY_TJ_AVAX_USDC_LP,\r\n        tokenSymbol: \"TJ_AVAX_USDC_LP\",\r\n        vaultTokenSymbol: \"YY_TJ_AVAX_USDC_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Stakes TJ_AVAX_ETH_LP in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of TJ_AVAX_ETH_LP to be staked\r\n    **/\r\n    function stakeTJAVAXETHYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: TJ_AVAX_ETH_LP,\r\n        vaultAddress: YY_TJ_AVAX_ETH_LP,\r\n        tokenSymbol: \"TJ_AVAX_ETH_LP\",\r\n        vaultTokenSymbol: \"YY_TJ_AVAX_ETH_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Stakes TJ_AVAX_sAVAX_LP in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of TJ_AVAX_sAVAX_LP to be staked\r\n    **/\r\n    function stakeTJAVAXSAVAXYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: TJ_AVAX_sAVAX_LP,\r\n        vaultAddress: YY_TJ_AVAX_sAVAX_LP,\r\n        tokenSymbol: \"TJ_AVAX_sAVAX_LP\",\r\n        vaultTokenSymbol: \"YY_TJ_AVAX_sAVAX_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    // ----- UNSTAKE -----\r\n\r\n\r\n    //TODO: make common method for unstaking single assets\r\n\r\n    /**\r\n        * Unstakes AVAX from Yield Yak protocol\r\n        * @dev This function uses the redstone-evm-connector\r\n        * @param amount amount of AVAX to be unstaked\r\n    **/\r\n    function unstakeAVAXYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\r\n        IYieldYak yakStakingContract = IYieldYak(YY_AAVE_AVAX);\r\n        uint256 initialDepositTokenBalance = address(this).balance;\r\n\r\n        amount = Math.min(yakStakingContract.balanceOf(address(this)), amount);\r\n\r\n        yakStakingContract.withdraw(amount);\r\n\r\n        if(yakStakingContract.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(\"YY_AAVE_AVAX\");\r\n        }\r\n\r\n        uint256 depositTokenBalanceAfterWithdrawal = address(this).balance;\r\n\r\n        IWrappedNativeToken(AVAX_TOKEN).deposit{value: address(this).balance}();\r\n\r\n        if(IERC20(AVAX_TOKEN).balanceOf(address(this)) > 0) {\r\n            DiamondStorageLib.addOwnedAsset(\"AVAX\", AVAX_TOKEN);\r\n        }\r\n\r\n        emit Unstaked(\r\n            msg.sender,\r\n            \"AVAX\",\r\n            YY_AAVE_AVAX,\r\n            depositTokenBalanceAfterWithdrawal - initialDepositTokenBalance,\r\n            amount,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * Unstakes sAVAX from Yield Yak protocol\r\n    * @dev This function uses the redstone-evm-connector\r\n        * @param amount amount of sAVAX to be unstaked\r\n    **/\r\n    function unstakeSAVAXYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\r\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: SAVAX_TOKEN,\r\n        vaultAddress: YY_PTP_sAVAX,\r\n        tokenSymbol: \"sAVAX\",\r\n        vaultTokenSymbol: \"YY_PTP_sAVAX\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Unstakes PNG_AVAX_USDC_LP in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of PNG_AVAX_USDC_LP to be staked\r\n    **/\r\n    function unstakePNGAVAXUSDCYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\r\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: PNG_AVAX_USDC_LP,\r\n        vaultAddress: YY_PNG_AVAX_USDC_LP,\r\n        tokenSymbol: \"PNG_AVAX_USDC_LP\",\r\n        vaultTokenSymbol: \"YY_PNG_AVAX_USDC_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Unstakes PNG_AVAX_ETH_LP in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of PNG_AVAX_ETH_LP to be unstaked\r\n    **/\r\n    function unstakePNGAVAXETHYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\r\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: PNG_AVAX_ETH_LP,\r\n        vaultAddress: YY_PNG_AVAX_ETH_LP,\r\n        tokenSymbol: \"PNG_AVAX_ETH_LP\",\r\n        vaultTokenSymbol: \"YY_PNG_AVAX_ETH_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Unstakes TJ_AVAX_USDC in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of TJ_AVAX_USDC to be unstaked\r\n    **/\r\n    function unstakeTJAVAXUSDCYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\r\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: TJ_AVAX_USDC_LP,\r\n        vaultAddress: YY_TJ_AVAX_USDC_LP,\r\n        tokenSymbol: \"TJ_AVAX_USDC_LP\",\r\n        vaultTokenSymbol: \"YY_TJ_AVAX_USDC_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Unstakes TJ_AVAX_ETH_LP in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of TJ_AVAX_ETH_LP to be unstaked\r\n    **/\r\n    function unstakeTJAVAXETHYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\r\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: TJ_AVAX_ETH_LP,\r\n        vaultAddress: YY_TJ_AVAX_ETH_LP,\r\n        tokenSymbol: \"TJ_AVAX_ETH_LP\",\r\n        vaultTokenSymbol: \"YY_TJ_AVAX_ETH_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Unstakes TJ_AVAX_sAVAX_LP in Yield Yak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of TJ_AVAX_sAVAX_LP to be unstaked\r\n    **/\r\n    function unstakeTJAVAXSAVAXYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\r\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\r\n        tokenAddress: TJ_AVAX_sAVAX_LP,\r\n        vaultAddress: YY_TJ_AVAX_sAVAX_LP,\r\n        tokenSymbol: \"TJ_AVAX_sAVAX_LP\",\r\n        vaultTokenSymbol: \"YY_TJ_AVAX_sAVAX_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    // ----- PRIVATE METHODS -----\r\n\r\n    /**\r\n      * Stakes {stakingDetails.tokenAddress} token in the YieldYak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param stakingDetails IYieldYak.YYStakingDetails staking details\r\n    **/\r\n    function _stakeTokenYY(IYieldYak.YYStakingDetails memory stakingDetails) private recalculateAssetsExposure {\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        IERC20Metadata yrtToken = IERC20Metadata(stakingDetails.vaultAddress);\r\n        uint256 initialYRTBalance = yrtToken.balanceOf(address(this));\r\n\r\n        stakingDetails.amount = Math.min(IERC20Metadata(stakingDetails.tokenAddress).balanceOf(address(this)), stakingDetails.amount);\r\n        require(stakingDetails.amount > 0, \"Cannot stake 0 tokens\");\r\n        // _ACTIVE = 2\r\n        require(tokenManager.tokenToStatus(stakingDetails.tokenAddress) == 2, \"Token not supported\");\r\n        require(tokenManager.tokenToStatus(stakingDetails.vaultAddress) == 2, \"Vault token not supported\");\r\n\r\n        IERC20Metadata(stakingDetails.tokenAddress).approve(stakingDetails.vaultAddress, stakingDetails.amount);\r\n        IYieldYak(stakingDetails.vaultAddress).deposit(stakingDetails.amount);\r\n\r\n        // Add/remove owned tokens\r\n        DiamondStorageLib.addOwnedAsset(stakingDetails.vaultTokenSymbol, stakingDetails.vaultAddress);\r\n        if(IERC20(stakingDetails.tokenAddress).balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(stakingDetails.tokenSymbol);\r\n        }\r\n\r\n        emit Staked(\r\n            msg.sender,\r\n            stakingDetails.tokenSymbol,\r\n            stakingDetails.vaultAddress,\r\n            stakingDetails.amount,\r\n            yrtToken.balanceOf(address(this)) - initialYRTBalance,\r\n            block.timestamp);\r\n    }\r\n\r\n    /**\r\n      * Unstakes {stakingDetails.tokenAddress} token in the YieldYak protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param stakingDetails IYieldYak.YYStakingDetails staking details\r\n    **/\r\n    function _unstakeTokenYY(IYieldYak.YYStakingDetails memory stakingDetails) private recalculateAssetsExposure {\r\n        IYieldYak vaultContract = IYieldYak(stakingDetails.vaultAddress);\r\n        IERC20Metadata depositToken = IERC20Metadata(stakingDetails.tokenAddress);\r\n        uint256 initialDepositTokenBalance = depositToken.balanceOf(address(this));\r\n        stakingDetails.amount = Math.min(vaultContract.balanceOf(address(this)), stakingDetails.amount);\r\n\r\n        vaultContract.withdraw(stakingDetails.amount);\r\n\r\n        // Add/remove owned tokens\r\n        DiamondStorageLib.addOwnedAsset(stakingDetails.tokenSymbol, stakingDetails.tokenAddress);\r\n        if(vaultContract.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(stakingDetails.vaultTokenSymbol);\r\n        }\r\n\r\n        emit Unstaked(\r\n            msg.sender,\r\n            stakingDetails.tokenSymbol,\r\n            stakingDetails.vaultAddress,\r\n            depositToken.balanceOf(address(this)) - initialDepositTokenBalance,\r\n            stakingDetails.amount,\r\n            block.timestamp);\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    /* ========== RECEIVE AVAX FUNCTION ========== */\r\n    receive() external payable {}\r\n\r\n    /**\r\n        * @dev emitted when user stakes an asset\r\n        * @param user the address executing staking\r\n        * @param asset the asset that was staked\r\n        * @param vault address of the vault token\r\n        * @param depositTokenAmount how much of deposit token was staked\r\n        * @param receiptTokenAmount how much of receipt token was received\r\n        * @param timestamp of staking\r\n    **/\r\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\r\n\r\n    /**\r\n        * @dev emitted when user unstakes an asset\r\n        * @param user the address executing unstaking\r\n        * @param vault address of the vault token\r\n        * @param asset the asset that was unstaked\r\n        * @param depositTokenAmount how much deposit token was received\r\n        * @param receiptTokenAmount how much receipt token was unstaked\r\n        * @param timestamp of unstaking\r\n    **/\r\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\r\n}"
    },
    "contracts/interfaces/facets/avalanche/IYieldYak.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\ninterface IYieldYak {\r\n    function totalDeposits() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function depositFor(address account) external payable;\r\n\r\n    function depositFor(address account, uint256 amount) external;\r\n\r\n    function deposit() external payable;\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    // ---INTERFACE-----\r\n    struct YYStakingDetails {\r\n        address tokenAddress;\r\n        address vaultAddress;\r\n        bytes32 tokenSymbol;\r\n        bytes32 vaultTokenSymbol;\r\n        uint256 amount;\r\n    }\r\n}"
    },
    "contracts/facets/avalanche/YieldYakSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: f14df032e1f35f6a051c254ec22090b57b073c87;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"../../interfaces/facets/avalanche/IYieldYakRouter.sol\";\r\nimport \"../../ReentrancyGuardKeccak.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\r\nimport \"../../lib/SolvencyMethods.sol\";\r\nimport \"../../interfaces/ITokenManager.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract YieldYakSwapFacet is ReentrancyGuardKeccak, SolvencyMethods {\r\n    address private constant YY_ROUTER = 0xC4729E56b831d74bBc18797e0e17A295fA77488c;\r\n\r\n    struct SwapTokensDetails {\r\n        bytes32 tokenSoldSymbol;\r\n        bytes32 tokenBoughtSymbol;\r\n        IERC20Metadata soldToken;\r\n        IERC20Metadata boughtToken;\r\n        uint256 initialSoldTokenBalance;\r\n        uint256 initialBoughtTokenBalance;\r\n    }\r\n\r\n    function getInitialTokensDetails(address _soldTokenAddress, address _boughtTokenAddress) internal returns (SwapTokensDetails memory){\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n\r\n        bytes32 _tokenSoldSymbol = tokenManager.tokenAddressToSymbol(_soldTokenAddress);\r\n        bytes32 _tokenBoughtSymbol = tokenManager.tokenAddressToSymbol(_boughtTokenAddress);\r\n\r\n        require(tokenManager.isTokenAssetActive(_boughtTokenAddress), \"Asset not supported.\");\r\n\r\n        IERC20Metadata _soldToken = IERC20Metadata(_soldTokenAddress);\r\n        IERC20Metadata _boughtToken = IERC20Metadata(_boughtTokenAddress);\r\n\r\n        return SwapTokensDetails({\r\n            tokenSoldSymbol: _tokenSoldSymbol,\r\n            tokenBoughtSymbol: _tokenBoughtSymbol,\r\n            soldToken: _soldToken,\r\n            boughtToken: _boughtToken,\r\n            initialSoldTokenBalance: _soldToken.balanceOf(address(this)),\r\n            initialBoughtTokenBalance: _boughtToken.balanceOf(address(this))\r\n        });\r\n    }\r\n\r\n    function yakSwap(uint256 _amountIn, uint256 _amountOut, address[] calldata _path, address[] calldata _adapters) external nonReentrant onlyOwner noBorrowInTheSameBlock recalculateAssetsExposure remainsSolvent{\r\n        SwapTokensDetails memory swapTokensDetails = getInitialTokensDetails(_path[0], _path[_path.length - 1]);\r\n\r\n        _amountIn = Math.min(swapTokensDetails.soldToken.balanceOf(address(this)), _amountIn);\r\n        require(_amountIn > 0, \"Amount of tokens to sell has to be greater than 0\");\r\n\r\n        swapTokensDetails.soldToken.approve(YY_ROUTER, _amountIn);\r\n\r\n        IYieldYakRouter router = IYieldYakRouter(YY_ROUTER);\r\n\r\n        IYieldYakRouter.Trade memory trade = IYieldYakRouter.Trade({\r\n            amountIn: _amountIn,\r\n            amountOut: _amountOut,\r\n            path: _path,\r\n            adapters: _adapters\r\n        });\r\n\r\n        router.swapNoSplit(trade, address(this), 0);\r\n\r\n        // Add asset to ownedAssets\r\n        if (swapTokensDetails.boughtToken.balanceOf(address(this)) > 0) {\r\n            DiamondStorageLib.addOwnedAsset(swapTokensDetails.tokenBoughtSymbol, address(swapTokensDetails.boughtToken));\r\n        }\r\n\r\n        // Remove asset from ownedAssets if the asset balance is 0 after the swap\r\n        if (swapTokensDetails.soldToken.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(swapTokensDetails.tokenSoldSymbol);\r\n        }\r\n\r\n        uint256 boughtTokenFinalAmount = swapTokensDetails.boughtToken.balanceOf(address(this)) - swapTokensDetails.initialBoughtTokenBalance;\r\n        require(boughtTokenFinalAmount >= _amountOut, \"Insuficient output amount\");\r\n\r\n        emit Swap(\r\n            msg.sender,\r\n            swapTokensDetails.tokenSoldSymbol,\r\n            swapTokensDetails.tokenBoughtSymbol,\r\n            swapTokensDetails.initialSoldTokenBalance - swapTokensDetails.soldToken.balanceOf(address(this)),\r\n            boughtTokenFinalAmount,\r\n            block.timestamp\r\n        );\r\n\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after a swap of assets\r\n     * @param user the address of user making the purchase\r\n     * @param soldAsset sold by the user\r\n     * @param boughtAsset bought by the user\r\n     * @param amountSold amount of tokens sold\r\n     * @param amountBought amount of tokens bought\r\n     * @param timestamp time of the swap\r\n     **/\r\n    event Swap(address indexed user, bytes32 indexed soldAsset, bytes32 indexed boughtAsset, uint256 amountSold, uint256 amountBought, uint256 timestamp);\r\n}\r\n"
    },
    "contracts/interfaces/facets/avalanche/IYieldYakRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity ^0.8.17;\r\n\r\ninterface IYieldYakRouter {\r\n    struct Trade {\r\n        uint256 amountIn;\r\n        uint256 amountOut;\r\n        address[] path;\r\n        address[] adapters;\r\n    }\r\n\r\n    function swapNoSplit(\r\n        Trade calldata _trade,\r\n        address _to,\r\n        uint256 _fee\r\n    ) external;\r\n}"
    },
    "contracts/facets/avalanche/VectorFinanceFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: bdee015765a0dd3731205df659aae576d57dd473;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\nimport \"../../ReentrancyGuardKeccak.sol\";\r\nimport \"../../interfaces/IVectorFinanceStaking.sol\";\r\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\r\nimport \"../../interfaces/IStakingPositions.sol\";\r\nimport \"../../OnlyOwnerOrInsolvent.sol\";\r\nimport \"../../interfaces/IVectorFinanceMainStaking.sol\";\r\n//This path is updated during deployment\r\nimport \"../../lib/avalanche/DeploymentConstants.sol\";\r\n\r\ncontract VectorFinanceFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\r\n\r\n    // CONSTANTS\r\n\r\n    address private constant VectorMainStaking = 0x8B3d9F0017FA369cD8C164D0Cc078bf4cA588aE5;\r\n\r\n    // PUBLIC FUNCTIONS\r\n\r\n    function vectorStakeUSDC1(uint256 amount) public {\r\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\r\n            asset: 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E,\r\n            symbol: \"USDC\",\r\n            identifier: \"VF_USDC_MAIN\",\r\n            balanceSelector: this.vectorUSDC1Balance.selector,\r\n            unstakeSelector: this.vectorUnstakeUSDC1.selector\r\n        });\r\n        stakeToken(amount, position);\r\n    }\r\n\r\n    function vectorUnstakeUSDC1(uint256 amount, uint256 minAmount) public {\r\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\r\n            asset: 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E,\r\n            symbol: \"USDC\",\r\n            identifier: \"VF_USDC_MAIN\",\r\n            balanceSelector: this.vectorUSDC1Balance.selector,\r\n            unstakeSelector: this.vectorUnstakeUSDC1.selector\r\n        });\r\n        unstakeToken(amount, minAmount, position);\r\n    }\r\n\r\n    function vectorUSDC1Balance() public view returns(uint256 _stakedBalance) {\r\n        IVectorFinanceStaking stakingContract = IVectorFinanceStaking(getAssetPoolHelper(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E));\r\n        _stakedBalance = stakingContract.balance(address(this));\r\n    }\r\n\r\n    function vectorStakeWAVAX1(uint256 amount) public {\r\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\r\n            asset: 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\r\n            symbol: \"AVAX\",\r\n            identifier: \"VF_AVAX_SAVAX\",\r\n            balanceSelector: this.vectorWAVAX1Balance.selector,\r\n            unstakeSelector: this.vectorUnstakeWAVAX1.selector\r\n        });\r\n        stakeToken(amount, position);\r\n    }\r\n\r\n    function vectorUnstakeWAVAX1(uint256 amount, uint256 minAmount) public {\r\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\r\n            asset: 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\r\n            symbol: \"AVAX\",\r\n            identifier: \"VF_AVAX_SAVAX\",\r\n            balanceSelector: this.vectorWAVAX1Balance.selector,\r\n            unstakeSelector: this.vectorUnstakeWAVAX1.selector\r\n        });\r\n        unstakeToken(amount, minAmount, position);\r\n    }\r\n\r\n    function vectorWAVAX1Balance() public view returns(uint256 _stakedBalance) {\r\n        IVectorFinanceStaking stakingContract = IVectorFinanceStaking(getAssetPoolHelper(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7));\r\n        _stakedBalance = stakingContract.balance(address(this));\r\n    }\r\n\r\n    function vectorStakeSAVAX1(uint256 amount) public {\r\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\r\n            asset: 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE,\r\n            symbol: \"sAVAX\",\r\n            identifier: \"VF_SAVAX_MAIN\",\r\n            balanceSelector: this.vectorSAVAX1Balance.selector,\r\n            unstakeSelector: this.vectorUnstakeSAVAX1.selector\r\n        });\r\n        stakeToken(amount, position);\r\n    }\r\n\r\n    function vectorUnstakeSAVAX1(uint256 amount, uint256 minAmount) public {\r\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\r\n            asset: 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE,\r\n            symbol: \"sAVAX\",\r\n            identifier: \"VF_SAVAX_MAIN\",\r\n            balanceSelector: this.vectorSAVAX1Balance.selector,\r\n            unstakeSelector: this.vectorUnstakeSAVAX1.selector\r\n        });\r\n        unstakeToken(amount, minAmount, position);\r\n    }\r\n\r\n    function vectorSAVAX1Balance() public view returns(uint256 _stakedBalance) {\r\n        IVectorFinanceStaking stakingContract = IVectorFinanceStaking(getAssetPoolHelper(0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE));\r\n        _stakedBalance = stakingContract.balance(address(this));\r\n    }\r\n\r\n    // INTERNAL FUNCTIONS\r\n    /**\r\n    * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function stakeToken(uint256 amount, IStakingPositions.StakedPosition memory position) internal\r\n    onlyOwner nonReentrant  recalculateAssetsExposure remainsSolvent {\r\n        IVectorFinanceStaking poolHelper = getAssetPoolHelper(position.asset);\r\n        IERC20Metadata stakedToken = getERC20TokenInstance(position.symbol, false);\r\n        uint256 initialReceiptTokenBalance = poolHelper.balance(address(this));\r\n\r\n        amount = Math.min(stakedToken.balanceOf(address(this)), amount);\r\n        require(amount > 0, \"Cannot stake 0 tokens\");\r\n\r\n        stakedToken.approve(VectorMainStaking, amount);\r\n\r\n        poolHelper.deposit(amount);\r\n\r\n        DiamondStorageLib.addStakedPosition(position);\r\n\r\n        if (stakedToken.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(position.symbol);\r\n        }\r\n\r\n        emit Staked(\r\n            msg.sender,\r\n            position.symbol,\r\n            address(poolHelper),\r\n            amount,\r\n            poolHelper.balance(address(this)) - initialReceiptTokenBalance,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * Unstakes token from Vector Finance\r\n    * IMPORTANT: This method can be used by anyone when a loan is insolvent. This operation can be costly, that is why\r\n    * if needed it has to be performed in a separate transaction to liquidation\r\n    * @dev This function uses the redstone-evm-connector\r\n    **/\r\n    function unstakeToken(uint256 amount, uint256 minAmount, IStakingPositions.StakedPosition memory position) internal\r\n    onlyOwnerOrInsolvent recalculateAssetsExposure nonReentrant returns (uint256 unstaked) {\r\n        IVectorFinanceStaking poolHelper = getAssetPoolHelper(position.asset);\r\n        IERC20Metadata unstakedToken = getERC20TokenInstance(position.symbol, false);\r\n\r\n        require(amount > 0, \"Cannot unstake 0 tokens\");\r\n\r\n        amount = Math.min(poolHelper.balance(address(this)), amount);\r\n\r\n        uint256 balance = unstakedToken.balanceOf(address(this));\r\n\r\n        poolHelper.withdraw(amount, minAmount);\r\n\r\n        uint256 newBalance = unstakedToken.balanceOf(address(this));\r\n\r\n        if (poolHelper.balance(address(this)) == 0) {\r\n            DiamondStorageLib.removeStakedPosition(position.identifier);\r\n        }\r\n        DiamondStorageLib.addOwnedAsset(position.symbol, address(unstakedToken));\r\n\r\n        emit Unstaked(\r\n            msg.sender,\r\n            position.symbol,\r\n            address(poolHelper),\r\n            newBalance - balance,\r\n            amount,\r\n            block.timestamp\r\n        );\r\n\r\n        _handleRewards(poolHelper);\r\n\r\n        return newBalance - balance;\r\n    }\r\n\r\n    function _handleRewards(IVectorFinanceStaking stakingContract) internal {\r\n        IVectorRewarder rewarder = stakingContract.rewarder();\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n        uint256 index;\r\n\r\n        // We do not want to revert in case of unsupported rewardTokens in order not to block the unstaking/liquidation process\r\n        while(true) {\r\n            // No access to the length of rewardTokens[]. Need to iterate until indexOutOfRange\r\n            (bool success, bytes memory result) = address(rewarder).call(abi.encodeWithSignature(\"rewardTokens(uint256)\", index));\r\n            if(!success) {\r\n                break;\r\n            }\r\n            address rewardToken = abi.decode(result, (address));\r\n            bytes32 rewardTokenSymbol = tokenManager.tokenAddressToSymbol(rewardToken);\r\n            if(rewardTokenSymbol == \"\") {\r\n                emit UnsupportedRewardToken(msg.sender, rewardToken, block.timestamp);\r\n                index += 1;\r\n                continue;\r\n            }\r\n            if(IERC20(rewardToken).balanceOf(address(this)) > 0) {\r\n                DiamondStorageLib.addOwnedAsset(rewardTokenSymbol, rewardToken);\r\n            }\r\n            index += 1;\r\n        }\r\n    }\r\n\r\n    function getAssetPoolHelper(address asset) internal view returns(IVectorFinanceStaking){\r\n        IVectorFinanceMainStaking mainStaking = IVectorFinanceMainStaking(VectorMainStaking);\r\n        return IVectorFinanceStaking(mainStaking.getPoolInfo(asset).helper);\r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    // EVENTS\r\n\r\n    /**\r\n        * @dev emitted when user stakes an asset\r\n        * @param user the address executing staking\r\n        * @param asset the asset that was staked\r\n        * @param vault address of receipt token\r\n        * @param depositTokenAmount how much of deposit token was staked\r\n        * @param receiptTokenAmount how much of receipt token was received\r\n        * @param timestamp of staking\r\n    **/\r\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\r\n\r\n    /**\r\n        * @dev emitted when user unstakes an asset\r\n        * @param user the address executing unstaking\r\n        * @param asset the asset that was unstaked\r\n        * @param vault address of receipt token\r\n        * @param depositTokenAmount how much deposit token was received\r\n        * @param receiptTokenAmount how much receipt token was unstaked\r\n        * @param timestamp of unstaking\r\n    **/\r\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\r\n\r\n    /**\r\n        * @dev emitted when user collects rewards in tokens that are not supported\r\n        * @param user the address collecting rewards\r\n        * @param asset reward token that was collected\r\n        * @param timestamp of collecting rewards\r\n    **/\r\n    event UnsupportedRewardToken(address indexed user, address indexed asset, uint256 timestamp);\r\n}"
    },
    "contracts/interfaces/IVectorFinanceStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./IVectorRewarder.sol\";\r\n\r\ninterface IVectorFinanceStaking {\r\n    function balance(address account) external view returns (uint256);\r\n\r\n    function withdraw(uint256 amount, uint256 minAmount) external;\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function earned(address rewardToken) external view returns (uint256);\r\n\r\n    function masterVtx() external view returns (address);\r\n\r\n    function stakingToken() external view returns (address);\r\n\r\n    function rewarder() external view returns (IVectorRewarder);\r\n}"
    },
    "contracts/interfaces/IVectorFinanceMainStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\ninterface IVectorFinanceMainStaking {\r\n    struct PoolInfo {\r\n        uint256 pid;\r\n        bool isActive;\r\n        address token;\r\n        address lp;\r\n        uint256 sizeLp;\r\n        address receipt;\r\n        uint256 size;\r\n        address rewards_addr;\r\n        address helper;\r\n    }\r\n\r\n    function getPoolInfo(address _address)\r\n    external\r\n    view\r\n    returns (PoolInfo memory);\r\n}"
    },
    "contracts/interfaces/IVectorRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\ninterface IVectorRewarder {\r\n    function rewardTokens(uint256 index) external view returns (address);\r\n\r\n    function earned(address account, address rewardToken) external view returns (uint256);\r\n\r\n    function updateFor(address account) external;\r\n}"
    },
    "contracts/mock/MockUsd.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract MockUsd is ERC20 {\r\n    constructor(address[] memory airdropUsers) ERC20(\"MockToken\", \"USD\") {\r\n\r\n        for(uint256 i = 0; i < airdropUsers.length; i++) {\r\n            _mint(airdropUsers[i], 10000 * 10 ** decimals());\r\n        }\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 6;\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract MockToken is ERC20 {\r\n    constructor(address[] memory airdropUsers) ERC20(\"MockToken\", \"USDT\") {\r\n\r\n        for (uint256 i = 0; i < airdropUsers.length; i++) {\r\n            _mint(airdropUsers[i], 10000 * 10 ** decimals());\r\n        }\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/ERC721/EarlyAccessNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\nimport \"../abstract/ECDSAVerify.sol\";\r\n\r\ncontract EarlyAccessNFT is ERC721, Pausable, Ownable, ECDSAVerify {\r\n    using Counters for Counters.Counter;\r\n\r\n    Counters.Counter public _tokenIdCounter;\r\n    mapping(string => address) public accessTokens;\r\n    string public baseURI;\r\n    address public accessTokenTrustedSigner;\r\n\r\n\r\n    constructor(string memory _baseUri) ERC721(\"Delta Prime Early Access\", \"DP-EA\") {\r\n        _pause();\r\n        baseURI = _baseUri;\r\n    }\r\n\r\n    function setTrustedSigner(address trustedSigner) external onlyOwner {\r\n        require(trustedSigner != address(0), \"Trusted signer cannot be a zero address\");\r\n        accessTokenTrustedSigner = trustedSigner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        return baseURI;\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function safeMint(string memory accessToken, bytes memory signature) public returns (uint256) {\r\n        require(verifyMessage(accessTokenTrustedSigner, accessToken, signature), \"Signer not authorized\");\r\n        require(accessTokens[accessToken] == address(0), \"Only one NFT per one user is allowed\");\r\n        require(balanceOf(_msgSender()) == 0, \"Only one NFT per one wallet is allowed\");\r\n\r\n        uint256 tokenId = _tokenIdCounter.current();\r\n        _tokenIdCounter.increment();\r\n        accessTokens[accessToken] = _msgSender();\r\n        _safeMint(_msgSender(), tokenId);\r\n        return tokenId;\r\n    }\r\n\r\n    function airdropMint(address[] memory _accounts) external onlyOwner returns (uint256 _NFTsMinted){\r\n        uint256 tokenId;\r\n        _NFTsMinted = 0;\r\n        for (uint i = 0; i < _accounts.length; i++) {\r\n            if (balanceOf(_accounts[i]) > 0) continue;\r\n            tokenId = _tokenIdCounter.current();\r\n            _tokenIdCounter.increment();\r\n            _safeMint(_accounts[i], tokenId);\r\n            _NFTsMinted += 1;\r\n        }\r\n    }\r\n\r\n    modifier whenNotPausedMintingExemption(address from) {\r\n        if (from != address(0)) {\r\n            require(!paused(), \"Pausable: paused\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal whenNotPausedMintingExemption(from) override(ERC721) {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/abstract/ECDSAVerify.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\r\n\r\nabstract contract ECDSAVerify {\r\n    using ECDSA for bytes32;\r\n\r\n    function verifyMessage(address signer, string memory message, bytes memory signature) public pure returns (bool) {\r\n        bytes32 messageHash = keccak256(bytes(message));\r\n        address signerAddress = messageHash.toEthSignedMessageHash().recover(signature);\r\n\r\n        return signerAddress == signer;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/ERC721/AccessNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\nimport \"../abstract/ECDSAVerify.sol\";\r\n\r\nabstract contract AccessNFT is ERC721, ERC721Enumerable, ERC721URIStorage, Pausable, Ownable, ECDSAVerify {\r\n    using Counters for Counters.Counter;\r\n\r\n    Counters.Counter private _tokenIdCounter;\r\n    mapping(string => address) accessTokens;\r\n    string[] availableUris;\r\n    address accessTokenTrustedSigner;\r\n\r\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {\r\n        _pause();\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\r\n        super._burn(tokenId);\r\n    }\r\n\r\n    function setTrustedSigner(address trustedSigner) external onlyOwner {\r\n        require(trustedSigner != address(0), \"Trusted signer cannot be a zero address\");\r\n        accessTokenTrustedSigner = trustedSigner;\r\n    }\r\n\r\n    function addAvailableUri(string[] memory _uris) external onlyOwner {\r\n        for (uint i = 0; i < _uris.length; i++) {\r\n            availableUris.push(_uris[i]);\r\n        }\r\n    }\r\n\r\n    function getAvailableUri(uint256 index) external view returns (string memory) {\r\n        return availableUris[index];\r\n    }\r\n\r\n    function getAvailableUrisCount() external view returns (uint256) {\r\n        return availableUris.length;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\r\n        return super.tokenURI(tokenId);\r\n    }\r\n\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function safeMint(string memory accessToken, bytes memory signature) public returns (uint256) {\r\n        require(verifyMessage(accessTokenTrustedSigner, accessToken, signature), \"Signer not authorized\");\r\n        require(accessTokens[accessToken] == address(0), \"Only one NFT per one user is allowed\");\r\n        require(balanceOf(_msgSender()) == 0, \"Only one NFT per one wallet is allowed\");\r\n        require(availableUris.length > 0, \"All available NFTs were already minted\");\r\n\r\n        uint256 tokenId = _tokenIdCounter.current();\r\n        _tokenIdCounter.increment();\r\n        accessTokens[accessToken] = _msgSender();\r\n        _safeMint(_msgSender(), tokenId);\r\n        _setTokenURI(tokenId, availableUris[availableUris.length - 1]);\r\n        availableUris.pop();\r\n        return tokenId;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal whenNotPausedMintingExemption(from) override(ERC721, ERC721Enumerable) {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    modifier whenNotPausedMintingExemption(address from) {\r\n        if (from != address(0)) {\r\n            require(!paused(), \"Pausable: paused\");\r\n        }\r\n        _;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/ERC721/DepositAccessNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./AccessNFT.sol\";\r\n\r\ncontract DepositAccessNFT is AccessNFT {\r\n\r\n    constructor() AccessNFT(\"DeltaPrimeDepositAccess\", \"DP-DA\") {\r\n        accessTokenTrustedSigner = 0x1884fa898A26D0e080d047533B1c1E495d958b1D;\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockDepositAccessNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"../ERC721/DepositAccessNFT.sol\";\r\n\r\ncontract MockDepositAccessNFT is DepositAccessNFT {\r\n\r\n    constructor() DepositAccessNFT() {\r\n        accessTokenTrustedSigner = 0xdD2FD4581271e230360230F9337D5c0430Bf44C0;\r\n    }\r\n}\r\n"
    },
    "contracts/ERC721/BorrowAccessNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./AccessNFT.sol\";\r\n\r\ncontract BorrowAccessNFT is AccessNFT {\r\n\r\n    constructor() AccessNFT(\"DeltaPrimeBorrowAccess\", \"DP-BA\") {\r\n        accessTokenTrustedSigner = 0x6C21A841d6f029243AF87EF01f6772F05832144b;\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockBorrowAccessNFT.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../ERC721/BorrowAccessNFT.sol\";\r\n\r\ncontract MockBorrowAccessNFT is BorrowAccessNFT {\r\n\r\n    constructor() BorrowAccessNFT() {\r\n        accessTokenTrustedSigner = 0xdD2FD4581271e230360230F9337D5c0430Bf44C0;\r\n    }\r\n}\r\n"
    },
    "contracts/ERC721/WolfOfDeFiWinners.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\ncontract WolfOfDeFiWinners is ERC721, ERC721Enumerable, ERC721URIStorage, Ownable {\r\n    using Counters for Counters.Counter;\r\n\r\n    Counters.Counter public _tokenIdCounter;\r\n\r\n    constructor() ERC721(\"Wolf of DeFi Winners\", \"DP-WODW\") {}\r\n\r\n    function safeMint(address to, string memory uri) public onlyOwner {\r\n        uint256 tokenId = _tokenIdCounter.current();\r\n        _tokenIdCounter.increment();\r\n        _safeMint(to, tokenId);\r\n        _setTokenURI(tokenId, uri);\r\n    }\r\n\r\n    // The following functions are overrides required by Solidity.\r\n\r\n    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\r\n        super._burn(tokenId);\r\n    }\r\n\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\r\n    internal\r\n    override(ERC721, ERC721Enumerable)\r\n    {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    view\r\n    override(ERC721, ERC721Enumerable)\r\n    returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId)\r\n    public\r\n    view\r\n    override(ERC721, ERC721URIStorage)\r\n    returns (string memory)\r\n    {\r\n        return super.tokenURI(tokenId);\r\n    }\r\n}"
    },
    "contracts/PoolRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity ^0.8.17;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./interfaces/IPoolRewarder.sol\";\r\n\r\ncontract PoolRewarder is IPoolRewarder {\r\n//    IERC20 public immutable stakingToken;\r\n    IERC20 public immutable rewardsToken;\r\n\r\n    address public owner;\r\n    address public pool;\r\n\r\n    // Duration of rewards to be paid out (in seconds)\r\n    uint public duration;\r\n    // Timestamp of when the rewards finish\r\n    uint public finishAt;\r\n    // Minimum of last updated time and reward finish time\r\n    uint public updatedAt;\r\n    // Reward to be paid out per second\r\n    uint public rewardRate;\r\n    // Sum of (reward rate * dt * 1e18 / total supply)\r\n    uint public rewardPerTokenStored;\r\n    // User address => rewardPerTokenStored\r\n    mapping(address => uint) public userRewardPerTokenPaid;\r\n    // User address => rewards to be claimed\r\n    mapping(address => uint) public rewards;\r\n\r\n    // Total staked\r\n    uint public totalSupply;\r\n    // User address => staked amount\r\n    mapping(address => uint) public balanceOf;\r\n\r\n//    constructor(address _stakingToken, address _rewardToken) {\r\n    constructor(address _rewardToken, address _pool) {\r\n        owner = msg.sender;\r\n        pool = _pool;\r\n//        stakingToken = IERC20(_stakingToken);\r\n        rewardsToken = IERC20(_rewardToken);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Unauthorized: onlyOwner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyPool() {\r\n        require(msg.sender == pool, \"Unauthorized: onlyPool\");\r\n        _;\r\n    }\r\n\r\n    modifier updateReward(address _account) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        updatedAt = lastTimeRewardApplicable();\r\n\r\n        if (_account != address(0)) {\r\n            rewards[_account] = earned(_account);\r\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\r\n        }\r\n\r\n        _;\r\n    }\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint) {\r\n        return _min(finishAt, block.timestamp);\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint) {\r\n        if (totalSupply == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n\r\n        return\r\n        rewardPerTokenStored +\r\n        (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\r\n        totalSupply;\r\n    }\r\n\r\n    function stakeFor(uint _amount, address _stakeFor) external updateReward(_stakeFor) onlyPool {\r\n        require(_amount > 0, \"amount = 0\");\r\n//        stakingToken.transferFrom(msg.sender, address(this), _amount);\r\n        balanceOf[_stakeFor] += _amount;\r\n        totalSupply += _amount;\r\n        emit Staked(_stakeFor, _amount, block.timestamp);\r\n    }\r\n\r\n    function withdrawFor(uint _amount, address _unstakeFor) external updateReward(_unstakeFor) onlyPool returns (uint256){\r\n        require(_amount > 0, \"amount = 0\");\r\n        if(balanceOf[_unstakeFor] > 0) {\r\n            uint256 amountToUnstake = _amount > balanceOf[_unstakeFor] ? balanceOf[_unstakeFor] : _amount;\r\n            balanceOf[_unstakeFor] -= amountToUnstake;\r\n            totalSupply -= amountToUnstake;\r\n            //        stakingToken.transfer(msg.sender, _amount);\r\n            emit Unstaked(_unstakeFor, amountToUnstake, block.timestamp);\r\n            return amountToUnstake;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function earned(address _account) public view returns (uint) {\r\n        return\r\n        ((balanceOf[_account] *\r\n        (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18) +\r\n        rewards[_account];\r\n    }\r\n\r\n    function getRewardsFor(address _user) external updateReward(_user) {\r\n        uint reward = rewards[_user];\r\n        if (reward > 0) {\r\n            rewards[_user] = 0;\r\n            rewardsToken.transfer(_user, reward);\r\n        }\r\n    }\r\n\r\n    function setRewardsDuration(uint _duration) external onlyOwner {\r\n        require(finishAt < block.timestamp, \"reward duration not finished\");\r\n        duration = _duration;\r\n    }\r\n\r\n    function notifyRewardAmount(uint _amount)\r\n    external\r\n    onlyOwner\r\n    updateReward(address(0))\r\n    {\r\n        if (block.timestamp >= finishAt) {\r\n            rewardRate = _amount / duration;\r\n        } else {\r\n            uint remainingRewards = (finishAt - block.timestamp) * rewardRate;\r\n            rewardRate = (_amount + remainingRewards) / duration;\r\n        }\r\n\r\n        require(rewardRate > 0, \"reward rate = 0\");\r\n        require(\r\n            rewardRate * duration <= rewardsToken.balanceOf(address(this)),\r\n            \"reward amount > balance\"\r\n        );\r\n\r\n        finishAt = block.timestamp + duration;\r\n        updatedAt = block.timestamp;\r\n    }\r\n\r\n    function _min(uint x, uint y) private pure returns (uint) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    /**\r\n      * @dev emitted after staking in the pool\r\n      * @param user the address that staked\r\n      * @param timestamp of the staking\r\n    **/\r\n    event Staked(address user, uint256 indexed amount, uint256 timestamp);\r\n\r\n    /**\r\n      * @dev emitted after staking in the pool\r\n      * @param user the address that unstaked\r\n      * @param timestamp of the unstaking\r\n    **/\r\n    event Unstaked(address user, uint256 indexed amount, uint256 timestamp);\r\n}\r\n"
    },
    "contracts/mock/AntiReentrantDiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\n\r\nimport \"../ReentrancyGuardKeccak.sol\";\r\n\r\ncontract AntiReentrantDiamondStorage is ReentrancyGuardKeccak {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    /* ========== RECEIVE AVAX FUNCTION ========== */\r\n    receive() external payable {}\r\n\r\n    function antiReentrant() public nonReentrant {\r\n        payable(msg.sender).safeTransferETH(100);\r\n    }\r\n}\r\n"
    },
    "contracts/mock/ReentrantAttack.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"./AntiReentrantDiamondStorage.sol\";\r\n\r\ncontract ReentrantAttack {\r\n\r\n    uint256 callCounter = 0;\r\n    uint256 targetCallCount = 1;\r\n\r\n    /* ========== RECEIVE AVAX FUNCTION ========== */\r\n    receive() external payable {\r\n        if (callCounter < targetCallCount) {\r\n            callCounter += 1;\r\n            AntiReentrantDiamondStorage(payable(msg.sender)).antiReentrant();\r\n        } else {\r\n            callCounter = 0;\r\n        }\r\n    }\r\n\r\n    function changeTargetCallCount(uint256 _newCount) public {\r\n        targetCallCount = _newCount;\r\n    }\r\n\r\n    function callAntiReentrant(address payable _antiReentrant) external {\r\n        callCounter += 1;\r\n        AntiReentrantDiamondStorage(_antiReentrant).antiReentrant();\r\n    }\r\n}\r\n"
    },
    "contracts/facets/avalanche/BeefyFinanceAvalancheFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"../../ReentrancyGuardKeccak.sol\";\r\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\r\nimport \"../../lib/SolvencyMethods.sol\";\r\nimport \"../../interfaces/facets/avalanche/IBeefyFinance.sol\";\r\n\r\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\r\n\r\n//This path is updated during deployment\r\nimport \"../../lib/avalanche/DeploymentConstants.sol\";\r\nimport \"../../interfaces/facets/avalanche/IBeefyFinance.sol\";\r\n\r\ncontract BeefyFinanceAvalancheFacet is ReentrancyGuardKeccak, SolvencyMethods {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    // Vaults\r\n    address private constant MOO_PNG_AVAX_USDC_LP = 0xf3340EdF16563D52C7E7C576F2fCC8f3D52464aB;\r\n    address private constant MOO_PNG_AVAX_USDCe_LP = 0x9B02209a331c072637C6eBd34cdCD6b6A16987a9;\r\n    address private constant MOO_TJ_AVAX_USDC_LP = 0x7E5bC7088aB3Da3e7fa1Aa7ceF1dC73F5B00681c;\r\n\r\n    // LPs\r\n    address private constant PNG_AVAX_USDC_LP = 0x0e0100Ab771E9288e0Aa97e11557E6654C3a9665;\r\n    address private constant PNG_AVAX_USDCe_LP = 0xbd918Ed441767fe7924e99F6a0E0B568ac1970D9;\r\n    address private constant TJ_AVAX_USDC_LP = 0xf4003F4efBE8691B60249E6afbD307aBE7758adb;\r\n\r\n    // ----- STAKE -----\r\n\r\n    /**\r\n      * Stakes PNG_AVAX_USDC_LP in the Beefy protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of PNG_AVAX_USDC_LP to be staked\r\n    **/\r\n    function stakePngUsdcAvaxLpBeefy(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\r\n            lpTokenAddress: PNG_AVAX_USDC_LP,\r\n            vaultAddress: MOO_PNG_AVAX_USDC_LP,\r\n            lpTokenSymbol: \"PNG_AVAX_USDC_LP\",\r\n            vaultTokenSymbol: \"MOO_PNG_AVAX_USDC_LP\",\r\n            amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Stakes PNG_AVAX_USDCe_LP in the Beefy protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of PNG_AVAX_USDCe_LP to be staked\r\n    **/\r\n    function stakePngUsdceAvaxLpBeefy(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\r\n        lpTokenAddress: PNG_AVAX_USDCe_LP,\r\n        vaultAddress: MOO_PNG_AVAX_USDCe_LP,\r\n        lpTokenSymbol: \"PNG_AVAX_USDCe_LP\",\r\n        vaultTokenSymbol: \"MOO_PNG_AVAX_USDCe_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Stakes TJ_AVAX_USDC_LP in the Beefy protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of TJ_AVAX_USDC_LP to be staked\r\n    **/\r\n    function stakeTjUsdcAvaxLpBeefy(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\r\n        lpTokenAddress: TJ_AVAX_USDC_LP,\r\n        vaultAddress: MOO_TJ_AVAX_USDC_LP,\r\n        lpTokenSymbol: \"TJ_AVAX_USDC_LP\",\r\n        vaultTokenSymbol: \"MOO_TJ_AVAX_USDC_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    // ----- UNSTAKE -----\r\n\r\n    /**\r\n      * Unstakes PNG_AVAX_USDC_LP from the Beefy protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of PNG_AVAX_USDC_LP to be unstaked\r\n    **/\r\n    function unstakePngUsdcAvaxLpBeefy(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\r\n        lpTokenAddress: PNG_AVAX_USDC_LP,\r\n        vaultAddress: MOO_PNG_AVAX_USDC_LP,\r\n        lpTokenSymbol: \"PNG_AVAX_USDC_LP\",\r\n        vaultTokenSymbol: \"MOO_PNG_AVAX_USDC_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Unstakes PNG_AVAX_USDCe_LP from the Beefy protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of PNG_AVAX_USDCe_LP to be unstaked\r\n    **/\r\n    function unstakePngUsdceAvaxLpBeefy(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\r\n        lpTokenAddress: PNG_AVAX_USDCe_LP,\r\n        vaultAddress: MOO_PNG_AVAX_USDCe_LP,\r\n        lpTokenSymbol: \"PNG_AVAX_USDCe_LP\",\r\n        vaultTokenSymbol: \"MOO_PNG_AVAX_USDCe_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    /**\r\n      * Untakes TJ_AVAX_USDC_LP from the Beefy protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param amount amount of TJ_AVAX_USDC_LP to be unstaked\r\n    **/\r\n    function unstakeTjUsdcAvaxLpBeefy(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\r\n        _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\r\n        lpTokenAddress: TJ_AVAX_USDC_LP,\r\n        vaultAddress: MOO_TJ_AVAX_USDC_LP,\r\n        lpTokenSymbol: \"TJ_AVAX_USDC_LP\",\r\n        vaultTokenSymbol: \"MOO_TJ_AVAX_USDC_LP\",\r\n        amount: amount\r\n        }));\r\n    }\r\n\r\n    // ----- PRIVATE METHODS -----\r\n\r\n\r\n    /**\r\n      * Stakes {stakingDetails.lpTokenAddress} LP token in the Beefy protocol\r\n      * @dev This function uses the redstone-evm-connector\r\n      * @param stakingDetails IBeefyFinance.BeefyStakingDetails staking details\r\n    **/\r\n    function _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails memory stakingDetails) private {\r\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\r\n\r\n        require(stakingDetails.amount > 0, \"Cannot stake 0 tokens\");\r\n        // _ACTIVE = 2\r\n        require(tokenManager.tokenToStatus(stakingDetails.lpTokenAddress) == 2, \"LP token not supported\");\r\n        require(tokenManager.tokenToStatus(stakingDetails.vaultAddress) == 2, \"Vault token not supported\");\r\n        require(IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this)) >= stakingDetails.amount, \"Not enough LP token available\");\r\n\r\n        IERC20Metadata(stakingDetails.lpTokenAddress).approve(stakingDetails.vaultAddress, stakingDetails.amount);\r\n\r\n        IBeefyFinance vaultContract = IBeefyFinance(stakingDetails.vaultAddress);\r\n\r\n        vaultContract.deposit(stakingDetails.amount);\r\n\r\n        // Add/remove owned tokens\r\n        if(vaultContract.balanceOf(address(this)) > 0) {\r\n            DiamondStorageLib.addOwnedAsset(stakingDetails.vaultTokenSymbol, stakingDetails.vaultAddress);\r\n        }\r\n        if(IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(stakingDetails.lpTokenSymbol);\r\n        }\r\n\r\n        emit Staked(msg.sender, stakingDetails.lpTokenSymbol, stakingDetails.vaultAddress, stakingDetails.amount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n              * Unstakes {stakingDetails.lpTokenAddress} LP token in the Beefy protocol\r\n              * @dev This function uses the redstone-evm-connector\r\n              * @param stakingDetails IBeefyFinance.BeefyStakingDetails staking details\r\n    **/\r\n    function _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails memory stakingDetails) private {\r\n        IBeefyFinance vaultContract = IBeefyFinance(stakingDetails.vaultAddress);\r\n        uint256 initialStakedBalance = vaultContract.balanceOf(address(this));\r\n\r\n        require(initialStakedBalance >= stakingDetails.amount, \"Cannot unstake more than was initially staked\");\r\n\r\n        vaultContract.withdraw(stakingDetails.amount);\r\n\r\n        // Add/remove owned tokens\r\n        if(IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this)) > 0) {\r\n            DiamondStorageLib.addOwnedAsset(stakingDetails.lpTokenSymbol, stakingDetails.lpTokenAddress);\r\n        }\r\n        if(vaultContract.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(stakingDetails.vaultTokenSymbol);\r\n        }\r\n\r\n        emit Unstaked(msg.sender, stakingDetails.lpTokenSymbol, stakingDetails.vaultAddress, stakingDetails.amount, block.timestamp);\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        DiamondStorageLib.enforceIsContractOwner();\r\n        _;\r\n    }\r\n\r\n    /* ========== RECEIVE AVAX FUNCTION ========== */\r\n    receive() external payable {}\r\n\r\n    /**\r\n        * @dev emitted when user stakes an asset\r\n        * @param user the address executing staking\r\n        * @param asset the asset that was staked\r\n        * @param vault address of the vault token\r\n        * @param amount of the asset that was staked\r\n        * @param timestamp of staking\r\n    **/\r\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 amount, uint256 timestamp);\r\n\r\n    /**\r\n        * @dev emitted when user unstakes an asset\r\n        * @param user the address executing unstaking\r\n        * @param asset the asset that was unstaked\r\n        * @param vault address of the vault token\r\n        * @param amount of the asset that was unstaked\r\n        * @param timestamp of unstaking\r\n    **/\r\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 amount, uint256 timestamp);\r\n}"
    },
    "contracts/interfaces/facets/avalanche/IBeefyFinance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity ^0.8.4;\r\n\r\ninterface IBeefyFinance {\r\n    // -- Deposit/Withdraw underlying LP token --\r\n    function depositAll() external;\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function withdrawAll() external;\r\n\r\n    // ------------------------------------------\r\n\r\n    // User's balance of the vault's token\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    // Vault's balance of the underlying token\r\n    function balance() external view returns (uint256);\r\n\r\n    // Total supply of the vault's token\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // Decimals of the vault's token\r\n    function decimals() external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    // ---INTERFACE-----\r\n    struct BeefyStakingDetails {\r\n        address lpTokenAddress;\r\n        address vaultAddress;\r\n        bytes32 lpTokenSymbol;\r\n        bytes32 vaultTokenSymbol;\r\n        uint256 amount;\r\n    }\r\n\r\n}"
    },
    "contracts/facets/mock/AssetsOperationsMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"../AssetsOperationsFacet.sol\";\r\n\r\ncontract AssetsOperationsMock is AssetsOperationsFacet {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    /**\r\n    * Withdraws an amount of a defined asset from the loan\r\n    * This method does not perform any solvency check hence allows the user to withdraw whatever is available in the loan\r\n    * @dev This function uses the redstone-evm-connector\r\n    * @param _withdrawnAsset asset to be withdrawn\r\n    * @param _amount to be withdrawn\r\n    **/\r\n    function withdraw(bytes32 _withdrawnAsset, uint256 _amount) public virtual override onlyOwner nonReentrant{\r\n        IERC20Metadata token = getERC20TokenInstance(_withdrawnAsset, true);\r\n        require(getBalance(_withdrawnAsset) >= _amount, \"There is not enough funds to withdraw\");\r\n\r\n        address(token).safeTransfer(msg.sender, _amount);\r\n        if (token.balanceOf(address(this)) == 0) {\r\n            DiamondStorageLib.removeOwnedAsset(_withdrawnAsset);\r\n        }\r\n\r\n        emit Withdrawn(msg.sender, _withdrawnAsset, _amount, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "contracts/deployment/avalanche/UsdcBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../LinearIndex.sol\";\r\n\r\ncontract UsdcBorrowIndex is LinearIndex {}"
    },
    "contracts/mock/OpenBorrowersRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../interfaces/IBorrowersRegistry.sol\";\r\n\r\n/**\r\n * @title OpenBorrowersRegistry\r\n * It the simpled borrowers registry that allows every account\r\n * Should be used for test purpose only\r\n */\r\ncontract OpenBorrowersRegistry is IBorrowersRegistry {\r\n    function canBorrow(address _account) external pure override returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function getLoanForOwner(address _user) external pure override returns (address) {\r\n        return address(0);\r\n    }\r\n\r\n    function getOwnerOfLoan(address _loan) external pure override returns (address) {\r\n        return address(0);\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockBorrowersRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../interfaces/IBorrowersRegistry.sol\";\r\n\r\n/**\r\n * @title MockBorrowersRegistry\r\n * Should be used for test purpose only\r\n */\r\ncontract MockBorrowersRegistry is IBorrowersRegistry {\r\n\r\n    mapping(address => address) public ownersToLoans;\r\n    mapping(address => address) public loansToOwners;\r\n\r\n    address[] loans;\r\n\r\n    function updateRegistry(address loan, address owner) public  {\r\n        ownersToLoans[owner] = loan;\r\n        loansToOwners[loan] = owner;\r\n        loans.push(loan);\r\n    }\r\n\r\n    function canBorrow(address _account) external view override returns (bool) {\r\n        return loansToOwners[_account] != address(0);\r\n    }\r\n\r\n    function getLoanForOwner(address _user) external view override returns (address) {\r\n        return ownersToLoans[_user];\r\n    }\r\n\r\n    function getOwnerOfLoan(address _loan) external view override returns (address) {\r\n        return loansToOwners[_loan];\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockTokenManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"../TokenManager.sol\";\r\n\r\ncontract MockTokenManager is TokenManager {\r\n    address factoryAddress;\r\n\r\n    function setFactoryAddress(address _newAddress) external {\r\n        factoryAddress = _newAddress;\r\n    }\r\n\r\n    function getSmartLoansFactoryAddress() public view override returns (address) {\r\n        return factoryAddress;\r\n    }\r\n}\r\n"
    },
    "contracts/WrappedNativeTokenPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 5bae95ca244e96444fe80078195944f6637e72d8;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./Pool.sol\";\r\nimport \"./interfaces/IWrappedNativeToken.sol\";\r\n\r\n/**\r\n * @title Pool\r\n * @dev Contract allowing user to deposit to and borrow from a single pot\r\n * Depositors are rewarded with the interest rates collected from borrowers.\r\n * Rates are compounded every second and getters always return the current deposit and borrowing balance.\r\n * The interest rates calculation is delegated to the external calculator contract.\r\n */\r\ncontract WrappedNativeTokenPool is Pool {\r\n    using TransferHelper for address payable;\r\n    using TransferHelper for address;\r\n\r\n    /**\r\n     * Wraps and deposits amount attached to the transaction\r\n     **/\r\n    function depositNativeToken() public payable virtual {\r\n        if(msg.value == 0) revert ZeroDepositAmount();\r\n\r\n        _accumulateDepositInterest(msg.sender);\r\n\r\n        if(totalSupplyCap != 0){\r\n            if(_deposited[address(this)] + msg.value > totalSupplyCap) revert TotalSupplyCapBreached();\r\n        }\r\n\r\n        IWrappedNativeToken(tokenAddress).deposit{value : msg.value}();\r\n\r\n        _mint(msg.sender, msg.value);\r\n        _deposited[address(this)] += msg.value;\r\n        _updateRates();\r\n\r\n        if (address(poolRewarder) != address(0)) {\r\n            poolRewarder.stakeFor(msg.value, msg.sender);\r\n        }\r\n\r\n        emit Deposit(msg.sender, msg.value, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * Unwraps and withdraws selected amount from the user deposits\r\n     * @dev _amount the amount to be withdrawn\r\n     **/\r\n    function withdrawNativeToken(uint256 _amount) external nonReentrant {\r\n        if(_amount > IERC20(tokenAddress).balanceOf(address(this))) revert InsufficientPoolFunds();\r\n\r\n        _accumulateDepositInterest(msg.sender);\r\n\r\n        if(_amount > _deposited[address(this)]) revert BurnAmountExceedsBalance();\r\n        // verified in \"require\" above\r\n        unchecked {\r\n            _deposited[address(this)] -= _amount;\r\n        }\r\n        _burn(msg.sender, _amount);\r\n\r\n        IWrappedNativeToken(tokenAddress).withdraw(_amount);\r\n        payable(msg.sender).safeTransferETH(_amount);\r\n\r\n        _updateRates();\r\n\r\n        if (address(poolRewarder) != address(0)) {\r\n            poolRewarder.withdrawFor(_amount, msg.sender);\r\n        }\r\n\r\n        emit Withdrawal(msg.sender, _amount, block.timestamp);\r\n    }\r\n\r\n    /* ========== RECEIVE AVAX FUNCTION ========== */\r\n    //needed for withdrawNativeToken\r\n    receive() external payable {}\r\n}"
    },
    "contracts/deployment/avalanche/WavaxPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 5bae95ca244e96444fe80078195944f6637e72d8;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../WrappedNativeTokenPool.sol\";\r\n\r\n\r\n/**\r\n * @title WavaxPool\r\n * @dev Contract allowing user to deposit to and borrow WAVAX from a dedicated user account\r\n */\r\ncontract WavaxPool is WrappedNativeTokenPool {\r\n    // Returns max. acceptable pool utilisation after borrow action\r\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\r\n        return 0.8e18;\r\n    }\r\n}"
    },
    "contracts/deployment/avalanche/WavaxPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 5bae95ca244e96444fe80078195944f6637e72d8;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./WavaxPool.sol\";\r\n\r\n\r\n/**\r\n * @title WavaxPoolFactory\r\n * @dev Contract factory allowing anyone to deploy a pool contract\r\n */\r\ncontract WavaxPoolFactory {\r\n    function deployPool() public {\r\n        WavaxPool pool = new WavaxPool();\r\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after pool is deployed by any user\r\n     * @param user the address initiating the deployment\r\n     * @param poolAddress of deployed pool\r\n     * @param timestamp of the deployment\r\n     **/\r\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\r\n}"
    },
    "contracts/deployment/avalanche/UsdcPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../Pool.sol\";\r\n\r\n\r\n/**\r\n * @title UsdcPool\r\n * @dev Contract allowing user to deposit to and borrow USDC from a dedicated user account\r\n */\r\ncontract UsdcPool is Pool {\r\n}"
    },
    "contracts/deployment/avalanche/UsdcPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./UsdcPool.sol\";\r\n\r\n\r\n/**\r\n * @title PoolFactory\r\n * @dev Contract factory allowing anyone to deploy a pool contract\r\n */\r\ncontract UsdcPoolFactory {\r\n    function deployPool() public {\r\n        UsdcPool pool = new UsdcPool();\r\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev emitted after pool is deployed by any user\r\n     * @param user the address initiating the deployment\r\n     * @param poolAddress of deployed pool\r\n     * @param timestamp of the deployment\r\n     **/\r\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\r\n}"
    },
    "contracts/mock/MockNFTAccess.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../abstract/NFTAccess.sol\";\r\n\r\ncontract MockNFTAccess is NFTAccess {\r\n    function initialize() external initializer {\r\n        __Ownable_init();\r\n    }\r\n\r\n    function nftAccessFunction() public view hasAccessNFT returns (uint256 mockResult) {\r\n        mockResult = 777;\r\n    }\r\n}\r\n"
    },
    "contracts/SmartLoansFactoryRestrictedAccess.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: da3db6d98ac8305a3d43391d37f1b9a30e456c4e;\r\npragma solidity 0.8.17;\r\n\r\nimport \"./SmartLoansFactory.sol\";\r\n\r\ncontract SmartLoansFactoryRestrictedAccess is SmartLoansFactory {\r\n    bytes32 internal constant ACCESS_NFT_SLOT = bytes32(uint256(keccak256('WHITELIST_SLOT_1670605213')) - 1);\r\n\r\n    function getWhitelistingMapping() internal view returns(mapping(address=>bool) storage result){\r\n        bytes32 slot = ACCESS_NFT_SLOT;\r\n        assembly{\r\n            result.slot := sload(slot)\r\n        }\r\n    }\r\n    \r\n    function whitelistBorrowers(address[] memory _borrowers) external onlyOwner {\r\n\r\n        for(uint i; i<_borrowers.length; i++){\r\n            getWhitelistingMapping()[_borrowers[i]] = true;\r\n            emit BorrowerWhitelisted(_borrowers[i], msg.sender, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function delistBorrowers(address[] memory _borrowers) external onlyOwner {\r\n        for(uint i; i<_borrowers.length; i++){\r\n            getWhitelistingMapping()[_borrowers[i]] = false;\r\n            emit BorrowerDelisted(_borrowers[i], msg.sender, block.timestamp);\r\n        }\r\n    }\r\n\r\n    function isBorrowerWhitelisted(address _borrower) public view returns(bool){\r\n        return getWhitelistingMapping()[_borrower];\r\n    }\r\n\r\n    function createLoan() public virtual override hasNoLoan canCreatePrimeAccount(msg.sender) returns (SmartLoanDiamondBeacon) {\r\n        return super.createLoan();\r\n    }\r\n\r\n    function createAndFundLoan(bytes32 _fundedAsset, address _assetAddress, uint256 _amount) public virtual override hasNoLoan canCreatePrimeAccount(msg.sender) returns (SmartLoanDiamondBeacon) {\r\n        return super.createAndFundLoan(_fundedAsset, _assetAddress, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev emitted when a new borrower gets whitelisted\r\n     * @param borrower the address being whitelisted\r\n     * @param performer the address initiating whitelisting\r\n     * @param timestamp of the whitelisting\r\n     **/\r\n    event BorrowerWhitelisted(address indexed borrower, address performer, uint256 timestamp);\r\n    \r\n    /**\r\n     * @dev emitted when a borrower gets delisted\r\n     * @param borrower the address being delisted\r\n     * @param performer the address initiating delisting\r\n     * @param timestamp of the delisting\r\n     **/\r\n    event BorrowerDelisted(address indexed borrower, address performer, uint256 timestamp);\r\n\r\n    modifier canCreatePrimeAccount(address _borrower) {\r\n        require(isBorrowerWhitelisted(_borrower), \"Only whitelisted borrowers can create a Prime Account.\");\r\n        _;\r\n    }\r\n}\r\n"
    },
    "contracts/facets/mock/MockSolvencyFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"../SolvencyFacetProd.sol\";\r\n\r\ncontract MockSolvencyFacet is SolvencyFacetProd {}\r\n"
    },
    "contracts/integrations/avalanche/PangolinIntermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\r\npragma solidity 0.8.17;\r\n\r\nimport \"../UniswapV2Intermediary.sol\";\r\nimport \"../../lib/avalanche/DeploymentConstants.sol\";\r\n\r\n/**\r\n * @title PangolinIntermediary\r\n * @dev Contract allows user to swap ERC20 tokens on DEX\r\n * This implementation uses the Pangolin DEX\r\n */\r\ncontract PangolinIntermediary is UniswapV2Intermediary {\r\n\r\n    function getNativeTokenAddress() override internal pure returns (address) {\r\n        return DeploymentConstants.getNativeToken();\r\n    }\r\n}"
    },
    "contracts/facets/mock/MockSolvencyFacetAlwaysSolvent.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\ncontract MockSolvencyFacetAlwaysSolvent {\r\n    /**\r\n    * Always returns true - used in test suits\r\n    **/\r\n    function isSolvent() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function canRepayDebtFully() external view returns (bool) {\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/facets/avalanche/IYakStakingVectorSAV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n// Last deployed from commit: ;\r\npragma solidity 0.8.17;\r\n\r\ninterface IYakStakingVectorSAV2 {\r\n    function totalDeposits() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function depositFor(address account, uint256 amount) external;\r\n\r\n    function deposit(uint256 amount) external;\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}"
    },
    "contracts/interfaces/facets/IDiamondInit.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface IDiamondInit {\r\n    function init() external;\r\n}\r\n"
    },
    "contracts/interfaces/facets/IUniswapV2DEXFacet.sol": {
      "content": "pragma solidity ^0.8.17;\r\n\r\ninterface IUniswapV2DEXFacet {\r\n}\r\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity ^0.8.10;\r\n\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\r\n// Subject to the MIT license.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c;\r\n    unchecked { c = a + b; }\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        uint256 c;\r\n    unchecked { c = a + b; }\r\n        require(c >= a, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction underflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot underflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c;\r\n    unchecked { c = a * b; }\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c;\r\n    unchecked { c = a * b; }\r\n        require(c / a == b, errorMessage);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers.\r\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"
    },
    "contracts/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\r\npragma solidity ^0.8.10;\r\n\r\nimport \"./lib/SafeMath.sol\";\r\n\r\ncontract Timelock {\r\n    using SafeMath for uint;\r\n\r\n    event NewAdmin(address indexed newAdmin);\r\n    event NewPendingAdmin(address indexed newPendingAdmin);\r\n    event NewDelay(uint indexed newDelay);\r\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\r\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\r\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\r\n\r\n    uint public constant GRACE_PERIOD = 7 days;\r\n    uint public constant MINIMUM_DELAY = 1 days;\r\n    uint public constant MAXIMUM_DELAY = 30 days;\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    uint public delay;\r\n\r\n    mapping (bytes32 => bool) public queuedTransactions;\r\n\r\n\r\n    constructor(address admin_, uint delay_) public {\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n\r\n        admin = admin_;\r\n        delay = delay_;\r\n    }\r\n\r\n    fallback() external payable { }\r\n\r\n    function setDelay(uint delay_) public {\r\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\r\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\r\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\r\n        delay = delay_;\r\n\r\n        emit NewDelay(delay);\r\n    }\r\n\r\n    function acceptAdmin() public {\r\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\r\n        admin = msg.sender;\r\n        pendingAdmin = address(0);\r\n\r\n        emit NewAdmin(admin);\r\n    }\r\n\r\n    function setPendingAdmin(address pendingAdmin_) public {\r\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\r\n        pendingAdmin = pendingAdmin_;\r\n\r\n        emit NewPendingAdmin(pendingAdmin);\r\n    }\r\n\r\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\r\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\r\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = true;\r\n\r\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\r\n        return txHash;\r\n    }\r\n\r\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\r\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        queuedTransactions[txHash] = false;\r\n\r\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\r\n    }\r\n\r\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\r\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\r\n\r\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\r\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\r\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\r\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\r\n\r\n        queuedTransactions[txHash] = false;\r\n\r\n        bytes memory callData;\r\n\r\n        if (bytes(signature).length == 0) {\r\n            callData = data;\r\n        } else {\r\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\r\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\r\n\r\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function getBlockTimestamp() internal view returns (uint) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp;\r\n    }\r\n}"
    },
    "contracts/lib/SmartLoanLib.sol": {
      "content": ""
    },
    "contracts/mock/DestructableContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @title DestructableContract\r\n * @dev For tests\r\n */\r\ncontract DestructableContract {\r\n    fallback() external payable {\r\n        //just receive funds\r\n    }\r\n\r\n    function destruct(address payable receiverOfFunds) public {\r\n        selfdestruct(receiverOfFunds);\r\n    }\r\n}\r\n"
    },
    "contracts/mock/MockSmartLoanLogicFacetSetValues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\ncontract MockSolvencyFacetConstantDebt {\r\n    /**\r\n    * Always returns 2137 - used in test suits\r\n    **/\r\n    function getDebt() public pure returns (uint256) {\r\n        return 2137;\r\n    }\r\n}\r\n"
    },
    "contracts/mock/WAVAX.sol": {
      "content": "/**\r\n *Submitted for verification at snowtrace.io on 2021-10-26\r\n*/\r\n\r\n// Copyright (C) 2015, 2016, 2017 Dapphub\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n// Contract name, token name, and token symbol modified by Ava Labs 2020\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract WAVAX {\r\n    string public name     = \"Wrapped AVAX\";\r\n    string public symbol   = \"WAVAX\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    receive() external payable {\r\n        deposit();\r\n    }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        payable(msg.sender).transfer(wad);\r\n        emit Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n    public\r\n    returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n//        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n//        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/*\r\n                    GNU GENERAL PUBLIC LICENSE\r\n                       Version 3, 29 June 2007\r\n\r\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\r\n Everyone is permitted to copy and distribute verbatim copies\r\n of this license document, but changing it is not allowed.\r\n\r\n                            Preamble\r\n\r\n  The GNU General Public License is a free, copyleft license for\r\nsoftware and other kinds of works.\r\n\r\n  The licenses for most software and other practical works are designed\r\nto take away your freedom to share and change the works.  By contrast,\r\nthe GNU General Public License is intended to guarantee your freedom to\r\nshare and change all versions of a program--to make sure it remains free\r\nsoftware for all its users.  We, the Free Software Foundation, use the\r\nGNU General Public License for most of our software; it applies also to\r\nany other work released this way by its authors.  You can apply it to\r\nyour programs, too.\r\n\r\n  When we speak of free software, we are referring to freedom, not\r\nprice.  Our General Public Licenses are designed to make sure that you\r\nhave the freedom to distribute copies of free software (and charge for\r\nthem if you wish), that you receive source code or can get it if you\r\nwant it, that you can change the software or use pieces of it in new\r\nfree programs, and that you know you can do these things.\r\n\r\n  To protect your rights, we need to prevent others from denying you\r\nthese rights or asking you to surrender the rights.  Therefore, you have\r\ncertain responsibilities if you distribute copies of the software, or if\r\nyou modify it: responsibilities to respect the freedom of others.\r\n\r\n  For example, if you distribute copies of such a program, whether\r\ngratis or for a fee, you must pass on to the recipients the same\r\nfreedoms that you received.  You must make sure that they, too, receive\r\nor can get the source code.  And you must show them these terms so they\r\nknow their rights.\r\n\r\n  Developers that use the GNU GPL protect your rights with two steps:\r\n(1) assert copyright on the software, and (2) offer you this License\r\ngiving you legal permission to copy, distribute and/or modify it.\r\n\r\n  For the developers' and authors' protection, the GPL clearly explains\r\nthat there is no warranty for this free software.  For both users' and\r\nauthors' sake, the GPL requires that modified versions be marked as\r\nchanged, so that their problems will not be attributed erroneously to\r\nauthors of previous versions.\r\n\r\n  Some devices are designed to deny users access to install or run\r\nmodified versions of the software inside them, although the manufacturer\r\ncan do so.  This is fundamentally incompatible with the aim of\r\nprotecting users' freedom to change the software.  The systematic\r\npattern of such abuse occurs in the area of products for individuals to\r\nuse, which is precisely where it is most unacceptable.  Therefore, we\r\nhave designed this version of the GPL to prohibit the practice for those\r\nproducts.  If such problems arise substantially in other domains, we\r\nstand ready to extend this provision to those domains in future versions\r\nof the GPL, as needed to protect the freedom of users.\r\n\r\n  Finally, every program is threatened constantly by software patents.\r\nStates should not allow patents to restrict development and use of\r\nsoftware on general-purpose computers, but in those that do, we wish to\r\navoid the special danger that patents applied to a free program could\r\nmake it effectively proprietary.  To prevent this, the GPL assures that\r\npatents cannot be used to render the program non-free.\r\n\r\n  The precise terms and conditions for copying, distribution and\r\nmodification follow.\r\n\r\n                       TERMS AND CONDITIONS\r\n\r\n  0. Definitions.\r\n\r\n  \"This License\" refers to version 3 of the GNU General Public License.\r\n\r\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\r\nworks, such as semiconductor masks.\r\n\r\n  \"The Program\" refers to any copyrightable work licensed under this\r\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\r\n\"recipients\" may be individuals or organizations.\r\n\r\n  To \"modify\" a work means to copy from or adapt all or part of the work\r\nin a fashion requiring copyright permission, other than the making of an\r\nexact copy.  The resulting work is called a \"modified version\" of the\r\nearlier work or a work \"based on\" the earlier work.\r\n\r\n  A \"covered work\" means either the unmodified Program or a work based\r\non the Program.\r\n\r\n  To \"propagate\" a work means to do anything with it that, without\r\npermission, would make you directly or secondarily liable for\r\ninfringement under applicable copyright law, except executing it on a\r\ncomputer or modifying a private copy.  Propagation includes copying,\r\ndistribution (with or without modification), making available to the\r\npublic, and in some countries other activities as well.\r\n\r\n  To \"convey\" a work means any kind of propagation that enables other\r\nparties to make or receive copies.  Mere interaction with a user through\r\na computer network, with no transfer of a copy, is not conveying.\r\n\r\n  An interactive user interface displays \"Appropriate Legal Notices\"\r\nto the extent that it includes a convenient and prominently visible\r\nfeature that (1) displays an appropriate copyright notice, and (2)\r\ntells the user that there is no warranty for the work (except to the\r\nextent that warranties are provided), that licensees may convey the\r\nwork under this License, and how to view a copy of this License.  If\r\nthe interface presents a list of user commands or options, such as a\r\nmenu, a prominent item in the list meets this criterion.\r\n\r\n  1. Source Code.\r\n\r\n  The \"source code\" for a work means the preferred form of the work\r\nfor making modifications to it.  \"Object code\" means any non-source\r\nform of a work.\r\n\r\n  A \"Standard Interface\" means an interface that either is an official\r\nstandard defined by a recognized standards body, or, in the case of\r\ninterfaces specified for a particular programming language, one that\r\nis widely used among developers working in that language.\r\n\r\n  The \"System Libraries\" of an executable work include anything, other\r\nthan the work as a whole, that (a) is included in the normal form of\r\npackaging a Major Component, but which is not part of that Major\r\nComponent, and (b) serves only to enable use of the work with that\r\nMajor Component, or to implement a Standard Interface for which an\r\nimplementation is available to the public in source code form.  A\r\n\"Major Component\", in this context, means a major essential component\r\n(kernel, window system, and so on) of the specific operating system\r\n(if any) on which the executable work runs, or a compiler used to\r\nproduce the work, or an object code interpreter used to run it.\r\n\r\n  The \"Corresponding Source\" for a work in object code form means all\r\nthe source code needed to generate, install, and (for an executable\r\nwork) run the object code and to modify the work, including scripts to\r\ncontrol those activities.  However, it does not include the work's\r\nSystem Libraries, or general-purpose tools or generally available free\r\nprograms which are used unmodified in performing those activities but\r\nwhich are not part of the work.  For example, Corresponding Source\r\nincludes interface definition files associated with source files for\r\nthe work, and the source code for shared libraries and dynamically\r\nlinked subprograms that the work is specifically designed to require,\r\nsuch as by intimate data communication or control flow between those\r\nsubprograms and other parts of the work.\r\n\r\n  The Corresponding Source need not include anything that users\r\ncan regenerate automatically from other parts of the Corresponding\r\nSource.\r\n\r\n  The Corresponding Source for a work in source code form is that\r\nsame work.\r\n\r\n  2. Basic Permissions.\r\n\r\n  All rights granted under this License are granted for the term of\r\ncopyright on the Program, and are irrevocable provided the stated\r\nconditions are met.  This License explicitly affirms your unlimited\r\npermission to run the unmodified Program.  The output from running a\r\ncovered work is covered by this License only if the output, given its\r\ncontent, constitutes a covered work.  This License acknowledges your\r\nrights of fair use or other equivalent, as provided by copyright law.\r\n\r\n  You may make, run and propagate covered works that you do not\r\nconvey, without conditions so long as your license otherwise remains\r\nin force.  You may convey covered works to others for the sole purpose\r\nof having them make modifications exclusively for you, or provide you\r\nwith facilities for running those works, provided that you comply with\r\nthe terms of this License in conveying all material for which you do\r\nnot control copyright.  Those thus making or running the covered works\r\nfor you must do so exclusively on your behalf, under your direction\r\nand control, on terms that prohibit them from making any copies of\r\nyour copyrighted material outside their relationship with you.\r\n\r\n  Conveying under any other circumstances is permitted solely under\r\nthe conditions stated below.  Sublicensing is not allowed; section 10\r\nmakes it unnecessary.\r\n\r\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\r\n\r\n  No covered work shall be deemed part of an effective technological\r\nmeasure under any applicable law fulfilling obligations under article\r\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\r\nsimilar laws prohibiting or restricting circumvention of such\r\nmeasures.\r\n\r\n  When you convey a covered work, you waive any legal power to forbid\r\ncircumvention of technological measures to the extent such circumvention\r\nis effected by exercising rights under this License with respect to\r\nthe covered work, and you disclaim any intention to limit operation or\r\nmodification of the work as a means of enforcing, against the work's\r\nusers, your or third parties' legal rights to forbid circumvention of\r\ntechnological measures.\r\n\r\n  4. Conveying Verbatim Copies.\r\n\r\n  You may convey verbatim copies of the Program's source code as you\r\nreceive it, in any medium, provided that you conspicuously and\r\nappropriately publish on each copy an appropriate copyright notice;\r\nkeep intact all notices stating that this License and any\r\nnon-permissive terms added in accord with section 7 apply to the code;\r\nkeep intact all notices of the absence of any warranty; and give all\r\nrecipients a copy of this License along with the Program.\r\n\r\n  You may charge any price or no price for each copy that you convey,\r\nand you may offer support or warranty protection for a fee.\r\n\r\n  5. Conveying Modified Source Versions.\r\n\r\n  You may convey a work based on the Program, or the modifications to\r\nproduce it from the Program, in the form of source code under the\r\nterms of section 4, provided that you also meet all of these conditions:\r\n\r\n    a) The work must carry prominent notices stating that you modified\r\n    it, and giving a relevant date.\r\n\r\n    b) The work must carry prominent notices stating that it is\r\n    released under this License and any conditions added under section\r\n    7.  This requirement modifies the requirement in section 4 to\r\n    \"keep intact all notices\".\r\n\r\n    c) You must license the entire work, as a whole, under this\r\n    License to anyone who comes into possession of a copy.  This\r\n    License will therefore apply, along with any applicable section 7\r\n    additional terms, to the whole of the work, and all its parts,\r\n    regardless of how they are packaged.  This License gives no\r\n    permission to license the work in any other way, but it does not\r\n    invalidate such permission if you have separately received it.\r\n\r\n    d) If the work has interactive user interfaces, each must display\r\n    Appropriate Legal Notices; however, if the Program has interactive\r\n    interfaces that do not display Appropriate Legal Notices, your\r\n    work need not make them do so.\r\n\r\n  A compilation of a covered work with other separate and independent\r\nworks, which are not by their nature extensions of the covered work,\r\nand which are not combined with it such as to form a larger program,\r\nin or on a volume of a storage or distribution medium, is called an\r\n\"aggregate\" if the compilation and its resulting copyright are not\r\nused to limit the access or legal rights of the compilation's users\r\nbeyond what the individual works permit.  Inclusion of a covered work\r\nin an aggregate does not cause this License to apply to the other\r\nparts of the aggregate.\r\n\r\n  6. Conveying Non-Source Forms.\r\n\r\n  You may convey a covered work in object code form under the terms\r\nof sections 4 and 5, provided that you also convey the\r\nmachine-readable Corresponding Source under the terms of this License,\r\nin one of these ways:\r\n\r\n    a) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by the\r\n    Corresponding Source fixed on a durable physical medium\r\n    customarily used for software interchange.\r\n\r\n    b) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by a\r\n    written offer, valid for at least three years and valid for as\r\n    long as you offer spare parts or customer support for that product\r\n    model, to give anyone who possesses the object code either (1) a\r\n    copy of the Corresponding Source for all the software in the\r\n    product that is covered by this License, on a durable physical\r\n    medium customarily used for software interchange, for a price no\r\n    more than your reasonable cost of physically performing this\r\n    conveying of source, or (2) access to copy the\r\n    Corresponding Source from a network server at no charge.\r\n\r\n    c) Convey individual copies of the object code with a copy of the\r\n    written offer to provide the Corresponding Source.  This\r\n    alternative is allowed only occasionally and noncommercially, and\r\n    only if you received the object code with such an offer, in accord\r\n    with subsection 6b.\r\n\r\n    d) Convey the object code by offering access from a designated\r\n    place (gratis or for a charge), and offer equivalent access to the\r\n    Corresponding Source in the same way through the same place at no\r\n    further charge.  You need not require recipients to copy the\r\n    Corresponding Source along with the object code.  If the place to\r\n    copy the object code is a network server, the Corresponding Source\r\n    may be on a different server (operated by you or a third party)\r\n    that supports equivalent copying facilities, provided you maintain\r\n    clear directions next to the object code saying where to find the\r\n    Corresponding Source.  Regardless of what server hosts the\r\n    Corresponding Source, you remain obligated to ensure that it is\r\n    available for as long as needed to satisfy these requirements.\r\n\r\n    e) Convey the object code using peer-to-peer transmission, provided\r\n    you inform other peers where the object code and Corresponding\r\n    Source of the work are being offered to the general public at no\r\n    charge under subsection 6d.\r\n\r\n  A separable portion of the object code, whose source code is excluded\r\nfrom the Corresponding Source as a System Library, need not be\r\nincluded in conveying the object code work.\r\n\r\n  A \"User Product\" is either (1) a \"consumer product\", which means any\r\ntangible personal property which is normally used for personal, family,\r\nor household purposes, or (2) anything designed or sold for incorporation\r\ninto a dwelling.  In determining whether a product is a consumer product,\r\ndoubtful cases shall be resolved in favor of coverage.  For a particular\r\nproduct received by a particular user, \"normally used\" refers to a\r\ntypical or common use of that class of product, regardless of the status\r\nof the particular user or of the way in which the particular user\r\nactually uses, or expects or is expected to use, the product.  A product\r\nis a consumer product regardless of whether the product has substantial\r\ncommercial, industrial or non-consumer uses, unless such uses represent\r\nthe only significant mode of use of the product.\r\n\r\n  \"Installation Information\" for a User Product means any methods,\r\nprocedures, authorization keys, or other information required to install\r\nand execute modified versions of a covered work in that User Product from\r\na modified version of its Corresponding Source.  The information must\r\nsuffice to ensure that the continued functioning of the modified object\r\ncode is in no case prevented or interfered with solely because\r\nmodification has been made.\r\n\r\n  If you convey an object code work under this section in, or with, or\r\nspecifically for use in, a User Product, and the conveying occurs as\r\npart of a transaction in which the right of possession and use of the\r\nUser Product is transferred to the recipient in perpetuity or for a\r\nfixed term (regardless of how the transaction is characterized), the\r\nCorresponding Source conveyed under this section must be accompanied\r\nby the Installation Information.  But this requirement does not apply\r\nif neither you nor any third party retains the ability to install\r\nmodified object code on the User Product (for example, the work has\r\nbeen installed in ROM).\r\n\r\n  The requirement to provide Installation Information does not include a\r\nrequirement to continue to provide support service, warranty, or updates\r\nfor a work that has been modified or installed by the recipient, or for\r\nthe User Product in which it has been modified or installed.  Access to a\r\nnetwork may be denied when the modification itself materially and\r\nadversely affects the operation of the network or violates the rules and\r\nprotocols for communication across the network.\r\n\r\n  Corresponding Source conveyed, and Installation Information provided,\r\nin accord with this section must be in a format that is publicly\r\ndocumented (and with an implementation available to the public in\r\nsource code form), and must require no special password or key for\r\nunpacking, reading or copying.\r\n\r\n  7. Additional Terms.\r\n\r\n  \"Additional permissions\" are terms that supplement the terms of this\r\nLicense by making exceptions from one or more of its conditions.\r\nAdditional permissions that are applicable to the entire Program shall\r\nbe treated as though they were included in this License, to the extent\r\nthat they are valid under applicable law.  If additional permissions\r\napply only to part of the Program, that part may be used separately\r\nunder those permissions, but the entire Program remains governed by\r\nthis License without regard to the additional permissions.\r\n\r\n  When you convey a copy of a covered work, you may at your option\r\nremove any additional permissions from that copy, or from any part of\r\nit.  (Additional permissions may be written to require their own\r\nremoval in certain cases when you modify the work.)  You may place\r\nadditional permissions on material, added by you to a covered work,\r\nfor which you have or can give appropriate copyright permission.\r\n\r\n  Notwithstanding any other provision of this License, for material you\r\nadd to a covered work, you may (if authorized by the copyright holders of\r\nthat material) supplement the terms of this License with terms:\r\n\r\n    a) Disclaiming warranty or limiting liability differently from the\r\n    terms of sections 15 and 16 of this License; or\r\n\r\n    b) Requiring preservation of specified reasonable legal notices or\r\n    author attributions in that material or in the Appropriate Legal\r\n    Notices displayed by works containing it; or\r\n\r\n    c) Prohibiting misrepresentation of the origin of that material, or\r\n    requiring that modified versions of such material be marked in\r\n    reasonable ways as different from the original version; or\r\n\r\n    d) Limiting the use for publicity purposes of names of licensors or\r\n    authors of the material; or\r\n\r\n    e) Declining to grant rights under trademark law for use of some\r\n    trade names, trademarks, or service marks; or\r\n\r\n    f) Requiring indemnification of licensors and authors of that\r\n    material by anyone who conveys the material (or modified versions of\r\n    it) with contractual assumptions of liability to the recipient, for\r\n    any liability that these contractual assumptions directly impose on\r\n    those licensors and authors.\r\n\r\n  All other non-permissive additional terms are considered \"further\r\nrestrictions\" within the meaning of section 10.  If the Program as you\r\nreceived it, or any part of it, contains a notice stating that it is\r\ngoverned by this License along with a term that is a further\r\nrestriction, you may remove that term.  If a license document contains\r\na further restriction but permits relicensing or conveying under this\r\nLicense, you may add to a covered work material governed by the terms\r\nof that license document, provided that the further restriction does\r\nnot survive such relicensing or conveying.\r\n\r\n  If you add terms to a covered work in accord with this section, you\r\nmust place, in the relevant source files, a statement of the\r\nadditional terms that apply to those files, or a notice indicating\r\nwhere to find the applicable terms.\r\n\r\n  Additional terms, permissive or non-permissive, may be stated in the\r\nform of a separately written license, or stated as exceptions;\r\nthe above requirements apply either way.\r\n\r\n  8. Termination.\r\n\r\n  You may not propagate or modify a covered work except as expressly\r\nprovided under this License.  Any attempt otherwise to propagate or\r\nmodify it is void, and will automatically terminate your rights under\r\nthis License (including any patent licenses granted under the third\r\nparagraph of section 11).\r\n\r\n  However, if you cease all violation of this License, then your\r\nlicense from a particular copyright holder is reinstated (a)\r\nprovisionally, unless and until the copyright holder explicitly and\r\nfinally terminates your license, and (b) permanently, if the copyright\r\nholder fails to notify you of the violation by some reasonable means\r\nprior to 60 days after the cessation.\r\n\r\n  Moreover, your license from a particular copyright holder is\r\nreinstated permanently if the copyright holder notifies you of the\r\nviolation by some reasonable means, this is the first time you have\r\nreceived notice of violation of this License (for any work) from that\r\ncopyright holder, and you cure the violation prior to 30 days after\r\nyour receipt of the notice.\r\n\r\n  Termination of your rights under this section does not terminate the\r\nlicenses of parties who have received copies or rights from you under\r\nthis License.  If your rights have been terminated and not permanently\r\nreinstated, you do not qualify to receive new licenses for the same\r\nmaterial under section 10.\r\n\r\n  9. Acceptance Not Required for Having Copies.\r\n\r\n  You are not required to accept this License in order to receive or\r\nrun a copy of the Program.  Ancillary propagation of a covered work\r\noccurring solely as a consequence of using peer-to-peer transmission\r\nto receive a copy likewise does not require acceptance.  However,\r\nnothing other than this License grants you permission to propagate or\r\nmodify any covered work.  These actions infringe copyright if you do\r\nnot accept this License.  Therefore, by modifying or propagating a\r\ncovered work, you indicate your acceptance of this License to do so.\r\n\r\n  10. Automatic Licensing of Downstream Recipients.\r\n\r\n  Each time you convey a covered work, the recipient automatically\r\nreceives a license from the original licensors, to run, modify and\r\npropagate that work, subject to this License.  You are not responsible\r\nfor enforcing compliance by third parties with this License.\r\n\r\n  An \"entity transaction\" is a transaction transferring control of an\r\norganization, or substantially all assets of one, or subdividing an\r\norganization, or merging organizations.  If propagation of a covered\r\nwork results from an entity transaction, each party to that\r\ntransaction who receives a copy of the work also receives whatever\r\nlicenses to the work the party's predecessor in interest had or could\r\ngive under the previous paragraph, plus a right to possession of the\r\nCorresponding Source of the work from the predecessor in interest, if\r\nthe predecessor has it or can get it with reasonable efforts.\r\n\r\n  You may not impose any further restrictions on the exercise of the\r\nrights granted or affirmed under this License.  For example, you may\r\nnot impose a license fee, royalty, or other charge for exercise of\r\nrights granted under this License, and you may not initiate litigation\r\n(including a cross-claim or counterclaim in a lawsuit) alleging that\r\nany patent claim is infringed by making, using, selling, offering for\r\nsale, or importing the Program or any portion of it.\r\n\r\n  11. Patents.\r\n\r\n  A \"contributor\" is a copyright holder who authorizes use under this\r\nLicense of the Program or a work on which the Program is based.  The\r\nwork thus licensed is called the contributor's \"contributor version\".\r\n\r\n  A contributor's \"essential patent claims\" are all patent claims\r\nowned or controlled by the contributor, whether already acquired or\r\nhereafter acquired, that would be infringed by some manner, permitted\r\nby this License, of making, using, or selling its contributor version,\r\nbut do not include claims that would be infringed only as a\r\nconsequence of further modification of the contributor version.  For\r\npurposes of this definition, \"control\" includes the right to grant\r\npatent sublicenses in a manner consistent with the requirements of\r\nthis License.\r\n\r\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\r\npatent license under the contributor's essential patent claims, to\r\nmake, use, sell, offer for sale, import and otherwise run, modify and\r\npropagate the contents of its contributor version.\r\n\r\n  In the following three paragraphs, a \"patent license\" is any express\r\nagreement or commitment, however denominated, not to enforce a patent\r\n(such as an express permission to practice a patent or covenant not to\r\nsue for patent infringement).  To \"grant\" such a patent license to a\r\nparty means to make such an agreement or commitment not to enforce a\r\npatent against the party.\r\n\r\n  If you convey a covered work, knowingly relying on a patent license,\r\nand the Corresponding Source of the work is not available for anyone\r\nto copy, free of charge and under the terms of this License, through a\r\npublicly available network server or other readily accessible means,\r\nthen you must either (1) cause the Corresponding Source to be so\r\navailable, or (2) arrange to deprive yourself of the benefit of the\r\npatent license for this particular work, or (3) arrange, in a manner\r\nconsistent with the requirements of this License, to extend the patent\r\nlicense to downstream recipients.  \"Knowingly relying\" means you have\r\nactual knowledge that, but for the patent license, your conveying the\r\ncovered work in a country, or your recipient's use of the covered work\r\nin a country, would infringe one or more identifiable patents in that\r\ncountry that you have reason to believe are valid.\r\n\r\n  If, pursuant to or in connection with a single transaction or\r\narrangement, you convey, or propagate by procuring conveyance of, a\r\ncovered work, and grant a patent license to some of the parties\r\nreceiving the covered work authorizing them to use, propagate, modify\r\nor convey a specific copy of the covered work, then the patent license\r\nyou grant is automatically extended to all recipients of the covered\r\nwork and works based on it.\r\n\r\n  A patent license is \"discriminatory\" if it does not include within\r\nthe scope of its coverage, prohibits the exercise of, or is\r\nconditioned on the non-exercise of one or more of the rights that are\r\nspecifically granted under this License.  You may not convey a covered\r\nwork if you are a party to an arrangement with a third party that is\r\nin the business of distributing software, under which you make payment\r\nto the third party based on the extent of your activity of conveying\r\nthe work, and under which the third party grants, to any of the\r\nparties who would receive the covered work from you, a discriminatory\r\npatent license (a) in connection with copies of the covered work\r\nconveyed by you (or copies made from those copies), or (b) primarily\r\nfor and in connection with specific products or compilations that\r\ncontain the covered work, unless you entered into that arrangement,\r\nor that patent license was granted, prior to 28 March 2007.\r\n\r\n  Nothing in this License shall be construed as excluding or limiting\r\nany implied license or other defenses to infringement that may\r\notherwise be available to you under applicable patent law.\r\n\r\n  12. No Surrender of Others' Freedom.\r\n\r\n  If conditions are imposed on you (whether by court order, agreement or\r\notherwise) that contradict the conditions of this License, they do not\r\nexcuse you from the conditions of this License.  If you cannot convey a\r\ncovered work so as to satisfy simultaneously your obligations under this\r\nLicense and any other pertinent obligations, then as a consequence you may\r\nnot convey it at all.  For example, if you agree to terms that obligate you\r\nto collect a royalty for further conveying from those to whom you convey\r\nthe Program, the only way you could satisfy both those terms and this\r\nLicense would be to refrain entirely from conveying the Program.\r\n\r\n  13. Use with the GNU Affero General Public License.\r\n\r\n  Notwithstanding any other provision of this License, you have\r\npermission to link or combine any covered work with a work licensed\r\nunder version 3 of the GNU Affero General Public License into a single\r\ncombined work, and to convey the resulting work.  The terms of this\r\nLicense will continue to apply to the part which is the covered work,\r\nbut the special requirements of the GNU Affero General Public License,\r\nsection 13, concerning interaction through a network will apply to the\r\ncombination as such.\r\n\r\n  14. Revised Versions of this License.\r\n\r\n  The Free Software Foundation may publish revised and/or new versions of\r\nthe GNU General Public License from time to time.  Such new versions will\r\nbe similar in spirit to the present version, but may differ in detail to\r\naddress new problems or concerns.\r\n\r\n  Each version is given a distinguishing version number.  If the\r\nProgram specifies that a certain numbered version of the GNU General\r\nPublic License \"or any later version\" applies to it, you have the\r\noption of following the terms and conditions either of that numbered\r\nversion or of any later version published by the Free Software\r\nFoundation.  If the Program does not specify a version number of the\r\nGNU General Public License, you may choose any version ever published\r\nby the Free Software Foundation.\r\n\r\n  If the Program specifies that a proxy can decide which future\r\nversions of the GNU General Public License can be used, that proxy's\r\npublic statement of acceptance of a version permanently authorizes you\r\nto choose that version for the Program.\r\n\r\n  Later license versions may give you additional or different\r\npermissions.  However, no additional obligations are imposed on any\r\nauthor or copyright holder as a result of your choosing to follow a\r\nlater version.\r\n\r\n  15. Disclaimer of Warranty.\r\n\r\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\r\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\r\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\r\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\r\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\r\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\r\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\r\n\r\n  16. Limitation of Liability.\r\n\r\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\r\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\r\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\r\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\r\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\r\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\r\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\r\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\r\nSUCH DAMAGES.\r\n\r\n  17. Interpretation of Sections 15 and 16.\r\n\r\n  If the disclaimer of warranty and limitation of liability provided\r\nabove cannot be given local legal effect according to their terms,\r\nreviewing courts shall apply local law that most closely approximates\r\nan absolute waiver of all civil liability in connection with the\r\nProgram, unless a warranty or assumption of liability accompanies a\r\ncopy of the Program in return for a fee.\r\n\r\n                     END OF TERMS AND CONDITIONS\r\n\r\n            How to Apply These Terms to Your New Programs\r\n\r\n  If you develop a new program, and you want it to be of the greatest\r\npossible use to the public, the best way to achieve this is to make it\r\nfree software which everyone can redistribute and change under these terms.\r\n\r\n  To do so, attach the following notices to the program.  It is safest\r\nto attach them to the start of each source file to most effectively\r\nstate the exclusion of warranty; and each file should have at least\r\nthe \"copyright\" line and a pointer to where the full notice is found.\r\n\r\n    <one line to give the program's name and a brief idea of what it does.>\r\n    Copyright (C) <year>  <name of author>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nAlso add information on how to contact you by electronic and paper mail.\r\n\r\n  If the program does terminal interaction, make it output a short\r\nnotice like this when it starts in an interactive mode:\r\n\r\n    <program>  Copyright (C) <year>  <name of author>\r\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\r\n    This is free software, and you are welcome to redistribute it\r\n    under certain conditions; type `show c' for details.\r\n\r\nThe hypothetical commands `show w' and `show c' should show the appropriate\r\nparts of the General Public License.  Of course, your program's commands\r\nmight be different; for a GUI interface, you would use an \"about box\".\r\n\r\n  You should also get your employer (if you work as a programmer) or school,\r\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\r\nFor more information on this, and how to apply and follow the GNU GPL, see\r\n<http://www.gnu.org/licenses/>.\r\n\r\n  The GNU General Public License does not permit incorporating your program\r\ninto proprietary programs.  If your program is a subroutine library, you\r\nmay consider it more useful to permit linking proprietary applications with\r\nthe library.  If this is what you want to do, use the GNU Lesser General\r\nPublic License instead of this License.  But first, please read\r\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\r\n\r\n*/"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}